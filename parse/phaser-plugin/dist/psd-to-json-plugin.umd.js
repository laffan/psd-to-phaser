(function(p,y){typeof exports=="object"&&typeof module<"u"?module.exports=y():typeof define=="function"&&define.amd?define(y):(p=typeof globalThis<"u"?globalThis:p||self,p.PsdToJSONPlugin=y())})(this,function(){"use strict";var C=Object.defineProperty;var v=(p,y,b)=>y in p?C(p,y,{enumerable:!0,configurable:!0,writable:!0,value:b}):p[y]=b;var z=(p,y,b)=>(v(p,typeof y!="symbol"?y+"":y,b),b);const D=class D{constructor(t,e=null){this.parent=e,this.children=[],this.lazyLoad=!1,this.isLoaded=!1,Object.keys(t).forEach(a=>{a==="children"?this.children=t[a].map(s=>new D(s,this)):this[a]=t[a]}),this.bbox||(this.bbox={left:this.x,top:this.y,right:this.x+this.width,bottom:this.y+this.height})}isStandardProp(t){return D.standardProps.includes(t)}getCustomAttributes(){return Object.keys(this).filter(t=>!this.isStandardProp(t)&&t!=="parent").reduce((t,e)=>(t[e]=this[e],t),{})}createDebugBox(t,e,a,s={}){if(!this.shouldDebug(a,s))return null;const n=t.add.graphics(),i=16711935,r=2;if(n.lineStyle(r,i),e==="zone"){const{left:o,top:l,right:d,bottom:h}=this.bbox,u=d-o,g=h-l;n.strokeRect(o,l,u,g)}else e==="sprite"||e==="image"?this.type==="spritesheet"?this.placement.forEach(o=>{n.strokeRect(this.x+o.x,this.y+o.y,this.frame_width,this.frame_height)}):n.strokeRect(this.x,this.y,this.width,this.height):e==="point"&&n.strokeCircle(this.x,this.y,5);return n}getTargetObject(t,e){switch(e){case"sprite":return t.children.getByName(this.name);case"zone":return t.children.getByName(this.name);case"point":return t.children.getByName(this.name);default:return null}}shouldDebug(t,e){return t.options.debug||e.debug}getPath(){return this.parent?`${this.parent.getPath()}/${this.name}`:this.name}findByPath(t){const e=t.split("/");if(e[0]===this.name){if(e.length===1)return this;const a=e[1],s=this.children.find(n=>n.name===a);return s?s.findByPath(e.slice(1).join("/")):null}return null}static place(t,e,a,s,n,i={}){if(!e||!e[a])return console.warn(`${a} data not found.`),null;let r;if(a==="tiles")r=e[a].layers.find(l=>l.name===s);else{const l=s.split("/");r=e[a].find(d=>d.name===l[0]);for(let d=1;d<l.length;d++){if(!r||!r.children)return null;r=r.children.find(h=>h.name===l[d])}}if(!r)return console.warn(`${a} '${s}' not found in PSD data.`),null;const o=n(t,r,i);return o&&(e[`placed${a.charAt(0).toUpperCase()+a.slice(1)}`]||(e[`placed${a.charAt(0).toUpperCase()+a.slice(1)}`]={}),e[`placed${a.charAt(0).toUpperCase()+a.slice(1)}`][s]=o,o.children&&this.storeNestedObjects(e,a,s,o.children)),o}static storeNestedObjects(t,e,a,s){s.forEach(n=>{const i=`${a}/${n.layerData.name}`;t[`placed${e.charAt(0).toUpperCase()+e.slice(1)}`][i]=n,n.children&&this.storeNestedObjects(t,e,i,n.children)})}static placeAll(t,e,a,s,n={}){if(!e||!e[a])return console.warn(`${a} data not found.`),null;const i=e[a].map(r=>s(t,r,n));return e[`placed${a.charAt(0).toUpperCase()+a.slice(1)}`]=i,i}static get(t,e,a){const s=`placed${e.charAt(0).toUpperCase()+e.slice(1)}`;if(!t||!t[s])return console.warn(`Placed ${e} data not found.`),null;const n=a.split("/");let i=t[s].find(r=>r.layerData.name===n[0]);for(let r=1;r<n.length;r++){if(!i||!i.children)return null;i=i.children.find(o=>o.layerData.name===n[r])}return i}static countRecursive(t){return t.reduce((e,a)=>{let s=1;return a.children&&a.children.length>0&&(s+=this.countRecursive(a.children)),e+s},0)}};z(D,"standardProps",["name","x","y","width","height","children","lazyLoad"]);let p=D;function y(c){return new p(c)}function b(c){let t=0,e=!1,a=[],s=0,n=0;return{load(i,r,o){const l=`${o}/data.json`;i.load.json(r,l),i.load.once("complete",()=>{const d=i.cache.json.get(r);this.processJSON(i,r,d,o)})},processJSON(i,r,o,l){c.psdData[r]={...o,basePath:l,sprites:o.sprites.map(d=>y(d)),zones:o.zones.map(d=>y(d)),points:o.points.map(d=>y(d))},c.options.debug&&console.log(`Loaded JSON for key "${r}":`,c.psdData[r]),this.loadAssetsFromJSON(i,r,c.psdData[r])},loadAssetsFromJSON(i,r,o){const l=this.flattenObjects(o.sprites),d=o.tiles||{};s=this.countAssets(l)+c.tiles.countTiles(d),n=0,c.options.debug&&console.log(`Total assets to load: ${s}`);const h=()=>{n++,t=n/s,i.events.emit("psdAssetsLoadProgress",t),c.options.debug&&(console.log(`Loaded asset ${n} of ${s}`),console.log(`Loading progress: ${(t*100).toFixed(2)}%`)),n===s&&(e=!0,i.events.emit("psdAssetsLoadComplete"),c.options.debug&&console.log("All PSD assets loaded"))};l.length>0&&this.loadSprites(i,l,o.basePath,h),d.layers&&d.layers.length>0&&c.tiles.load(i,d,o.basePath,h),s===0&&(e=!0,i.events.emit("psdAssetsLoadComplete")),i.load.isLoading()||i.load.start()},loadSprites(i,r,o,l){r.forEach(({path:d,obj:h})=>{if(h.lazyLoad){c.options.debug&&console.log(`Skipping load for lazy-loaded sprite: ${d}`);return}const u=`${o}/sprites/${d}.png`;h.type==="atlas"?(i.load.image(d,u),i.load.once(`filecomplete-image-${d}`,()=>{i.textures.addAtlas(d,i.textures.get(d).getSourceImage(),h.atlas_data),h.isLoaded=!0,l(),c.options.debug&&console.log(`Atlas loaded: ${d}`)})):h.type==="animation"||h.type==="spritesheet"?(i.load.spritesheet(d,u,{frameWidth:h.frame_width,frameHeight:h.frame_height}),i.load.once(`filecomplete-spritesheet-${d}`,()=>{h.isLoaded=!0,l()})):(i.load.image(d,u),i.load.once(`filecomplete-image-${d}`,()=>{h.isLoaded=!0,l()})),c.options.debug&&console.log(`Loading ${h.type==="atlas"?"atlas":h.type==="animation"?"animation spritesheet":h.type==="spritesheet"?"spritesheet":"sprite"}: ${d} from ${u}`)})},flattenObjects(i,r=""){return i.reduce((o,l)=>{const d=r?`${r}/${l.name}`:l.name;return l.lazyLoad?a.push({path:d,obj:l}):(!l.children||l.children.length===0)&&o.push({path:d,obj:l}),l.children&&o.push(...this.flattenObjects(l.children,d)),o},[])},countAssets(i){return i.reduce((r,{obj:o})=>r,0)},getLazyLoadQueue(){return a},get progress(){return t},get complete(){return e}}}function A(c){return{place(t,e,a,s={}){const n=c.getData(a);return!n||!n.points?(console.warn(`Point data for key '${a}' not found.`),null):p.place(t,n,"points",e,this.placePoint.bind(this),s)},placePoint(t,e,a={}){const{name:s,x:n,y:i}=e,r=t.add.circle(n,i,5,16777215,1);r.setName(s);const o=e.createDebugBox(t,"point",c,a);c.options.debug&&console.log(`Placed point: ${s} at (${n}, ${i})`);const l={layerData:e,point:r,debugGraphics:o};return e.children&&(l.children=e.children.map(d=>this.placePoint(t,d,a))),l},placeAll(t,e,a={}){const s=c.getData(e);return!s||!s.points?(console.warn(`Point data for key '${e}' not found.`),null):s.points.map(n=>p.place(t,s,"points",n.name,this.placePoint.bind(this),a))},get(t,e){const a=c.getData(t);return!a||!a.placedPoints?(console.warn(`Placed point data for key '${t}' not found.`),null):a.placedPoints[e]||null},countPoints(t){return p.countRecursive(t)}}}function _(c){return{place(t,e,a,s={}){const n=c.getData(a);return!n||!n.sprites?(console.warn(`Sprite data for key '${a}' not found.`),null):p.place(t,n,"sprites",e,this.placeSprite.bind(this),s)},placeSprite(t,e,a={}){const{name:s,x:n,y:i,width:r,height:o,type:l,frame_width:d,frame_height:h,placement:u,autoplacement:g=!0,lazyLoad:P,layerOrder:f}=e;let w=[],$=null;if(!e.children||e.children.length===0){if(P)return c.options.debug&&console.log(`Sprite '${e.getPath()}' is set to lazy load. Skipping placement.`),{layerData:e,sprites:[],debugGraphics:null};if(!e.isLoaded)return console.warn(`Sprite '${e.getPath()}' hasn't been loaded yet.`),{layerData:e,sprites:[],debugGraphics:null};if(l==="atlas"){const m=this.createAtlasSprite(t,e,a);m.setDepth(f),w.push(m)}else if(l==="animation"){const m=this.createAnimatedSprite(t,e,a);m.sprite.setDepth(f),w.push(m.sprite),$=m}else if(l==="spritesheet"&&g)u.forEach((m,T)=>{const O=t.add.sprite(n+m.x,i+m.y,e.getPath(),m.frame);O.setName(`${s}_${T}`),O.setDisplaySize(d,h),O.setOrigin(0,0),O.setDepth(f),w.push(O)});else if(l!=="spritesheet"||g){const m=a.useImage?t.add.image(n,i,e.getPath()):t.add.sprite(n,i,e.getPath());m.setName(s),r!==void 0&&o!==void 0&&m.setDisplaySize(r,o),m.setOrigin(0,0),m.setDepth(f),w.push(m)}}const x=e.createDebugBox(t,"sprite",c,a);x&&x.setDepth(f+.1),c.options.debug&&console.log(`Placed ${l==="atlas"?"atlas":l==="spritesheet"?"spritesheet":l==="animation"?"animated sprite":a.useImage?"image":"sprite"}: ${s} at (${n}, ${i}) with dimensions ${r}x${o} and depth ${f}`);const S={layerData:e,sprites:w,debugGraphics:x};return l==="atlas"?S.getFrameSprite=w[0].getFrameSprite:$&&(S.animation=$.animation,S.animationKey=$.animationKey,S.play=$.play,S.pause=$.pause,S.resume=$.resume,S.stop=$.stop,S.updateAnimation=$.updateAnimation),e.children&&(S.children=e.children.map(m=>this.placeSprite(t,m,a))),S},createAtlasSprite(t,e,a){const{name:s,x:n,y:i,width:r,height:o,atlas_image:l,atlas_data:d,layerOrder:h}=e;if(!t.textures.exists(l)){const g={};d.frames.forEach(f=>{g[f.name]={frame:{x:f.x,y:f.y,w:f.w,h:f.h}}});const P={frames:g,meta:d.meta};t.textures.addAtlas(l,t.textures.get(e.getPath()).getSourceImage(),P)}const u=t.add.container(n,i);return u.setName(s),d.placement.forEach((g,P)=>{const f=t.add.sprite(g.relative.x,g.relative.y,l,g.frame);f.setName(`${s}_${g.frame}`),f.setOrigin(0,0),f.setDepth(P),u.add(f)}),u.setSize(r,o),u.setDepth(h),u.getFrameSprite=g=>u.list.find(P=>P.name===`${s}_${g}`),c.options.debug&&console.log(`Created atlas sprite '${s}' with ${d.placement.length} frames at depth ${h}`),u},createAnimatedSprite(t,e,a={}){const{name:s,x:n,y:i,frame_width:r,frame_height:o,frame_count:l,columns:d,rows:h}=e,u=t.add.sprite(n,i,e.getPath());u.setName(s),u.setDisplaySize(r,o),u.setOrigin(0,0),t.textures.exists(e.getPath())||t.textures.addSpriteSheet(e.getPath(),t.textures.get(e.getPath()).getSourceImage(),{frameWidth:r,frameHeight:o,startFrame:0,endFrame:l-1,margin:0,spacing:0});const g=["frameRate","duration","delay","repeat","repeatDelay","yoyo","showOnStart","hideOnComplete","skipMissedFrames","timeScale"],P={key:`${e.getPath()}_animated`,frames:t.anims.generateFrameNumbers(e.getPath(),{start:0,end:l-1}),frameRate:10,repeat:-1};g.forEach($=>{e[$]!==void 0&&(P[$]=e[$])});const f={...P,...a.animationOptions};t.anims.exists(f.key)||t.anims.create(f),u.play(f.key);const w=$=>{const x=t.anims.get(f.key);if(x)return Object.entries($).forEach(([S,m])=>{g.includes(S)&&(x[S]=m)}),$.frames&&(x.frames=t.anims.generateFrameNumbers(e.getPath(),$.frames)),$.paused!==void 0&&($.paused?u.anims.pause():u.anims.resume()),u.play(f.key),x};return{sprite:u,animationKey:f.key,play:()=>u.play(f.key),pause:()=>u.anims.pause(),resume:()=>u.anims.resume(),stop:()=>u.anims.stop(),updateAnimation:w}},placeAll(t,e,a={}){const s=c.getData(e);return!s||!s.sprites?(console.warn(`Sprite data for key '${e}' not found.`),null):[...s.sprites].sort((i,r)=>i.layerOrder-r.layerOrder).map(i=>p.place(t,s,"sprites",i.name,this.placeSprite.bind(this),a))},get(t,e){const a=c.getData(t);if(!a||!a.sprites)return console.warn(`Sprite data for key '${t}' not found.`),null;const n=e.split("/").join("/");let i=a.placedSprites?a.placedSprites[n]:null;if(!i){const o=this.findSpriteByPath(a.sprites,n);o&&(i={layerData:o})}if(!i)return null;const{layerData:r}=i;if(r.type==="atlas"){const o=i.sprites[0];return{sprite:o,setFrame:l=>o.setFrame(l)}}else{if(r.type==="spritesheet")return{layerData:r,getSprite:(o=0)=>({texture:r.getPath(),frame:o})};if(r.type==="animation"){const o=i.sprites[0],l=o.anims.currentAnim;return{sprite:o,animation:l,animationKey:l.key,play:()=>o.play(l.key),pause:()=>o.anims.pause(),resume:()=>o.anims.resume(),stop:()=>o.anims.stop(),updateAnimation:d=>{}}}}return i.sprites[0]},getTexture(t,e){const a=c.getData(t);if(!a||!a.sprites)return console.warn(`Sprite data for key '${t}' not found.`),null;const s=this.findSpriteByPath(a.sprites,e);if(!s)return console.warn(`Sprite '${e}' not found.`),null;if(s.type==="atlas"){const n=e.split("/");return n.length>1?{texture:s.atlas_image,frame:n[n.length-1]}:Object.keys(s.atlas_data.frames).map(i=>({texture:s.atlas_image,frame:i}))}else if(s.type==="spritesheet")return s.getPath();return e},findSpriteByPath(t,e){const a=e.split("/");let s=t.find(n=>n.name===a[0]);for(let n=1;n<a.length;n++){if(!s||!s.children)return null;s=s.children.find(i=>i.name===a[n])}return s},countSprites(t){return p.countRecursive(t)},loadSprites(t,e,a,s){e.forEach(({path:n,obj:i})=>{if(i.lazyLoad){c.options.debug&&console.log(`Skipping load for lazy-loaded sprite: ${n}`);return}const r=`${a}/sprites/${n}.png`;i.type==="atlas"?t.load.atlas(n,r,i.atlas_data):i.type==="animation"||i.type==="spritesheet"?t.load.spritesheet(n,r,{frameWidth:i.frame_width,frameHeight:i.frame_height}):t.load.image(n,r),t.load.once(`filecomplete-${i.type==="atlas"?"atlas":i.type==="animation"||i.type==="spritesheet"?"spritesheet":"image"}-${n}`,()=>{i.isLoaded=!0,s()}),c.options.debug&&console.log(`Loading ${i.type==="atlas"?"atlas":i.type==="animation"?"animation spritesheet":i.type==="spritesheet"?"spritesheet":"sprite"}: ${n} from ${r}`)})}}}function L(c){return{load(t,e,a,s){if(!e||!e.layers||e.layers.length===0){console.warn("No tiles to load or invalid tiles data");return}e.layers.forEach(n=>{for(let i=0;i<e.columns;i++)for(let r=0;r<e.rows;r++){const o=`${n.name}_tile_${i}_${r}`,l=`${a}/tiles/${e.tile_slice_size}/${o}.jpg`;t.load.image(o,l),t.load.once(`filecomplete-image-${o}`,s),c.options.debug&&console.log(`Loading tile: ${o} from ${l}`)}})},countTiles(t){return!t||!t.layers?0:t.layers.length*t.columns*t.rows},place(t,e,a,s={}){const n=c.getData(a);return!n||!n.tiles?(console.warn(`Tiles data for key '${a}' not found.`),null):p.place(t,n,"tiles",e,this.placeTileLayer.bind(this),{...s,psdKey:a,tilesData:n.tiles})},placeTileLayer(t,e,a){const{tilesData:s}=a,n=t.add.container(0,0);n.setName(e.name);for(let r=0;r<s.columns;r++)for(let o=0;o<s.rows;o++){const l=`${e.name}_tile_${r}_${o}`,d=r*s.tile_slice_size,h=o*s.tile_slice_size;if(t.textures.exists(l)){const u=t.add.image(d,h,l).setOrigin(0,0);n.add(u),c.options.debug&&console.log(`Placed tile: ${l} at (${d}, ${h})`)}else console.warn(`Texture for tile ${l} not found`)}const i=this.addDebugVisualization(t,e,s,a);return i&&n.add(i),{layerData:e,tileLayer:n,debugGraphics:i}},placeAll(t,e,a={}){const s=c.getData(e);return!s||!s.tiles||!s.tiles.layers?(console.warn(`Tiles data for key '${e}' not found.`),null):s.tiles.layers.map(n=>this.place(t,n.name,e,a))},get(t,e){const a=c.getData(t);return!a||!a.placedTiles?(console.warn(`Placed tile layer data for key '${t}' not found.`),null):a.placedTiles[e]||null},addDebugVisualization(t,e,a,s){if(!s.debug&&!c.options.debug)return null;const n=t.add.graphics();n.lineStyle(2,16711935,1);const i=a.columns*a.tile_slice_size,r=a.rows*a.tile_slice_size;return n.strokeRect(0,0,i,r),n}}}function N(c){return{place(t,e,a,s={}){const n=c.getData(a);return!n||!n.zones?(console.warn(`Zone data for key '${a}' not found.`),null):p.place(t,n,"zones",e,this.placeZone.bind(this),s)},placeZone(t,e,a={}){const{name:s,bbox:n}=e,{left:i,top:r,right:o,bottom:l}=n,d=o-i,h=l-r,u=t.add.zone(i,r,d,h);u.setName(s);const g=e.createDebugBox(t,"zone",c,a);c.options.debug&&console.log(`Placed zone: ${s} at (${i}, ${r}) with dimensions ${d}x${h}`);const P={layerData:e,zone:u,debugGraphics:g};return e.children&&(P.children=e.children.map(f=>this.placeZone(t,f,a))),P},placeAll(t,e,a={}){const s=c.getData(e);return!s||!s.zones?(console.warn(`Zone data for key '${e}' not found.`),null):s.zones.map(n=>p.place(t,s,"zones",n.name,this.placeZone.bind(this),a))},get(t,e){const a=c.getData(t);return!a||!a.placedZones?(console.warn(`Placed zone data for key '${t}' not found.`),null):a.placedZones[e]||null},countZones(t){return p.countRecursive(t)}}}class k extends Phaser.Plugins.BasePlugin{constructor(t){super(t),this.psdData={},this.options={debug:!1}}boot(){this.pluginManager.game.events.once("destroy",this.destroy,this)}init(t={}){this.options={...this.options,...t},this.data=b(this),this.points=A(this),this.sprites=_(this),this.tiles=L(this),this.zones=N(this),this.options.debug&&console.log("PsdToJSONPlugin initialized with options:",this.options)}load(t,e,a){this.data.load(t,e,a)}getData(t){return this.psdData[t]}}return k});
