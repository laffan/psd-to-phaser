(function(u,p){typeof exports=="object"&&typeof module<"u"?module.exports=p():typeof define=="function"&&define.amd?define(p):(u=typeof globalThis<"u"?globalThis:u||self,u.PsdToJSONPlugin=p())})(this,function(){"use strict";var k=Object.defineProperty;var B=(u,p,w)=>p in u?k(u,p,{enumerable:!0,configurable:!0,writable:!0,value:w}):u[p]=w;var O=(u,p,w)=>(B(u,typeof p!="symbol"?p+"":p,w),w);const S=class S{constructor(t,e=null){this.parent=e,this.children=[],this.lazyLoad=!1,this.isLoaded=!1,Object.keys(t).forEach(n=>{n==="children"?this.children=t[n].map(s=>new S(s,this)):this[n]=t[n]}),this.bbox||(this.bbox={left:this.x,top:this.y,right:this.x+this.width,bottom:this.y+this.height})}isStandardProp(t){return S.standardProps.includes(t)}getCustomAttributes(){return Object.keys(this).filter(t=>!this.isStandardProp(t)&&t!=="parent").reduce((t,e)=>(t[e]=this[e],t),{})}createDebugBox(t,e,n,s={}){if(!this.shouldDebug(n,s))return null;let i,o=16711935;if(e==="zone"){const{left:a,top:r,right:l,bottom:d}=this.bbox,h=l-a,m=d-r;i=t.add.rectangle(a,r,h,m,o,.5),i.setOrigin(0,0)}else e==="sprite"||e==="image"?this.type==="spritesheet"?(i=t.add.group(),this.placement.forEach(a=>{const r=t.add.rectangle(this.x+a.x,this.y+a.y,this.frame_width,this.frame_height,o,.5);r.setOrigin(0,0),i.add(r)})):(i=t.add.rectangle(this.x,this.y,this.width,this.height,o,.5),i.setOrigin(0,0)):e==="point"&&(i=t.add.circle(this.x,this.y,5,o,.5));return i}getTargetObject(t,e){switch(e){case"sprite":return t.children.getByName(this.name);case"zone":return t.children.getByName(this.name);case"point":return t.children.getByName(this.name);default:return null}}shouldDebug(t,e){return t.options.debug||e.debug}getPath(){return this.parent?`${this.parent.getPath()}/${this.name}`:this.name}findByPath(t){const e=t.split("/");if(e[0]===this.name){if(e.length===1)return this;const n=e[1],s=this.children.find(i=>i.name===n);return s?s.findByPath(e.slice(1).join("/")):null}return null}static place(t,e,n,s,i,o={}){if(!e||!e[n])return console.warn(`${n} data not found.`),null;let a;if(n==="tiles")a=e[n].layers.find(l=>l.name===s);else{const l=s.split("/");a=e[n].find(d=>d.name===l[0]);for(let d=1;d<l.length;d++){if(!a||!a.children)return null;a=a.children.find(h=>h.name===l[d])}}if(!a)return console.warn(`${n} '${s}' not found in PSD data.`),null;const r=i(t,a,o);return r&&(e[`placed${n.charAt(0).toUpperCase()+n.slice(1)}`]||(e[`placed${n.charAt(0).toUpperCase()+n.slice(1)}`]={}),e[`placed${n.charAt(0).toUpperCase()+n.slice(1)}`][s]=r,r.children&&this.storeNestedObjects(e,n,s,r.children)),r}static storeNestedObjects(t,e,n,s){s.forEach(i=>{const o=`${n}/${i.layerData.name}`;t[`placed${e.charAt(0).toUpperCase()+e.slice(1)}`][o]=i,i.children&&this.storeNestedObjects(t,e,o,i.children)})}static placeAll(t,e,n,s,i={}){if(!e||!e[n])return console.warn(`${n} data not found.`),null;const o=e[n].map(a=>s(t,a,i));return e[`placed${n.charAt(0).toUpperCase()+n.slice(1)}`]=o,o}static get(t,e,n){const s=`placed${e.charAt(0).toUpperCase()+e.slice(1)}`;if(!t||!t[s])return console.warn(`Placed ${e} data not found.`),null;const i=n.split("/");let o=t[s].find(a=>a.layerData.name===i[0]);for(let a=1;a<i.length;a++){if(!o||!o.children)return null;o=o.children.find(r=>r.layerData.name===i[a])}return o}static countRecursive(t){return t.reduce((e,n)=>{let s=1;return n.children&&n.children.length>0&&(s+=this.countRecursive(n.children)),e+s},0)}};O(S,"standardProps",["name","x","y","width","height","children","lazyLoad"]);let u=S;function p(c){return new u(c)}function w(c){let t=0,e=!1,n=[];return{load(s,i,o){const a=`${o}/data.json`;s.load.json(i,a),s.load.once("complete",()=>{const r=s.cache.json.get(i);this.processJSON(s,i,r,o)})},processJSON(s,i,o,a){c.psdData[i]={...o,basePath:a,sprites:o.sprites.map(r=>p(r)),zones:o.zones.map(r=>p(r)),points:o.points.map(r=>p(r))},c.options.debug&&console.log(`Loaded JSON for key "${i}":`,c.psdData[i]),this.loadAssetsFromJSON(s,i,c.psdData[i])},loadAssetsFromJSON(s,i,o){const a=this.flattenObjects(o.sprites),r=o.tiles||{};let l=this.countAssets(a)+c.tiles.countTiles(r),d=0;c.options.debug&&console.log(`Total assets to load: ${l}`);const h=()=>{d++,t=d/l,s.events.emit("psdAssetsLoadProgress",t),c.options.debug&&(console.log(`Loaded asset ${d} of ${l}`),console.log(`Loading progress: ${(t*100).toFixed(2)}%`)),d===l&&(e=!0,s.events.emit("psdAssetsLoadComplete"),c.options.debug&&console.log("All PSD assets loaded"))};a.length>0&&this.loadSprites(s,a,o.basePath,h),r.layers&&r.layers.length>0&&c.tiles.load(s,r,o.basePath,h),l===0&&(e=!0,s.events.emit("psdAssetsLoadComplete")),s.load.isLoading()||s.load.start()},flattenObjects(s,i=""){return s.reduce((o,a)=>{const r=i?`${i}/${a.name}`:a.name;return a.lazyLoad?n.push({path:r,obj:a}):(!a.children||a.children.length===0)&&o.push({path:r,obj:a}),a.children&&o.push(...this.flattenObjects(a.children,r)),o},[])},loadSprites(s,i,o,a){i.forEach(({path:r,obj:l})=>{if(l.lazyLoad){c.options.debug&&console.log(`Skipping load for lazy-loaded sprite: ${r}`);return}const d=`${o}/sprites/${r}.png`;l.type==="animation"||l.type==="spritesheet"?s.load.spritesheet(r,d,{frameWidth:l.frame_width,frameHeight:l.frame_height}):s.load.image(r,d),s.load.once(`filecomplete-${l.type==="animation"||l.type==="spritesheet"?"spritesheet":"image"}-${r}`,()=>{l.isLoaded=!0,a()}),c.options.debug&&console.log(`Loading ${l.type==="animation"?"animation spritesheet":l.type==="spritesheet"?"spritesheet":"sprite"}: ${r} from ${d}`)})},countAssets(s){return s.length},getLazyLoadQueue(){return n},get progress(){return t},get complete(){return e}}}function x(c){return{place(t,e,n,s={}){const i=c.getData(n);return!i||!i.points?(console.warn(`Point data for key '${n}' not found.`),null):u.place(t,i,"points",e,this.placePoint.bind(this),s)},placePoint(t,e,n={}){const{name:s,x:i,y:o}=e,a=t.add.circle(i,o,5,16777215,1);a.setName(s);const r=e.createDebugBox(t,"point",c,n);c.options.debug&&console.log(`Placed point: ${s} at (${i}, ${o})`);const l={layerData:e,point:a,debugGraphics:r};return e.children&&(l.children=e.children.map(d=>this.placePoint(t,d,n))),l},placeAll(t,e,n={}){const s=c.getData(e);return!s||!s.points?(console.warn(`Point data for key '${e}' not found.`),null):s.points.map(i=>u.place(t,s,"points",i.name,this.placePoint.bind(this),n))},get(t,e){const n=c.getData(t);return!n||!n.placedPoints?(console.warn(`Placed point data for key '${t}' not found.`),null):n.placedPoints[e]||null},countPoints(t){return u.countRecursive(t)}}}function A(c){return{place(t,e,n,s={}){const i=c.getData(n);return!i||!i.sprites?(console.warn(`Sprite data for key '${n}' not found.`),null):u.place(t,i,"sprites",e,this.placeSprite.bind(this),s)},placeSprite(t,e,n={}){const{name:s,x:i,y:o,width:a,height:r,type:l,frame_width:d,frame_height:h,placement:m,autoplacement:$=!0,lazyLoad:b}=e;let f=[],y=null;if(!e.children||e.children.length===0){if(b)return c.options.debug&&console.log(`Sprite '${e.getPath()}' is set to lazy load. Skipping placement.`),{layerData:e,sprites:[],debugGraphics:null};if(!e.isLoaded)return console.warn(`Sprite '${e.getPath()}' hasn't been loaded yet.`),{layerData:e,sprites:[],debugGraphics:null};if(l==="animation"){const g=this.createAnimatedSprite(t,e,n);f.push(g.sprite),y=g}else if(l==="spritesheet"&&$)m.forEach((g,T)=>{const D=t.add.sprite(i+g.x,o+g.y,e.getPath(),g.frame);D.setName(`${s}_${T}`),D.setDisplaySize(d,h),D.setOrigin(0,0),f.push(D)});else if(l!=="spritesheet"||$){const g=n.useImage?t.add.image(i,o,e.getPath()):t.add.sprite(i,o,e.getPath());g.setName(s),a!==void 0&&r!==void 0&&g.setDisplaySize(a,r),g.setOrigin(0,0),f.push(g)}}const z=$&&!b?e.createDebugBox(t,"sprite",c,n):null;c.options.debug&&$&&!b&&console.log(`Placed ${l==="spritesheet"?"spritesheet":l==="animation"?"animated sprite":n.useImage?"image":"sprite"}: ${s} at (${i}, ${o}) with dimensions ${d||a}x${h||r}`);const P={layerData:e,sprites:f,debugGraphics:z};return y&&(P.animation=y.animation,P.animationKey=y.animationKey,P.play=y.play,P.pause=y.pause,P.resume=y.resume,P.stop=y.stop),e.children&&(P.children=e.children.map(g=>this.placeSprite(t,g,n))),P},placeSpritesheet(t,e,n,s,i,o=0){const a=c.getData(e);if(!a||!a.sprites)return console.warn(`Sprite data for key '${e}' not found.`),null;const r=this.findSpriteByPath(a.sprites,n);if(!r||r.type!=="spritesheet")return console.warn(`Spritesheet '${n}' not found or is not a spritesheet.`),null;const l=t.add.sprite(s,i,n,o);return l.setDisplaySize(r.frame_width,r.frame_height),l.setOrigin(0,0),l},createAnimatedSprite(t,e,n={}){const{name:s,x:i,y:o,frame_width:a,frame_height:r}=e,l=t.add.sprite(i,o,e.getPath());l.setName(s),l.setDisplaySize(a,r),l.setOrigin(0,0);const d=["frameRate","duration","delay","repeat","repeatDelay","yoyo","showOnStart","hideOnComplete","skipMissedFrames","timeScale"],h={key:`${e.getPath()}_animated`,frames:t.anims.generateFrameNumbers(e.getPath(),{start:0,end:e.frame_count-1}),frameRate:10,repeat:-1,play:!0};d.forEach(f=>{e[f]!==void 0&&(h[f]=e[f])});const m={...h,...n.animationOptions},$=t.anims.create(m);m.play&&l.play(m.key);const b=f=>(Object.entries(f).forEach(([y,z])=>{d.includes(y)&&($[y]=z)}),f.frames&&($.frames=t.anims.generateFrameNumbers(e.getPath(),f.frames)),f.paused!==void 0&&(f.paused?l.anims.pause():l.anims.resume()),l.anims.play($),$);return{sprite:l,animation:$,animationKey:m.key,play:()=>l.play(m.key),pause:()=>l.anims.pause(),resume:()=>l.anims.resume(),stop:()=>l.anims.stop(),updateAnimation:b}},placeAll(t,e,n={}){const s=c.getData(e);return!s||!s.sprites?(console.warn(`Sprite data for key '${e}' not found.`),null):s.sprites.map(i=>u.place(t,s,"sprites",i.name,this.placeSprite.bind(this),n))},get(t,e){const n=c.getData(t);if(!n||!n.sprites)return console.warn(`Sprite data for key '${t}' not found.`),null;const i=e.split("/").join("/");let o=n.placedSprites?n.placedSprites[i]:null;if(!o){const r=this.findSpriteByPath(n.sprites,i);r&&(o={layerData:r})}if(!o)return null;const{layerData:a}=o;if(a.type==="spritesheet")return{layerData:a,getSprite:(r=0)=>({texture:a.getPath(),frame:r})};if(a.type==="animation"){const r=o.sprites[0],l=r.anims.currentAnim;return{sprite:r,animation:l,animationKey:l.key,play:()=>r.play(l.key),pause:()=>r.anims.pause(),resume:()=>r.anims.resume(),stop:()=>r.anims.stop(),updateAnimation:d=>{}}}return o.sprites[0]},getTexture(t,e){const n=c.getData(t);return!n||!n.sprites?(console.warn(`Sprite data for key '${t}' not found.`),null):this.findSpriteByPath(n.sprites,e)?e:(console.warn(`Sprite '${e}' not found.`),null)},findSpriteByPath(t,e){const n=e.split("/");let s=t.find(i=>i.name===n[0]);for(let i=1;i<n.length;i++){if(!s||!s.children)return null;s=s.children.find(o=>o.name===n[i])}return s},countSprites(t){return u.countRecursive(t)}}}function _(c){return{load(t,e,n,s){if(!e||!e.layers||e.layers.length===0){console.warn("No tiles to load or invalid tiles data");return}e.layers.forEach(i=>{for(let o=0;o<e.columns;o++)for(let a=0;a<e.rows;a++){const r=`${i.name}_tile_${o}_${a}`,l=`${n}/tiles/${e.tile_slice_size}/${r}.jpg`;t.load.image(r,l),t.load.once(`filecomplete-image-${r}`,s),c.options.debug&&console.log(`Loading tile: ${r} from ${l}`)}})},countTiles(t){return!t||!t.layers?0:t.layers.length*t.columns*t.rows},place(t,e,n,s={}){const i=c.getData(n);return!i||!i.tiles?(console.warn(`Tiles data for key '${n}' not found.`),null):u.place(t,i,"tiles",e,this.placeTileLayer.bind(this),{...s,psdKey:n,tilesData:i.tiles})},placeTileLayer(t,e,n){const{tilesData:s}=n,i=t.add.container(0,0);i.setName(e.name);for(let a=0;a<s.columns;a++)for(let r=0;r<s.rows;r++){const l=`${e.name}_tile_${a}_${r}`,d=a*s.tile_slice_size,h=r*s.tile_slice_size;if(t.textures.exists(l)){const m=t.add.image(d,h,l).setOrigin(0,0);i.add(m),c.options.debug&&console.log(`Placed tile: ${l} at (${d}, ${h})`)}else console.warn(`Texture for tile ${l} not found`)}const o=this.addDebugVisualization(t,e,s,n);return o&&i.add(o),{layerData:e,tileLayer:i,debugGraphics:o}},placeAll(t,e,n={}){const s=c.getData(e);return!s||!s.tiles||!s.tiles.layers?(console.warn(`Tiles data for key '${e}' not found.`),null):s.tiles.layers.map(i=>this.place(t,i.name,e,n))},get(t,e){const n=c.getData(t);return!n||!n.placedTiles?(console.warn(`Placed tile layer data for key '${t}' not found.`),null):n.placedTiles[e]||null},addDebugVisualization(t,e,n,s){if(!s.debug&&!c.options.debug)return null;const i=t.add.graphics();i.lineStyle(2,16711935,1);const o=n.columns*n.tile_slice_size,a=n.rows*n.tile_slice_size;return i.strokeRect(0,0,o,a),i}}}function L(c){return{place(t,e,n,s={}){const i=c.getData(n);return!i||!i.zones?(console.warn(`Zone data for key '${n}' not found.`),null):u.place(t,i,"zones",e,this.placeZone.bind(this),s)},placeZone(t,e,n={}){const{name:s,bbox:i}=e,{left:o,top:a,right:r,bottom:l}=i,d=r-o,h=l-a,m=t.add.zone(o,a,d,h);m.setName(s);const $=e.createDebugBox(t,"zone",c,n);c.options.debug&&console.log(`Placed zone: ${s} at (${o}, ${a}) with dimensions ${d}x${h}`);const b={layerData:e,zone:m,debugGraphics:$};return e.children&&(b.children=e.children.map(f=>this.placeZone(t,f,n))),b},placeAll(t,e,n={}){const s=c.getData(e);return!s||!s.zones?(console.warn(`Zone data for key '${e}' not found.`),null):s.zones.map(i=>u.place(t,s,"zones",i.name,this.placeZone.bind(this),n))},get(t,e){const n=c.getData(t);return!n||!n.placedZones?(console.warn(`Placed zone data for key '${t}' not found.`),null):n.placedZones[e]||null},countZones(t){return u.countRecursive(t)}}}class N extends Phaser.Plugins.BasePlugin{constructor(t){super(t),this.psdData={},this.options={debug:!1}}boot(){this.pluginManager.game.events.once("destroy",this.destroy,this)}init(t={}){this.options={...this.options,...t},this.data=w(this),this.points=x(this),this.sprites=A(this),this.tiles=_(this),this.zones=L(this),this.options.debug&&console.log("PsdToJSONPlugin initialized with options:",this.options)}load(t,e,n){this.data.load(t,e,n)}getData(t){return this.psdData[t]}}return N});
