(function(h,p){typeof exports=="object"&&typeof module<"u"?module.exports=p():typeof define=="function"&&define.amd?define(p):(h=typeof globalThis<"u"?globalThis:h||self,h.PsdToJSONPlugin=p())})(this,function(){"use strict";var A=Object.defineProperty;var L=(h,p,$)=>p in h?A(h,p,{enumerable:!0,configurable:!0,writable:!0,value:$}):h[p]=$;var w=(h,p,$)=>(L(h,typeof p!="symbol"?p+"":p,$),$);const b=class b{constructor(t,e=null){this.parent=e,this.children=[],this.lazyLoad=!1,this.isLoaded=!1,Object.keys(t).forEach(n=>{n==="children"?this.children=t[n].map(a=>new b(a,this)):this[n]=t[n]}),this.bbox||(this.bbox={left:this.x,top:this.y,right:this.x+this.width,bottom:this.y+this.height})}isStandardProp(t){return b.standardProps.includes(t)}getCustomAttributes(){return Object.keys(this).filter(t=>!this.isStandardProp(t)&&t!=="parent").reduce((t,e)=>(t[e]=this[e],t),{})}createDebugBox(t,e,n,a={}){if(!this.shouldDebug(n,a))return null;let i,o=16711935;if(e==="zone"){const{left:s,top:r,right:l,bottom:c}=this.bbox,u=l-s,m=c-r;i=t.add.rectangle(s,r,u,m,o,.5),i.setOrigin(0,0)}else e==="sprite"||e==="image"?(i=t.add.rectangle(this.x,this.y,this.width,this.height,o,.5),i.setOrigin(0,0)):e==="point"&&(i=t.add.circle(this.x,this.y,5,o,.5));return i}getTargetObject(t,e){switch(e){case"sprite":return t.children.getByName(this.name);case"zone":return t.children.getByName(this.name);case"point":return t.children.getByName(this.name);default:return null}}shouldDebug(t,e){return t.options.debug||e.debug}getPath(){return this.parent?`${this.parent.getPath()}/${this.name}`:this.name}findByPath(t){const e=t.split("/");if(e[0]===this.name){if(e.length===1)return this;const n=e[1],a=this.children.find(i=>i.name===n);return a?a.findByPath(e.slice(1).join("/")):null}return null}static place(t,e,n,a,i,o={}){if(!e||!e[n])return console.warn(`${n} data not found.`),null;let s;if(n==="tiles")s=e[n].layers.find(l=>l.name===a);else{const l=a.split("/");s=e[n].find(c=>c.name===l[0]);for(let c=1;c<l.length;c++){if(!s||!s.children)return null;s=s.children.find(u=>u.name===l[c])}}if(!s)return console.warn(`${n} '${a}' not found in PSD data.`),null;const r=i(t,s,o);return r&&(e[`placed${n.charAt(0).toUpperCase()+n.slice(1)}`]||(e[`placed${n.charAt(0).toUpperCase()+n.slice(1)}`]={}),e[`placed${n.charAt(0).toUpperCase()+n.slice(1)}`][a]=r,r.children&&this.storeNestedObjects(e,n,a,r.children)),r}static storeNestedObjects(t,e,n,a){a.forEach(i=>{const o=`${n}/${i.layerData.name}`;t[`placed${e.charAt(0).toUpperCase()+e.slice(1)}`][o]=i,i.children&&this.storeNestedObjects(t,e,o,i.children)})}static placeAll(t,e,n,a,i={}){if(!e||!e[n])return console.warn(`${n} data not found.`),null;const o=e[n].map(s=>a(t,s,i));return e[`placed${n.charAt(0).toUpperCase()+n.slice(1)}`]=o,o}static get(t,e,n){const a=`placed${e.charAt(0).toUpperCase()+e.slice(1)}`;if(!t||!t[a])return console.warn(`Placed ${e} data not found.`),null;const i=n.split("/");let o=t[a].find(s=>s.layerData.name===i[0]);for(let s=1;s<i.length;s++){if(!o||!o.children)return null;o=o.children.find(r=>r.layerData.name===i[s])}return o}static countRecursive(t){return t.reduce((e,n)=>{let a=1;return n.children&&n.children.length>0&&(a+=this.countRecursive(n.children)),e+a},0)}};w(b,"standardProps",["name","x","y","width","height","children","lazyLoad"]);let h=b;function p(d){return new h(d)}function $(d){let t=0,e=!1,n=[];return{load(a,i,o){const s=`${o}/data.json`;a.load.json(i,s),a.load.once("complete",()=>{const r=a.cache.json.get(i);this.processJSON(a,i,r,o)})},processJSON(a,i,o,s){d.psdData[i]={...o,basePath:s,sprites:o.sprites.map(r=>p(r)),zones:o.zones.map(r=>p(r)),points:o.points.map(r=>p(r))},d.options.debug&&console.log(`Loaded JSON for key "${i}":`,d.psdData[i]),this.loadAssetsFromJSON(a,i,d.psdData[i])},loadAssetsFromJSON(a,i,o){const s=this.flattenObjects(o.sprites),r=o.tiles||{};let l=this.countAssets(s)+d.tiles.countTiles(r),c=0;d.options.debug&&console.log(`Total assets to load: ${l}`);const u=()=>{c++,t=c/l,a.events.emit("psdAssetsLoadProgress",t),d.options.debug&&(console.log(`Loaded asset ${c} of ${l}`),console.log(`Loading progress: ${(t*100).toFixed(2)}%`)),c===l&&(e=!0,a.events.emit("psdAssetsLoadComplete"),d.options.debug&&console.log("All PSD assets loaded"))};s.length>0&&this.loadSprites(a,s,o.basePath,u),r.layers&&r.layers.length>0&&d.tiles.load(a,r,o.basePath,u),l===0&&(e=!0,a.events.emit("psdAssetsLoadComplete")),a.load.isLoading()||a.load.start()},flattenObjects(a,i=""){return a.reduce((o,s)=>{const r=i?`${i}/${s.name}`:s.name;return s.lazyLoad?n.push({path:r,obj:s}):(!s.children||s.children.length===0)&&o.push({path:r,obj:s}),s.children&&o.push(...this.flattenObjects(s.children,r)),o},[])},loadSprites(a,i,o,s){i.forEach(({path:r,obj:l})=>{const c=`${o}/sprites/${r}.png`;l.type==="animation"?a.load.spritesheet(r,c,{frameWidth:l.frame_width,frameHeight:l.frame_height}):a.load.image(r,c),a.load.once(`filecomplete-${l.type==="animation"?"spritesheet":"image"}-${r}`,()=>{l.isLoaded=!0,s()}),d.options.debug&&console.log(`Loading ${l.type==="animation"?"spritesheet":"sprite"}: ${r} from ${c}`)})},countAssets(a){return a.length},getLazyLoadQueue(){return n},get progress(){return t},get complete(){return e}}}function D(d){return{place(t,e,n,a={}){const i=d.getData(n);return!i||!i.points?(console.warn(`Point data for key '${n}' not found.`),null):h.place(t,i,"points",e,this.placePoint.bind(this),a)},placePoint(t,e,n={}){const{name:a,x:i,y:o}=e,s=t.add.circle(i,o,5,16777215,1);s.setName(a);const r=e.createDebugBox(t,"point",d,n);d.options.debug&&console.log(`Placed point: ${a} at (${i}, ${o})`);const l={layerData:e,point:s,debugGraphics:r};return e.children&&(l.children=e.children.map(c=>this.placePoint(t,c,n))),l},placeAll(t,e,n={}){const a=d.getData(e);return!a||!a.points?(console.warn(`Point data for key '${e}' not found.`),null):a.points.map(i=>h.place(t,a,"points",i.name,this.placePoint.bind(this),n))},get(t,e){const n=d.getData(t);return!n||!n.placedPoints?(console.warn(`Placed point data for key '${t}' not found.`),null):n.placedPoints[e]||null},countPoints(t){return h.countRecursive(t)}}}function S(d){return{place(t,e,n,a={}){const i=d.getData(n);return!i||!i.sprites?(console.warn(`Sprite data for key '${n}' not found.`),null):h.place(t,i,"sprites",e,this.placeSprite.bind(this),a)},placeSprite(t,e,n={}){const{name:a,x:i,y:o,width:s,height:r,type:l}=e;let c=null,u=null;if(!e.children||e.children.length===0)if(e.lazyLoad&&!e.isLoaded)console.warn(`Sprite '${e.getPath()}' is set to lazy load and hasn't been loaded yet.`);else{if(l==="animation"){const f=this.createAnimatedSprite(t,e,n);c=f.sprite,u=f}else c=n.useImage?t.add.image(i,o,e.getPath()):t.add.sprite(i,o,e.getPath());c.setName(a),s!==void 0&&r!==void 0&&c.setDisplaySize(s,r),c.setOrigin(0,0)}const m=e.createDebugBox(t,"sprite",d,n);m&&m.setPosition(i,o),d.options.debug&&console.log(`Placed ${l==="animation"?"animated sprite":n.useImage?"image":"sprite"}: ${a} at (${i}, ${o}) with dimensions ${s}x${r}`);const g={layerData:e,debugBox:m};if(c){g[l==="animation"?"sprite":n.useImage?"image":"sprite"]=c,u&&(g.animation=u.animation,g.animationKey=u.animationKey,g.play=u.play,g.pause=u.pause,g.resume=u.resume,g.stop=u.stop),c.on("changeposition",()=>{m&&m.setPosition(c.x,c.y)});const f=c.setPosition;c.setPosition=function(P,y){f.call(this,P,y),this.emit("changeposition")}}return e.children&&(g.children=e.children.map(f=>this.placeSprite(t,f,n))),g},createAnimatedSprite(t,e,n={}){const{name:a,x:i,y:o,frame_count:s}=e,r=t.add.sprite(i,o,e.getPath()),l=["frameRate","duration","delay","repeat","repeatDelay","yoyo","showOnStart","hideOnComplete","skipMissedFrames","timeScale"],c={key:`${e.getPath()}_animated`,frames:t.anims.generateFrameNumbers(e.getPath(),{start:0,end:s-1}),frameRate:10,repeat:-1,play:!0};l.forEach(f=>{e[f]!==void 0&&(c[f]=e[f])});const u={...c,...n.animationOptions},m=t.anims.create(u);u.play&&r.play(u.key);const g=f=>(Object.entries(f).forEach(([P,y])=>{l.includes(P)&&(m[P]=y)}),f.frames&&(m.frames=t.anims.generateFrameNumbers(e.getPath(),f.frames)),f.paused!==void 0&&(f.paused?r.anims.pause():r.anims.resume()),r.anims.play(m),m);return{sprite:r,animation:m,animationKey:u.key,play:()=>r.play(u.key),pause:()=>r.anims.pause(),resume:()=>r.anims.resume(),stop:()=>r.anims.stop(),updateAnimation:g}},placeAll(t,e,n={}){const a=d.getData(e);return!a||!a.sprites?(console.warn(`Sprite data for key '${e}' not found.`),null):a.sprites.map(i=>h.place(t,a,"sprites",i.name,this.placeSprite.bind(this),n))},get(t,e){const n=d.getData(t);if(!n||!n.placedSprites)return console.warn(`Placed sprite data for key '${t}' not found.`),null;const a=n.placedSprites[e];if(!a)return null;if(a.layerData.type==="animation"){const i=a.sprite,o=i.anims.currentAnim;return{sprite:i,animation:o,animationKey:o.key,play:()=>i.play(o.key),pause:()=>i.anims.pause(),resume:()=>i.anims.resume(),stop:()=>i.anims.stop(),updateAnimation:s=>{const r=["frameRate","duration","delay","repeat","repeatDelay","yoyo","showOnStart","hideOnComplete","skipMissedFrames","timeScale"];return Object.entries(s).forEach(([l,c])=>{r.includes(l)&&(o[l]=c)}),s.frames&&(o.frames=i.anims.generateFrameNames(i.texture.key,s.frames)),s.paused!==void 0&&(s.paused?i.anims.pause():i.anims.resume()),i.anims.play(o),o}}}return a.sprite||a.image},countSprites(t){return h.countRecursive(t)}}}function x(d){return{load(t,e,n,a){if(!e||!e.layers||e.layers.length===0){console.warn("No tiles to load or invalid tiles data");return}e.layers.forEach(i=>{for(let o=0;o<e.columns;o++)for(let s=0;s<e.rows;s++){const r=`${i.name}_tile_${o}_${s}`,l=`${n}/tiles/${e.tile_slice_size}/${r}.jpg`;t.load.image(r,l),t.load.once(`filecomplete-image-${r}`,a),d.options.debug&&console.log(`Loading tile: ${r} from ${l}`)}})},countTiles(t){return!t||!t.layers?0:t.layers.length*t.columns*t.rows},place(t,e,n,a={}){const i=d.getData(n);return!i||!i.tiles?(console.warn(`Tiles data for key '${n}' not found.`),null):h.place(t,i,"tiles",e,this.placeTileLayer.bind(this),{...a,psdKey:n,tilesData:i.tiles})},placeTileLayer(t,e,n){const{tilesData:a}=n,i=t.add.container(0,0);i.setName(e.name);for(let s=0;s<a.columns;s++)for(let r=0;r<a.rows;r++){const l=`${e.name}_tile_${s}_${r}`,c=s*a.tile_slice_size,u=r*a.tile_slice_size;if(t.textures.exists(l)){const m=t.add.image(c,u,l).setOrigin(0,0);i.add(m),d.options.debug&&console.log(`Placed tile: ${l} at (${c}, ${u})`)}else console.warn(`Texture for tile ${l} not found`)}const o=this.addDebugVisualization(t,e,a,n);return o&&i.add(o),{layerData:e,tileLayer:i,debugGraphics:o}},placeAll(t,e,n={}){const a=d.getData(e);return!a||!a.tiles||!a.tiles.layers?(console.warn(`Tiles data for key '${e}' not found.`),null):a.tiles.layers.map(i=>this.place(t,i.name,e,n))},get(t,e){const n=d.getData(t);return!n||!n.placedTiles?(console.warn(`Placed tile layer data for key '${t}' not found.`),null):n.placedTiles[e]||null},addDebugVisualization(t,e,n,a){if(!a.debug&&!d.options.debug)return null;const i=t.add.graphics();i.lineStyle(2,16711935,1);const o=n.columns*n.tile_slice_size,s=n.rows*n.tile_slice_size;return i.strokeRect(0,0,o,s),i}}}function O(d){return{place(t,e,n,a={}){const i=d.getData(n);return!i||!i.zones?(console.warn(`Zone data for key '${n}' not found.`),null):h.place(t,i,"zones",e,this.placeZone.bind(this),a)},placeZone(t,e,n={}){const{name:a,bbox:i}=e,{left:o,top:s,right:r,bottom:l}=i,c=r-o,u=l-s,m=t.add.zone(o,s,c,u);m.setName(a);const g=e.createDebugBox(t,"zone",d,n);d.options.debug&&console.log(`Placed zone: ${a} at (${o}, ${s}) with dimensions ${c}x${u}`);const f={layerData:e,zone:m,debugGraphics:g};return e.children&&(f.children=e.children.map(P=>this.placeZone(t,P,n))),f},placeAll(t,e,n={}){const a=d.getData(e);return!a||!a.zones?(console.warn(`Zone data for key '${e}' not found.`),null):a.zones.map(i=>h.place(t,a,"zones",i.name,this.placeZone.bind(this),n))},get(t,e){const n=d.getData(t);return!n||!n.placedZones?(console.warn(`Placed zone data for key '${t}' not found.`),null):n.placedZones[e]||null},countZones(t){return h.countRecursive(t)}}}class z extends Phaser.Plugins.BasePlugin{constructor(t){super(t),this.psdData={},this.options={debug:!1}}boot(){this.pluginManager.game.events.once("destroy",this.destroy,this)}init(t={}){this.options={...this.options,...t},this.data=$(this),this.points=D(this),this.sprites=S(this),this.tiles=x(this),this.zones=O(this),this.options.debug&&console.log("PsdToJSONPlugin initialized with options:",this.options)}load(t,e,n){this.data.load(t,e,n)}getData(t){return this.psdData[t]}}return z});
