(function(f,$){typeof exports=="object"&&typeof module<"u"?module.exports=$():typeof define=="function"&&define.amd?define($):(f=typeof globalThis<"u"?globalThis:f||self,f.PsdToJSONPlugin=$())})(this,function(){"use strict";var C=Object.defineProperty;var v=(f,$,D)=>$ in f?C(f,$,{enumerable:!0,configurable:!0,writable:!0,value:D}):f[$]=D;var O=(f,$,D)=>(v(f,typeof $!="symbol"?$+"":$,D),D);const x=class x{constructor(t,e=null){this.parent=e,this.children=[],this.lazyLoad=!1,this.isLoaded=!1,Object.keys(t).forEach(s=>{s==="children"?this.children=t[s].map(a=>new x(a,this)):this[s]=t[s]}),this.bbox||(this.bbox={left:this.x,top:this.y,right:this.x+this.width,bottom:this.y+this.height})}isStandardProp(t){return x.standardProps.includes(t)}getCustomAttributes(){return Object.keys(this).filter(t=>!this.isStandardProp(t)&&t!=="parent").reduce((t,e)=>(t[e]=this[e],t),{})}createDebugBox(t,e,s,a={}){if(!this.shouldDebug(s,a))return null;const i=t.add.graphics(),n=16711935,r=2;if(i.lineStyle(r,n),e==="zone"){const{left:o,top:l,right:d,bottom:h}=this.bbox,u=d-o,y=h-l;i.strokeRect(o,l,u,y)}else e==="sprite"||e==="image"?this.type==="spritesheet"?this.placement.forEach(o=>{i.strokeRect(this.x+o.x,this.y+o.y,this.frame_width,this.frame_height)}):i.strokeRect(this.x,this.y,this.width,this.height):e==="point"&&i.strokeCircle(this.x,this.y,5);return i}getTargetObject(t,e){switch(e){case"sprite":return t.children.getByName(this.name);case"zone":return t.children.getByName(this.name);case"point":return t.children.getByName(this.name);default:return null}}shouldDebug(t,e){return t.options.debug||e.debug}getPath(){return this.parent?`${this.parent.getPath()}/${this.name}`:this.name}findByPath(t){const e=t.split("/");if(e[0]===this.name){if(e.length===1)return this;const s=e[1],a=this.children.find(i=>i.name===s);return a?a.findByPath(e.slice(1).join("/")):null}return null}static place(t,e,s,a,i,n={}){if(!e||!e[s])return console.warn(`${s} data not found.`),null;let r;if(s==="tiles")r=e[s].layers.find(l=>l.name===a);else{const l=a.split("/");r=e[s].find(d=>d.name===l[0]);for(let d=1;d<l.length;d++){if(!r||!r.children)return null;r=r.children.find(h=>h.name===l[d])}}if(!r)return console.warn(`${s} '${a}' not found in PSD data.`),null;const o=i(t,r,n);return o&&(e[`placed${s.charAt(0).toUpperCase()+s.slice(1)}`]||(e[`placed${s.charAt(0).toUpperCase()+s.slice(1)}`]={}),e[`placed${s.charAt(0).toUpperCase()+s.slice(1)}`][a]=o,o.children&&this.storeNestedObjects(e,s,a,o.children)),o}static storeNestedObjects(t,e,s,a){a.forEach(i=>{const n=`${s}/${i.layerData.name}`;t[`placed${e.charAt(0).toUpperCase()+e.slice(1)}`][n]=i,i.children&&this.storeNestedObjects(t,e,n,i.children)})}static placeAll(t,e,s,a,i={}){if(!e||!e[s])return console.warn(`${s} data not found.`),null;const n=e[s].map(r=>a(t,r,i));return e[`placed${s.charAt(0).toUpperCase()+s.slice(1)}`]=n,n}static get(t,e,s){const a=`placed${e.charAt(0).toUpperCase()+e.slice(1)}`;if(!t||!t[a])return console.warn(`Placed ${e} data not found.`),null;const i=s.split("/");let n=t[a].find(r=>r.layerData.name===i[0]);for(let r=1;r<i.length;r++){if(!n||!n.children)return null;n=n.children.find(o=>o.layerData.name===i[r])}return n}static countRecursive(t){return t.reduce((e,s)=>{let a=1;return s.children&&s.children.length>0&&(a+=this.countRecursive(s.children)),e+a},0)}};O(x,"standardProps",["name","x","y","width","height","children","lazyLoad"]);let f=x;function $(c){return new f(c)}function D(c){let t=0,e=!1,s=[],a=0,i=0;return{load(n,r,o){const l=`${o}/data.json`;n.load.json(r,l),n.load.once("complete",()=>{const d=n.cache.json.get(r);this.processJSON(n,r,d,o)})},processJSON(n,r,o,l){c.psdData[r]={...o,basePath:l,sprites:o.sprites.map(d=>$(d)),zones:o.zones.map(d=>$(d)),points:o.points.map(d=>$(d))},c.options.debug&&console.log(`Loaded JSON for key "${r}":`,c.psdData[r]),this.loadAssetsFromJSON(n,r,c.psdData[r])},loadAssetsFromJSON(n,r,o){const l=this.flattenObjects(o.sprites),d=o.tiles||{};a=this.countAssets(l)+c.tiles.countTiles(d),i=0,c.options.debug&&console.log(`Total assets to load: ${a}`);const h=()=>{i++,t=i/a,n.events.emit("psdAssetsLoadProgress",t),c.options.debug&&(console.log(`Loaded asset ${i} of ${a}`),console.log(`Loading progress: ${(t*100).toFixed(2)}%`)),i===a&&(e=!0,n.events.emit("psdAssetsLoadComplete"),c.options.debug&&console.log("All PSD assets loaded"))};l.length>0&&this.loadSprites(n,l,o.basePath,h),d.layers&&d.layers.length>0&&c.tiles.load(n,d,o.basePath,h),a===0&&(e=!0,n.events.emit("psdAssetsLoadComplete")),n.load.isLoading()||n.load.start()},loadSprites(n,r,o,l){r.forEach(({path:d,obj:h})=>{if(h.lazyLoad){c.options.debug&&console.log(`Skipping load for lazy-loaded sprite: ${d}`);return}const u=`${o}/sprites/${d}.png`;h.type==="animation"||h.type==="spritesheet"?n.load.spritesheet(d,u,{frameWidth:h.frame_width,frameHeight:h.frame_height}):n.load.image(d,u),n.load.once(`filecomplete-${h.type==="animation"||h.type==="spritesheet"?"spritesheet":"image"}-${d}`,()=>{h.isLoaded=!0,l()}),c.options.debug&&console.log(`Loading ${h.type==="animation"?"animation":h.type==="spritesheet"?"spritesheet":"sprite"}: ${d} from ${u}`)})},flattenObjects(n,r=""){return n.reduce((o,l)=>{const d=r?`${r}/${l.name}`:l.name;return l.lazyLoad?s.push({path:d,obj:l}):(!l.children||l.children.length===0)&&o.push({path:d,obj:l}),l.children&&o.push(...this.flattenObjects(l.children,d)),o},[])},countAssets(n){return n.length},getLazyLoadQueue(){return s},get progress(){return t},get complete(){return e}}}function A(c){return{place(t,e,s,a={}){const i=c.getData(s);return!i||!i.points?(console.warn(`Point data for key '${s}' not found.`),null):f.place(t,i,"points",e,this.placePoint.bind(this),a)},placePoint(t,e,s={}){const{name:a,x:i,y:n}=e,r=t.add.circle(i,n,5,16777215,1);r.setName(a);const o=e.createDebugBox(t,"point",c,s);c.options.debug&&console.log(`Placed point: ${a} at (${i}, ${n})`);const l={layerData:e,point:r,debugGraphics:o};return e.children&&(l.children=e.children.map(d=>this.placePoint(t,d,s))),l},placeAll(t,e,s={}){const a=c.getData(e);return!a||!a.points?(console.warn(`Point data for key '${e}' not found.`),null):a.points.map(i=>f.place(t,a,"points",i.name,this.placePoint.bind(this),s))},get(t,e){const s=c.getData(t);return!s||!s.placedPoints?(console.warn(`Placed point data for key '${t}' not found.`),null):s.placedPoints[e]||null},countPoints(t){return f.countRecursive(t)}}}function _(c){return{place(t,e,s,a={}){const i=c.getData(s);return!i||!i.sprites?(console.warn(`Sprite data for key '${s}' not found.`),null):f.place(t,i,"sprites",e,this.placeSprite.bind(this),a)},placeSprite(t,e,s={}){const{name:a,x:i,y:n,width:r,height:o,type:l,frame_width:d,frame_height:h,placement:u,autoplacement:y=!0,lazyLoad:S,layerOrder:p}=e;let b=[],g=null;if(!e.children||e.children.length===0){if(S)return c.options.debug&&console.log(`Sprite '${e.getPath()}' is set to lazy load. Skipping placement.`),{layerData:e,sprites:[],debugGraphics:null};if(!e.isLoaded)return console.warn(`Sprite '${e.getPath()}' hasn't been loaded yet.`),{layerData:e,sprites:[],debugGraphics:null};if(l==="atlas"){const m=this.createAtlasSprite(t,e,s);m.setDepth(p),b.push(m)}else if(l==="animation"){const m=this.createAnimatedSprite(t,e,s);m.sprite.setDepth(p),b.push(m.sprite),g=m}else if(l==="spritesheet"&&y)u.forEach((m,T)=>{const z=t.add.sprite(i+m.x,n+m.y,e.getPath(),m.frame);z.setName(`${a}_${T}`),z.setDisplaySize(d,h),z.setOrigin(0,0),z.setDepth(p),b.push(z)});else if(l!=="spritesheet"||y){const m=s.useImage?t.add.image(i,n,e.getPath()):t.add.sprite(i,n,e.getPath());m.setName(a),r!==void 0&&o!==void 0&&m.setDisplaySize(r,o),m.setOrigin(0,0),m.setDepth(p),b.push(m)}}const w=e.createDebugBox(t,"sprite",c,s);w&&w.setDepth(p+.1),c.options.debug&&console.log(`Placed ${l==="atlas"?"atlas":l==="spritesheet"?"spritesheet":l==="animation"?"animated sprite":s.useImage?"image":"sprite"}: ${a} at (${i}, ${n}) with dimensions ${r}x${o} and depth ${p}`);const P={layerData:e,sprites:b,debugGraphics:w};return l==="atlas"?P.getFrameSprite=b[0].getFrameSprite:g&&(P.animation=g.animation,P.animationKey=g.animationKey,P.play=g.play,P.pause=g.pause,P.resume=g.resume,P.stop=g.stop,P.updateAnimation=g.updateAnimation),e.children&&(P.children=e.children.map(m=>this.placeSprite(t,m,s))),P},createAtlasSprite(t,e,s){const{name:a,x:i,y:n,width:r,height:o,atlas_image:l,atlas_data:d}=e;t.textures.exists(l)||t.textures.addAtlas(l,t.textures.get(e.getPath()).getSourceImage(),d);const h=t.add.container(i,n);h.setName(a);const u=Object.keys(d.frames);return u.forEach(y=>{const S=d.frames[y],p=t.add.sprite(S.relative.x,S.relative.y,l,y);p.setName(`${a}_${y}`),p.setOrigin(0,0),h.add(p)}),h.setSize(r,o),h.getFrameSprite=y=>h.list.find(S=>S.name===`${a}_${y}`),c.options.debug&&console.log(`Created atlas sprite '${a}' with ${u.length} frames`),h},createAnimatedSprite(t,e,s={}){const{name:a,x:i,y:n,frame_width:r,frame_height:o,frame_count:l,columns:d,rows:h}=e,u=t.add.sprite(i,n,e.getPath());u.setName(a),u.setDisplaySize(r,o),u.setOrigin(0,0),t.textures.exists(e.getPath())||t.textures.addSpriteSheet(e.getPath(),t.textures.get(e.getPath()).getSourceImage(),{frameWidth:r,frameHeight:o,startFrame:0,endFrame:l-1,margin:0,spacing:0});const y=["frameRate","duration","delay","repeat","repeatDelay","yoyo","showOnStart","hideOnComplete","skipMissedFrames","timeScale"],S={key:`${e.getPath()}_animated`,frames:t.anims.generateFrameNumbers(e.getPath(),{start:0,end:l-1}),frameRate:10,repeat:-1};y.forEach(g=>{e[g]!==void 0&&(S[g]=e[g])});const p={...S,...s.animationOptions};t.anims.exists(p.key)||t.anims.create(p),u.play(p.key);const b=g=>{const w=t.anims.get(p.key);if(w)return Object.entries(g).forEach(([P,m])=>{y.includes(P)&&(w[P]=m)}),g.frames&&(w.frames=t.anims.generateFrameNumbers(e.getPath(),g.frames)),g.paused!==void 0&&(g.paused?u.anims.pause():u.anims.resume()),u.play(p.key),w};return{sprite:u,animationKey:p.key,play:()=>u.play(p.key),pause:()=>u.anims.pause(),resume:()=>u.anims.resume(),stop:()=>u.anims.stop(),updateAnimation:b}},placeAll(t,e,s={}){const a=c.getData(e);return!a||!a.sprites?(console.warn(`Sprite data for key '${e}' not found.`),null):[...a.sprites].sort((n,r)=>n.layerOrder-r.layerOrder).map(n=>f.place(t,a,"sprites",n.name,this.placeSprite.bind(this),s))},get(t,e){const s=c.getData(t);if(!s||!s.sprites)return console.warn(`Sprite data for key '${t}' not found.`),null;const i=e.split("/").join("/");let n=s.placedSprites?s.placedSprites[i]:null;if(!n){const o=this.findSpriteByPath(s.sprites,i);o&&(n={layerData:o})}if(!n)return null;const{layerData:r}=n;if(r.type==="atlas"){const o=n.sprites[0];return{sprite:o,setFrame:l=>o.setFrame(l)}}else{if(r.type==="spritesheet")return{layerData:r,getSprite:(o=0)=>({texture:r.getPath(),frame:o})};if(r.type==="animation"){const o=n.sprites[0],l=o.anims.currentAnim;return{sprite:o,animation:l,animationKey:l.key,play:()=>o.play(l.key),pause:()=>o.anims.pause(),resume:()=>o.anims.resume(),stop:()=>o.anims.stop(),updateAnimation:d=>{}}}}return n.sprites[0]},getTexture(t,e){const s=c.getData(t);if(!s||!s.sprites)return console.warn(`Sprite data for key '${t}' not found.`),null;const a=this.findSpriteByPath(s.sprites,e);if(!a)return console.warn(`Sprite '${e}' not found.`),null;if(a.type==="atlas"){const i=e.split("/");return i.length>1?{texture:a.atlas_image,frame:i[i.length-1]}:Object.keys(a.atlas_data.frames).map(n=>({texture:a.atlas_image,frame:n}))}else if(a.type==="spritesheet")return a.getPath();return e},findSpriteByPath(t,e){const s=e.split("/");let a=t.find(i=>i.name===s[0]);for(let i=1;i<s.length;i++){if(!a||!a.children)return null;a=a.children.find(n=>n.name===s[i])}return a},countSprites(t){return f.countRecursive(t)},loadSprites(t,e,s,a){e.forEach(({path:i,obj:n})=>{if(n.lazyLoad){c.options.debug&&console.log(`Skipping load for lazy-loaded sprite: ${i}`);return}const r=`${s}/sprites/${i}.png`;n.type==="atlas"?t.load.atlas(i,r,n.atlas_data):n.type==="animation"||n.type==="spritesheet"?t.load.spritesheet(i,r,{frameWidth:n.frame_width,frameHeight:n.frame_height}):t.load.image(i,r),t.load.once(`filecomplete-${n.type==="atlas"?"atlas":n.type==="animation"||n.type==="spritesheet"?"spritesheet":"image"}-${i}`,()=>{n.isLoaded=!0,a()}),c.options.debug&&console.log(`Loading ${n.type==="atlas"?"atlas":n.type==="animation"?"animation spritesheet":n.type==="spritesheet"?"spritesheet":"sprite"}: ${i} from ${r}`)})}}}function L(c){return{load(t,e,s,a){if(!e||!e.layers||e.layers.length===0){console.warn("No tiles to load or invalid tiles data");return}e.layers.forEach(i=>{for(let n=0;n<e.columns;n++)for(let r=0;r<e.rows;r++){const o=`${i.name}_tile_${n}_${r}`,l=`${s}/tiles/${e.tile_slice_size}/${o}.jpg`;t.load.image(o,l),t.load.once(`filecomplete-image-${o}`,a),c.options.debug&&console.log(`Loading tile: ${o} from ${l}`)}})},countTiles(t){return!t||!t.layers?0:t.layers.length*t.columns*t.rows},place(t,e,s,a={}){const i=c.getData(s);return!i||!i.tiles?(console.warn(`Tiles data for key '${s}' not found.`),null):f.place(t,i,"tiles",e,this.placeTileLayer.bind(this),{...a,psdKey:s,tilesData:i.tiles})},placeTileLayer(t,e,s){const{tilesData:a}=s,i=t.add.container(0,0);i.setName(e.name);for(let r=0;r<a.columns;r++)for(let o=0;o<a.rows;o++){const l=`${e.name}_tile_${r}_${o}`,d=r*a.tile_slice_size,h=o*a.tile_slice_size;if(t.textures.exists(l)){const u=t.add.image(d,h,l).setOrigin(0,0);i.add(u),c.options.debug&&console.log(`Placed tile: ${l} at (${d}, ${h})`)}else console.warn(`Texture for tile ${l} not found`)}const n=this.addDebugVisualization(t,e,a,s);return n&&i.add(n),{layerData:e,tileLayer:i,debugGraphics:n}},placeAll(t,e,s={}){const a=c.getData(e);return!a||!a.tiles||!a.tiles.layers?(console.warn(`Tiles data for key '${e}' not found.`),null):a.tiles.layers.map(i=>this.place(t,i.name,e,s))},get(t,e){const s=c.getData(t);return!s||!s.placedTiles?(console.warn(`Placed tile layer data for key '${t}' not found.`),null):s.placedTiles[e]||null},addDebugVisualization(t,e,s,a){if(!a.debug&&!c.options.debug)return null;const i=t.add.graphics();i.lineStyle(2,16711935,1);const n=s.columns*s.tile_slice_size,r=s.rows*s.tile_slice_size;return i.strokeRect(0,0,n,r),i}}}function k(c){return{place(t,e,s,a={}){const i=c.getData(s);return!i||!i.zones?(console.warn(`Zone data for key '${s}' not found.`),null):f.place(t,i,"zones",e,this.placeZone.bind(this),a)},placeZone(t,e,s={}){const{name:a,bbox:i}=e,{left:n,top:r,right:o,bottom:l}=i,d=o-n,h=l-r,u=t.add.zone(n,r,d,h);u.setName(a);const y=e.createDebugBox(t,"zone",c,s);c.options.debug&&console.log(`Placed zone: ${a} at (${n}, ${r}) with dimensions ${d}x${h}`);const S={layerData:e,zone:u,debugGraphics:y};return e.children&&(S.children=e.children.map(p=>this.placeZone(t,p,s))),S},placeAll(t,e,s={}){const a=c.getData(e);return!a||!a.zones?(console.warn(`Zone data for key '${e}' not found.`),null):a.zones.map(i=>f.place(t,a,"zones",i.name,this.placeZone.bind(this),s))},get(t,e){const s=c.getData(t);return!s||!s.placedZones?(console.warn(`Placed zone data for key '${t}' not found.`),null):s.placedZones[e]||null},countZones(t){return f.countRecursive(t)}}}class N extends Phaser.Plugins.BasePlugin{constructor(t){super(t),this.psdData={},this.options={debug:!1}}boot(){this.pluginManager.game.events.once("destroy",this.destroy,this)}init(t={}){this.options={...this.options,...t},this.data=D(this),this.points=A(this),this.sprites=_(this),this.tiles=L(this),this.zones=k(this),this.options.debug&&console.log("PsdToJSONPlugin initialized with options:",this.options)}load(t,e,s){this.data.load(t,e,s)}getData(t){return this.psdData[t]}}return N});
