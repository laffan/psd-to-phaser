(function(h,u){typeof exports=="object"&&typeof module<"u"?module.exports=u():typeof define=="function"&&define.amd?define(u):(h=typeof globalThis<"u"?globalThis:h||self,h.PsdToJSONPlugin=u())})(this,function(){"use strict";var z=Object.defineProperty;var L=(h,u,g)=>u in h?z(h,u,{enumerable:!0,configurable:!0,writable:!0,value:g}):h[u]=g;var m=(h,u,g)=>(L(h,typeof u!="symbol"?u+"":u,g),g);const $=class ${constructor(e,t=null){this.parent=t,this.children=[],this.lazyLoad=!1,this.isLoaded=!1,Object.keys(e).forEach(n=>{n==="children"?this.children=e[n].map(o=>new $(o,this)):this[n]=e[n]})}isStandardProp(e){return $.standardProps.includes(e)}getCustomAttributes(){return Object.keys(this).filter(e=>!this.isStandardProp(e)&&e!=="parent").reduce((e,t)=>(e[t]=this[t],e),{})}addDebugVisualization(e,t,n,o={}){if(!this.shouldDebug(n,o))return null;let s="0xFF00FF",r;switch(t){case"sprite":r=e.add.rectangle(this.x,this.y,this.width,this.height,s,.5),r.setOrigin(0,0);break;case"zone":const{left:a,top:i,right:d,bottom:c}=this.bbox,f=d-a,p=c-i;r=e.add.rectangle(a,i,f,p,s,.5),r.setOrigin(0,0);break;case"point":r=e.add.circle(this.x,this.y,10,s,.5);break;default:console.warn(`Unknown debug visualization type: ${t}`)}return r}shouldDebug(e,t){return e.options.debug||t.debug}getPath(){return this.parent?`${this.parent.getPath()}/${this.name}`:this.name}findByPath(e){const t=e.split("/");if(t[0]===this.name){if(t.length===1)return this;const n=t[1],o=this.children.find(s=>s.name===n);return o?o.findByPath(t.slice(1).join("/")):null}return null}};m($,"standardProps",["name","x","y","width","height","children","lazyLoad"]);let h=$;function u(l){return new h(l)}function g(l){let e=0,t=!1,n=[];return{load(o,s,r){const a=`${r}/data.json`;o.load.json(s,a),o.load.once("complete",()=>{const i=o.cache.json.get(s);this.processJSON(o,s,i,r)})},processJSON(o,s,r,a){l.psdData[s]={...r,basePath:a,sprites:r.sprites.map(i=>u(i)),zones:r.zones.map(i=>u(i)),points:r.points.map(i=>u(i))},l.options.debug&&console.log(`Loaded JSON for key "${s}":`,l.psdData[s]),this.loadAssetsFromJSON(o,s,l.psdData[s])},loadAssetsFromJSON(o,s,r){const a=this.flattenObjects(r.sprites),i=r.tiles||{};let d=this.countAssets(a)+l.tiles.countTiles(i),c=0;l.options.debug&&console.log(`Total assets to load: ${d}`);const f=()=>{c++,e=c/d,o.events.emit("psdAssetsLoadProgress",e),l.options.debug&&(console.log(`Loaded asset ${c} of ${d}`),console.log(`Loading progress: ${(e*100).toFixed(2)}%`)),c===d&&(t=!0,o.events.emit("psdAssetsLoadComplete"),l.options.debug&&console.log("All PSD assets loaded"))};a.length>0&&this.loadSprites(o,a,r.basePath,f),i.layers&&i.layers.length>0&&l.tiles.load(o,i,r.basePath,f),d===0&&(t=!0,o.events.emit("psdAssetsLoadComplete")),o.load.isLoading()||o.load.start()},flattenObjects(o,s=""){return o.reduce((r,a)=>{const i=s?`${s}/${a.name}`:a.name;return a.lazyLoad?n.push({path:i,obj:a}):(!a.children||a.children.length===0)&&r.push({path:i,obj:a}),a.children&&r.push(...this.flattenObjects(a.children,i)),r},[])},loadSprites(o,s,r,a){s.forEach(({path:i,obj:d})=>{const c=`${r}/sprites/${i}.png`;o.load.image(i,c),o.load.once(`filecomplete-image-${i}`,()=>{d.isLoaded=!0,a()}),l.options.debug&&console.log(`Loading sprite: ${i} from ${c}`)})},countAssets(o){return o.length},getLazyLoadQueue(){return n},get progress(){return e},get complete(){return t}}}function P(l){return{place(e,t,n,o={}){const s=l.getData(n);if(!s||!s.points)return console.warn(`Point data for key '${n}' not found.`),null;const r=s.points.find(i=>t.startsWith(i.name));if(!r)return console.warn(`Point '${t}' not found in PSD data for key '${n}'.`),null;const a=r.findByPath(t);return a?this.placePoint(e,a,o):(console.warn(`Point '${t}' not found in PSD data for key '${n}'.`),null)},placePoint(e,t,n={}){const{name:o,x:s,y:r}=t,a=e.add.rectangle(s,r,1,1,16777215,0),i=t.addDebugVisualization(e,"point",l,n);l.options.debug&&console.log(`Placed point: ${o} at (${s}, ${r})`);const d={layerData:t,pointObject:a,debugGraphics:i};return t.children&&(d.children=t.children.map(c=>this.placePoint(e,c,n))),d},placeAll(e,t,n={}){const o=l.getData(t);return!o||!o.points?(console.warn(`Point data for key '${t}' not found.`),null):o.points.map(s=>this.placePoint(e,s,n))},countPoints(e){return this.countPointsRecursive(e)},countPointsRecursive(e){return e.reduce((t,n)=>{let o=1;return n.children&&(o+=this.countPointsRecursive(n.children)),t+o},0)}}}function y(l){return{place(e,t,n,o={}){const s=l.getData(n);if(!s||!s.sprites)return console.warn(`Sprite data for key '${n}' not found.`),null;const r=s.sprites.find(i=>t.startsWith(i.name));if(!r)return console.warn(`Sprite '${t}' not found in PSD data for key '${n}'.`),null;const a=r.findByPath(t);return a?this.placeSprite(e,a,o):(console.warn(`Sprite '${t}' not found in PSD data for key '${n}'.`),null)},placeSprite(e,t,n={}){const{name:o,x:s,y:r,width:a,height:i}=t;let d=null;(!t.children||t.children.length===0)&&(t.lazyLoad&&!t.isLoaded?console.warn(`Sprite '${t.getPath()}' is set to lazy load and hasn't been loaded yet.`):(d=e.add.image(s,r,t.getPath()),a!==void 0&&i!==void 0&&d.setDisplaySize(a,i),d.setOrigin(0,0)));const c=t.addDebugVisualization(e,"sprite",l,n);l.options.debug&&console.log(`Placed sprite: ${o} at (${s}, ${r}) with dimensions ${a}x${i}`);const f={layerData:t,image:d,debugGraphics:c};return t.children&&(f.children=t.children.map(p=>this.placeSprite(e,p,n))),f},placeAll(e,t,n={}){const o=l.getData(t);return!o||!o.sprites?(console.warn(`Sprite data for key '${t}' not found.`),null):o.sprites.map(s=>this.placeSprite(e,s,n))},countSprites(e){return this.countSpritesRecursive(e)},countSpritesRecursive(e){return e.reduce((t,n)=>{let o=1;return n.children&&(o+=this.countSpritesRecursive(n.children)),t+o},0)}}}function b(l){return{load(e,t,n,o){if(!t||!t.layers||t.layers.length===0){console.warn("No tiles to load or invalid tiles data");return}t.layers.forEach(s=>{for(let r=0;r<t.columns;r++)for(let a=0;a<t.rows;a++){const i=`${s.name}_tile_${r}_${a}`,d=`${n}/tiles/${t.tile_slice_size}/${i}.jpg`;e.load.image(i,d),e.load.once(`filecomplete-image-${i}`,o),l.options.debug&&console.log(`Loading tile: ${i} from ${d}`)}})},create(e,t){},countTiles(e){return!e||!e.layers?0:e.layers.length*e.columns*e.rows},place(e,t,n){const o=l.getData(n);if(!o||!o.tiles)return console.warn(`Tiles data for key '${n}' not found.`),null;const s=o.tiles;if(!s.layers.find(i=>i.name===t))return console.warn(`Tile layer '${t}' not found in PSD data for key '${n}'.`),null;const a=e.add.container(0,0);for(let i=0;i<s.columns;i++)for(let d=0;d<s.rows;d++){const c=`${t}_tile_${i}_${d}`,f=i*s.tile_slice_size,p=d*s.tile_slice_size;if(e.textures.exists(c)){const D=e.add.image(f,p,c).setOrigin(0,0);a.add(D),l.options.debug&&console.log(`Placed tile: ${c} at (${f}, ${p})`)}else console.warn(`Texture for tile ${c} not found`)}return a}}}function w(l){return{place(e,t,n,o={}){const s=l.getData(n);if(!s||!s.zones)return console.warn(`Zone data for key '${n}' not found.`),null;const r=s.zones.find(i=>t.startsWith(i.name));if(!r)return console.warn(`Zone '${t}' not found in PSD data for key '${n}'.`),null;const a=r.findByPath(t);return a?this.placeZone(e,a,o):(console.warn(`Zone '${t}' not found in PSD data for key '${n}'.`),null)},placeZone(e,t,n={}){const{name:o,x:s,y:r,width:a,height:i}=t,d=e.add.zone(s,r,a,i);(!e.physics||!e.physics.world)&&e.physics.startSystem(Phaser.Physics.ARCADE),e.physics.add.existing(d,!0);const c=t.addDebugVisualization(e,"zone",l,n);l.options.debug&&console.log(`Placed zone: ${o} at (${s}, ${r}) with dimensions ${a}x${i}`);const f={layerData:t,zoneObject:d,debugGraphics:c};return t.children&&(f.children=t.children.map(p=>this.placeZone(e,p,n))),f},placeAll(e,t,n={}){const o=l.getData(t);return!o||!o.zones?(console.warn(`Zone data for key '${t}' not found.`),null):o.zones.map(s=>this.placeZone(e,s,n))},countZones(e){return this.countZonesRecursive(e)},countZonesRecursive(e){return e.reduce((t,n)=>{let o=1;return n.children&&(o+=this.countZonesRecursive(n.children)),t+o},0)}}}class S extends Phaser.Plugins.BasePlugin{constructor(e){super(e),this.psdData={},this.options={debug:!1}}boot(){this.pluginManager.game.events.once("destroy",this.destroy,this)}init(e={}){this.options={...this.options,...e},this.data=g(this),this.points=P(this),this.sprites=y(this),this.tiles=b(this),this.zones=w(this),this.options.debug&&console.log("PsdToJSONPlugin initialized with options:",this.options)}load(e,t,n){this.data.load(e,t,n)}getData(e){return this.psdData[e]}}return S});
