(function(h,u){typeof exports=="object"&&typeof module<"u"?module.exports=u():typeof define=="function"&&define.amd?define(u):(h=typeof globalThis<"u"?globalThis:h||self,h.PsdToJSONPlugin=u())})(this,function(){"use strict";var L=Object.defineProperty;var z=(h,u,p)=>u in h?L(h,u,{enumerable:!0,configurable:!0,writable:!0,value:p}):h[u]=p;var m=(h,u,p)=>(z(h,typeof u!="symbol"?u+"":u,p),p);const $=class ${constructor(t,e=null){this.parent=e,this.children=[],this.lazyLoad=!1,this.isLoaded=!1,Object.keys(t).forEach(n=>{n==="children"?this.children=t[n].map(o=>new $(o,this)):this[n]=t[n]})}isStandardProp(t){return $.standardProps.includes(t)}getCustomAttributes(){return Object.keys(this).filter(t=>!this.isStandardProp(t)&&t!=="parent").reduce((t,e)=>(t[e]=this[e],t),{})}addDebugVisualization(t,e,n,o={}){if(!this.shouldDebug(n,o))return null;let i="0xFF00FF",r;switch(e){case"sprite":r=t.add.rectangle(this.x,this.y,this.width,this.height,i,.5),r.setOrigin(0,0);break;case"zone":const{left:a,top:s,right:d,bottom:c}=this.bbox,f=d-a,g=c-s;r=t.add.rectangle(a,s,f,g,i,.5),r.setOrigin(0,0);break;case"point":r=t.add.circle(this.x,this.y,10,i,.5);break;default:console.warn(`Unknown debug visualization type: ${e}`)}return r}shouldDebug(t,e){return t.options.debug||e.debug}getPath(){return this.parent?`${this.parent.getPath()}/${this.name}`:this.name}findByPath(t){const e=t.split("/");if(e[0]===this.name){if(e.length===1)return this;const n=e[1],o=this.children.find(i=>i.name===n);return o?o.findByPath(e.slice(1).join("/")):null}return null}};m($,"standardProps",["name","x","y","width","height","children","lazyLoad"]);let h=$;function u(l){return new h(l)}function p(l){let t=0,e=!1,n=[];return{load(o,i,r){const a=`${r}/data.json`;o.load.json(i,a),o.load.once("complete",()=>{const s=o.cache.json.get(i);this.processJSON(o,i,s,r)})},processJSON(o,i,r,a){l.psdData[i]={...r,basePath:a,sprites:r.sprites.map(s=>u(s)),zones:r.zones.map(s=>u(s)),points:r.points.map(s=>u(s))},l.options.debug&&console.log(`Loaded JSON for key "${i}":`,l.psdData[i]),this.loadAssetsFromJSON(o,i,l.psdData[i])},loadAssetsFromJSON(o,i,r){const a=this.flattenObjects(r.sprites),s=r.tiles||{};let d=this.countAssets(a)+l.tiles.countTiles(s),c=0;l.options.debug&&console.log(`Total assets to load: ${d}`);const f=()=>{c++,t=c/d,o.events.emit("psdAssetsLoadProgress",t),l.options.debug&&(console.log(`Loaded asset ${c} of ${d}`),console.log(`Loading progress: ${(t*100).toFixed(2)}%`)),c===d&&(e=!0,o.events.emit("psdAssetsLoadComplete"),l.options.debug&&console.log("All PSD assets loaded"))};a.length>0&&this.loadSprites(o,a,r.basePath,f),s.layers&&s.layers.length>0&&l.tiles.load(o,s,r.basePath,f),d===0&&(e=!0,o.events.emit("psdAssetsLoadComplete")),o.load.isLoading()||o.load.start()},flattenObjects(o,i=""){return o.reduce((r,a)=>{const s=i?`${i}/${a.name}`:a.name;return a.lazyLoad?n.push({path:s,obj:a}):(!a.children||a.children.length===0)&&r.push({path:s,obj:a}),a.children&&r.push(...this.flattenObjects(a.children,s)),r},[])},loadSprites(o,i,r,a){i.forEach(({path:s,obj:d})=>{const c=`${r}/sprites/${s}.png`;o.load.image(s,c),o.load.once(`filecomplete-image-${s}`,()=>{d.isLoaded=!0,a()}),l.options.debug&&console.log(`Loading sprite: ${s} from ${c}`)})},countAssets(o){return o.length},getLazyLoadQueue(){return n},get progress(){return t},get complete(){return e}}}function P(l){return{place(t,e,n,o={}){const i=l.getData(n);if(!i||!i.points)return console.warn(`Point data for key '${n}' not found.`),null;const r=i.points.find(s=>e.startsWith(s.name));if(!r)return console.warn(`Point '${e}' not found in PSD data for key '${n}'.`),null;const a=r.findByPath(e);return a?this.placePoint(t,a,o):(console.warn(`Point '${e}' not found in PSD data for key '${n}'.`),null)},placePoint(t,e,n={}){const{name:o,x:i,y:r}=e,a=t.add.rectangle(i,r,1,1,16777215,0),s=e.addDebugVisualization(t,"point",l,n);l.options.debug&&console.log(`Placed point: ${o} at (${i}, ${r})`);const d={layerData:e,pointObject:a,debugGraphics:s};return e.children&&(d.children=e.children.map(c=>this.placePoint(t,c,n))),d},countPoints(t){return this.countPointsRecursive(t)},countPointsRecursive(t){return t.reduce((e,n)=>{let o=1;return n.children&&(o+=this.countPointsRecursive(n.children)),e+o},0)}}}function y(l){return{place(t,e,n,o={}){const i=l.getData(n);if(!i||!i.sprites)return console.warn(`Sprite data for key '${n}' not found.`),null;const r=i.sprites.find(s=>e.startsWith(s.name));if(!r)return console.warn(`Sprite '${e}' not found in PSD data for key '${n}'.`),null;const a=r.findByPath(e);return a?this.placeSprite(t,a,o):(console.warn(`Sprite '${e}' not found in PSD data for key '${n}'.`),null)},placeSprite(t,e,n={}){const{name:o,x:i,y:r,width:a,height:s}=e;let d=null;(!e.children||e.children.length===0)&&(e.lazyLoad&&!e.isLoaded?console.warn(`Sprite '${e.getPath()}' is set to lazy load and hasn't been loaded yet.`):(d=t.add.image(i,r,e.getPath()),a!==void 0&&s!==void 0&&d.setDisplaySize(a,s),d.setOrigin(0,0)));const c=e.addDebugVisualization(t,"sprite",l,n);l.options.debug&&console.log(`Placed sprite: ${o} at (${i}, ${r}) with dimensions ${a}x${s}`);const f={layerData:e,image:d,debugGraphics:c};return e.children&&(f.children=e.children.map(g=>this.placeSprite(t,g,n))),f},countSprites(t){return this.countSpritesRecursive(t)},countSpritesRecursive(t){return t.reduce((e,n)=>{let o=1;return n.children&&(o+=this.countSpritesRecursive(n.children)),e+o},0)}}}function b(l){return{load(t,e,n,o){if(!e||!e.layers||e.layers.length===0){console.warn("No tiles to load or invalid tiles data");return}e.layers.forEach(i=>{for(let r=0;r<e.columns;r++)for(let a=0;a<e.rows;a++){const s=`${i.name}_tile_${r}_${a}`,d=`${n}/tiles/${e.tile_slice_size}/${s}.jpg`;t.load.image(s,d),t.load.once(`filecomplete-image-${s}`,o),l.options.debug&&console.log(`Loading tile: ${s} from ${d}`)}})},create(t,e){},countTiles(t){return!t||!t.layers?0:t.layers.length*t.columns*t.rows},place(t,e,n){const o=l.getData(n);if(!o||!o.tiles)return console.warn(`Tiles data for key '${n}' not found.`),null;const i=o.tiles;if(!i.layers.find(s=>s.name===e))return console.warn(`Tile layer '${e}' not found in PSD data for key '${n}'.`),null;const a=t.add.container(0,0);for(let s=0;s<i.columns;s++)for(let d=0;d<i.rows;d++){const c=`${e}_tile_${s}_${d}`,f=s*i.tile_slice_size,g=d*i.tile_slice_size;if(t.textures.exists(c)){const D=t.add.image(f,g,c).setOrigin(0,0);a.add(D),l.options.debug&&console.log(`Placed tile: ${c} at (${f}, ${g})`)}else console.warn(`Texture for tile ${c} not found`)}return a}}}function S(l){return{place(t,e,n,o={}){const i=l.getData(n);if(!i||!i.zones)return console.warn(`Zone data for key '${n}' not found.`),null;const r=i.zones.find(s=>e.startsWith(s.name));if(!r)return console.warn(`Zone '${e}' not found in PSD data for key '${n}'.`),null;const a=r.findByPath(e);return a?this.placeZone(t,a,o):(console.warn(`Zone '${e}' not found in PSD data for key '${n}'.`),null)},placeZone(t,e,n={}){const{name:o,x:i,y:r,width:a,height:s}=e,d=t.add.zone(i,r,a,s);(!t.physics||!t.physics.world)&&t.physics.startSystem(Phaser.Physics.ARCADE),t.physics.add.existing(d,!0);const c=e.addDebugVisualization(t,"zone",l,n);l.options.debug&&console.log(`Placed zone: ${o} at (${i}, ${r}) with dimensions ${a}x${s}`);const f={layerData:e,zoneObject:d,debugGraphics:c};return e.children&&(f.children=e.children.map(g=>this.placeZone(t,g,n))),f},countZones(t){return this.countZonesRecursive(t)},countZonesRecursive(t){return t.reduce((e,n)=>{let o=1;return n.children&&(o+=this.countZonesRecursive(n.children)),e+o},0)}}}class w extends Phaser.Plugins.BasePlugin{constructor(t){super(t),this.psdData={},this.options={debug:!1}}boot(){this.pluginManager.game.events.once("destroy",this.destroy,this)}init(t={}){this.options={...this.options,...t},this.data=p(this),this.points=P(this),this.sprites=y(this),this.tiles=b(this),this.zones=S(this),this.options.debug&&console.log("PsdToJSONPlugin initialized with options:",this.options)}load(t,e,n){this.data.load(t,e,n)}getData(t){return this.psdData[t]}}return w});
