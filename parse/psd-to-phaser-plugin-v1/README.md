# PSD to Phaser Plugin

PsdToPhaser's plugin is a bunch of convenience functions to get PSD to Phaser's output file up and running in your phaser project more quickly.

## ToDo

- getTexture()
- place: false (also ... support bang bools in generate? !place)
- (Make sure emission demo works)

### Initializing

You can initialize the plugin via when creating the game's configuration object, like so :

```js
new Phaser.Game({
  // ...
  plugins: {
    global: [
      {
        key: "PsdToJSONPlugin",
        plugin: PsdToJSONPlugin,
        start: true,
        mapping: "P2P", // all examples below assume you're mapping to P2P
        data: { debug: true },
      },
    ],
  },
  // ...
});
```

Note that the optional debug mode is on, which gives you simple visualizations of where all objects are being placed. This can be turned on individually for each item as well.

## Rebuilding the PSD.

### Loading

When preloading your scene, use P2P.load() by passing in the folder generated by PSDtoJSON. Any assets in the JSON that do not have a `lazyLoad:true` attribute will start loading. Events are emitted as each asset is loaded.

```js
// Load the JSON
this.P2P.load(this, "psd_key", "assets/simple");

// Listen for asset loading progress
this.events.on("psdLoadProgress", (value) => {
  this.P2PProgress = value;
  this.updateProgress();
});

// Listen for asset loading completion
this.events.once(
  "psdLoadComplete",
  () => {
    console.log("All done!");
  },
  this
);
```

### Placement

All types have place() and placeAll() methods.

```js
this.myTiles = this.P2P.tiles.placeAll(this, "psd_key");
this.myPoints = this.P2P.points.placeAll(this, "psd_key");
this.myZones = this.P2P.zones.placeAll(this, "psd_key");
// this.mySprites = this.P2P.sprites.placeAll(this, "psd_key");
```

#### Nesting

If you're placing a layer group, all of the descendants will be placed by default. However, place() also lets you place specific descendants using a slash path format.

```js
// Place a nested group
this.mySprites = this.P2P.sprites.place(
  this,
  "psd_key"
  "nestedSprites/spriteName",
);
```

Finally, if you need to limit the placement recursion, you can pass in a depth parameter.

```js
// Place a nested group
this.mySprites = this.P2P.sprites.place(
  this,
  "psd_key"
  "nestedSprites/spriteName",
);
```

### Removal

Anything placed on the canvas comes with a remove() method. This works a lot like the place() method. It is recursive by default (so if you apply it to a layer group the descendants go away too) but you can pass in a `depth` parameter to limit recursion.

```js
// Place on the canvas
this.doomed = this.P2P.sprites.place(this, "nestedSprites", "psd_key");

// Remove only the immediate children.
this.doomed.remove({ depth: 1 });

// Remove all descendants.
this.doomed.remove();
```

### Retreival

#### get()

Once you have placed sprites, you can get them using get().

```js
// Returns an individual sprite
this.nested = this.P2P.sprites.get(
  "psd_key",
  "nestedSprites/moreNested/aNestedSprite"
);
```

This returns the full nested structure of whatever you've asked for.

#### getTexture()

Once as sprite has been loaded, you can easily grab its texture and use it elsewhere, like particle emitters or placing individual frames of an atlas or spritesheet. 

**Note:**  Because the plugin is maintaining layer order with setDepth() it is very likely that new items will be hidden behind something. Just set the depth of your new item to something larger than the number of layers and you'll probably see it. 

```js
// Get the texture of a spritesheet
const spritesheetTex = this.P2P.sprites.getTexture('psd_key', 'nested/dotSheet');
const atlasTex = this.P2P.sprites.getTexture('psd_key', 'nested/dotAtlas');

// Emit spritesheet frames
this.add.particles(200, 30, spritesheetTex, {
  frame: { frames: [0, 1, 2, 3], cycle: true },
  speed: 100,
  scale: { start: 1, end: 0 },
});

// Emit atlas frames
this.add.particles(200, 30, atlasTex, {
  frame: ['pinkDot', 'greenDot']
  speed: 100,
  scale: { start: 1, end: 0 },
});

// Place the 'pinkDot' of the spritesheet elsewhere in the scene
const testSprite = this.add.sprite(200, 30, atlasTex, 'pinkDot');

// Make sure it's visible
testSprite.setDepth(100);

```

Of course you can also grab regular sprite textures as well. This can be very powerful if you'd like to add more instances of a particular sprite to the canvas. 

```js
// Get the texture
const spriteTex = this.P2P.sprites.getTexture('psd_key', 'simpleSprite')

// Create the new sprite like you normally would
const newSprite = this.add.sprite(200, 30, spriteTex);

// Make sure it's visible
testSprite.setDepth(100);
```

## Sprite Types

In the PSD, each layer can be given a type, which tells the tool what kind of image to create and how it should be represented in the JSON.

### Type : Spritesheets

Generates a basic spritesheet of the child layers. The default behaviour is the place all of the sprites where they show up in the PSD. (Note that naming two layers the same thing will cause one of them to overwrite the other.)

```
demoSpritesheet | spritesheet |
```

### Type : Atlas

Generates a packed atlas of the child layers. The default behaviour is to place all of the sprites where they show up in the PSD. (Note that naming two layers the same thing will cause one of them to overwrite the other.)

```
demoSpritesheet | atlas |
```

### Type : Animation

An animation is just a spreadsheet with different trimming rules on the layers that automatically loads as an animation. The layers in an animation group need to be integers, so it knows what frames to put where. If you've done your layer naming properly, though, you should just see an animated sprite when you place the Sprite.

You can override the default animation properties at several points.

1. Layer naming : In Photoshop, the attributes of the layer name itself can control animation properties. If you pass valid animation parameters, they will be merged in when instantiating the animation.

```
bounce | animation | frameRate: 5, yoyo: true
```

2. Instantiation : When instantiating the sprite, you can also pass in animation parameters, so the same thing could be acheived like so :

```js
// For individual sprites
this.P2P.sprites.place(this, "nested/bounce", "psd_key", {
  animationOptions: {
    frameRate: 5,
    yoyo: true,
  },
});
```

3. Using get() : You can always use get() to retreive the sprite and then use updateAnimation():

```js
this.bounce = this.P2P.sprites.get("psd_key", "nested/bounce");

this.bounce.updateAnimation({
  frameRate: 5,
  yoyo: true,
});
```

### Debugging

The plugin features a top-level debug mode you can feed either a boolean or a configuration object that gives you more granular control : `{ label, shape, console}`. "Label" controls the text label of the layer, "shape" is the visual outline of what is being placed on the canvas and "console" just gives you some basic info about the placement.

```js

// Turn on all the lights!
plugins: {
    global: [
      {
        key: 'PsdToPhaserPlugin',
        plugin: PsdToPhaserPlugin,
        start: true,
        mapping: "P2P",
        data: true ,
      },
    ],
  }

// Only certain modes on
plugins: {
    global: [
      {
        key: 'PsdToPhaserPlugin',
        plugin: PsdToPhaserPlugin,
        start: true,
        mapping: "P2P",
        data: { debug: {
          shape: true,
          label: false
        } },
      },
    ],
  }
```

When placing objects, you can override whatever your global setting is the same way.

```js
// Turn off the text labels
this.P2P.tiles.place(this, "psd_key", "backgroundTiles", {
  debug: {
    label: false,
  },
});

// The equivelant of not using debug at all.
this.P2P.points.place(this, "psd_key", "pickups/deepNestPoints", {
  debug: {
    shape: false,
    label: false,
    console: false,
  },
});
```

## Cameras

P2P has a few camera functions that help optimize your project and get you
started with some basic interaction styles.

You can add these functions to any camera by passing it in to the `createCamera`
function like so :

```js
this.myCamera = this.P2P.createCamera(this.camera);
```

Just doing this gives you access to the functions, but doesn't actually do anything.
To get functionality working off the bat, pass in one of the camera features as an array.
At the moment, there are two : `lazyLoad` and `draggable`.

### LazyLoad

This camera works in conjunction with the `lazyLoad` attribute, which you can set to true on any sprite or tile layer. Any sprite or tile layers that have been given the `lazyLoad` attribute will not loaded during preload() but later, when they enter the camera. This gives you the ability to load assets only when the camera needs them, potentially keeping load times much (much) smaller.

**Note:** There are some tradeoffs to using `lazyLoad`. The biggest difference is that you can't manually place lazily loaded items before the sprite texture has loaded. If the lazyLoad camera is on, they'll just show up when needed. 

The other tradeoff is that you MUST use the lazyLoad camera to see them at all, as the plugin just leaves them out of the initial load sequence.

```js
// Initialize a lazyLoad camera
this.lazyCamera = this.P2P.cameras.createCamera(
  this.cameras.main,
  ["lazyLoading"],
  "simple_psd",
  {
    lazyLoadingOptions: {
    extendPreloadBounds: -30,
    // Show the boundary of the lazyLoad camera
    // and the lazyLoad sprites.
    debug: {
      shape: true,
    },
    },
  }
);
```

Now P2P is keeping track of where the camera is and whether there is any overlap with the location of sprites or tiles. If there is overlap, it will trigger a load sequence

You can also deactivate the feature by setting active to false.

```js
this.lazyCamera.update({
  lazyLoadOptions: { active: false},
)
```

LazyLoading triggers events, so you can listen for "lazyLoadStart", "loadProgress", "loadingComplete".

```js
this.lazyCamera = this.P2P.cameras.createCamera(
  this.cameras.main,
  ["lazyLoading"],
  "simple_psd"
);

this.events.on("loadProgress", (progress, currentlyLoading) => {
  console.log(`Loading is ${progress} complete.`);
  console.log(currentlyLoading); // Array of items currently loading.
});

this.events.on("loadingComplete", () => {
  console.log(`Lazy loading is complete.`);
});
```


### Draggable

The draggable camera lets you click and drag around the canvas. That's about it. It should work with desktop and mobile and has an easing feature that you can switch on and off.

```js
// Initialize a draggable camera. Try it out!
this.dragCam = this.P2P.createCamera(this.camera, ['draggable']);

// Initialize a draggable camera with options
this.dragCam = this.P2P.createCamera(this.camera, ['draggable']
  draggableOptions: {
    easeDragging: true // use easing defaults
  })
```

Just like the lazyLoad feature, you can create the camera with defaults and set specific parameters later on.

Dragging triggers events, so you can listen for "dragOnStart", "isDragging" and "dragOnComplete".

```js
this.dragCam = this.P2P.createCamera(this.camera, ["draggable"]);

this.events.on("dragOnStart", () => {
  console.log(`Drag has begun.`);
});

this.events.on("dragOnComplete", () => {
  console.log(`Drag has completed.`);
});
```

### Combined

And of course you can combine functions to create a supercamera. 

```js
this.myCamera = this.P2P.createCamera(this.camera, ['lazyLoading', 'draggable'], {
  debug: {
    label: true, // Plase camera name in upper left hand corner of view
    shape: false, // draw a boundary around the camera view
    console: true // output camera info.
  },
  lazyLoadingOptions: {
    active: true // switch on and off
    extendPreloadBounds: 10, // extend/contract trigger bounds beyond camera
    transitionStyle: "fade", // method of adding the tile
    debug: {
      shape: true // draw a shape around the lazyLoad trigger
    }
  },
  draggableOptions: {
    useBounds: { x, y, width, height }, //set boundary of drag
    easeDragging: true, // use eased dragging
    friction: 0.95, // friction of ease
    minSpeed: 0.1 // min   }
   }
}
```

## P2P Camera Functions

Any P2P camera comes with a set of functions that are essentially presets that you can use to interact with
the PSD features.

### panToPoint()

Pass in a point and have the canvas pan to it. Can have it finish

```js
this.myCamera.panToPoint("psd_key", "nested/pointName", {
  pointPlacement: "topLeft", // pans the point to "center", "topLeft". Can pass in an array of top, left padding from topLeft (ie. pointPlacement: [300, 400])
  speed: 300, // time in ms it takes to pan to point
  easing: true, // turn easing on/off
});
```

Pans trigger events, so you can listen for "panOnStart", "panProgress" and "panOnComplete".

```js
this.myCamera.panToPoint("psd_key", "nested/pointName");

this.events.on("panProgress", ( value ) => {
  console.log(`Pan is ${value} percent complete.`);
});

this.events.on("panOnComplete", () => {
  console.log("Pan has started!"");
});

```

You could then control these parameters by calling the cameara

```js
this.myCamera.update({
  lazyLoadOptions: { active: false},
  draggableOptions: { easeAmount: 11 }
)
```

## Limitations

- At the moment, you are limited to one-psd-per-scene at a time. I have plans to fix this.

## Development

When developing, run : `npm run watch` to build plugin on save.

To link plugin to your project locally, run `npm link` in this folder, and then `npm link psd-to-json-plugin` in the project you'd like to use it in.

(To reset, just run the same commands with `unlink`.)


