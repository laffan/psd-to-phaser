(function(k,M){typeof exports=="object"&&typeof module<"u"?module.exports=M(require("phaser")):typeof define=="function"&&define.amd?define(["phaser"],M):(k=typeof globalThis<"u"?globalThis:k||self,k.PsdToPhaserPlugin=M(k.Phaser))})(this,(function(k){"use strict";var ht=Object.defineProperty;var gt=(k,M,N)=>M in k?ht(k,M,{enumerable:!0,configurable:!0,writable:!0,value:N}):k[M]=N;var T=(k,M,N)=>gt(k,typeof M!="symbol"?M+"":M,N);function M(n,e,t,o,r){return new Promise(s=>{let i=e.length;e.forEach(a=>{const c=a.name,l=`${t}/${a.filePath}`,f=()=>{i--,o(),i===0&&s()};a.type==="atlas"?N(n,c,l,a,f,r):a.type==="spritesheet"||a.type==="animation"?le(n,c,l,a,f,r):ce(n,c,l,f,r)}),i===0&&s()})}function N(n,e,t,o,r,s){console.log(`[${Date.now()}] Starting loadAtlas for key: ${e}`);const i={frames:{}};Object.entries(o.frames).forEach(([c,l])=>{i.frames[c]={frame:{x:l.x,y:l.y,w:l.width,h:l.height},rotated:!1,trimmed:!1,sourceSize:{w:l.width,h:l.height},spriteSourceSize:{x:0,y:0,w:l.width,h:l.height}}}),n.load.atlas(e,t,i);const a=()=>{n.textures.exists(e)?(s&&console.log(`ðŸ—ºï¸ Loaded atlas: ${e} from ${t}`),n.load.off("complete",a),r()):setTimeout(a,100)};n.load.on("complete",a),n.load.on("loaderror",c=>{console.error("Error loading file: ",c),n.load.off("complete",a)})}function le(n,e,t,o,r,s){n.load.spritesheet(e,t,{frameWidth:o.frame_width,frameHeight:o.frame_height}),n.load.once(`filecomplete-spritesheet-${e}`,()=>{s&&console.log(`ðŸ’¥ Loaded spritesheet: ${e} from ${t}`);for(let i=0;i<(o.frame_count||1);i++)r()})}function ce(n,e,t,o,r){n.load.image(e,t),n.load.once(`filecomplete-image-${e}`,()=>{r&&console.log(`ðŸŽ‘ Loaded image: ${e} from ${t}`),o()})}function j(n,e,t,o,r,s){const i=`${e.tilesetName}_tile_${e.col}_${e.row}`,a=`${t}/tiles/${e.tilesetName}/${o}/${i}.${e.filetype||"png"}`;!n.textures.exists(i)&&!n.textures.getTextureKeys().includes(i)&&!n.load.textureManager.exists(i)?(n.load.image(i,a),n.load.once(`filecomplete-image-${i}`,()=>{r(),s&&console.log(`ðŸ§© Loaded tile: ${i} from ${a}`)}),n.load.start()):(r(),s&&console.log(`Tile already loaded or loading: ${i}`))}function fe(n,e,t,o,r,s,i){e.forEach(a=>{for(let c=0;c<a.columns;c++)for(let l=0;l<a.rows;l++){const f={tilesetName:a.name,col:c,row:l,filetype:a.filetype},u=`${a.name}_tile_${c}_${l}`;i.push(u),j(n,f,t,o,()=>{const y=i.indexOf(u);y>-1&&i.splice(y,1),r()},s)}})}function J(n,e,t,o){const r=o.getData(e);if(!r||!r.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const s=r.basePath,i=r.original.tile_slice_size||150,a=de(t),c=a.tiles+a.sprites+a.singleTiles+a.atlases;let l=0;const f=[];o.isDebugEnabled("console")&&(console.log(`Total assets to load: ${c}`),console.log(`Tiles to load: ${a.tiles}`),console.log(`Sprites to load: ${a.sprites}`),console.log(`Single tiles to load: ${a.singleTiles}`),console.log(`Atlases to load: ${a.atlases}`),console.log(`Tile slice size: ${i}`));const u=()=>{l++;const y=l/c;n.events.emit("psdLoadProgress",y),o.isDebugEnabled("console")&&console.log(`â³ Progress: ${l} of ${c} ( ${(y*100).toFixed(2)}% )`),l===c&&(n.events.emit("psdLoadComplete"),o.isDebugEnabled("console")&&console.log("All PSD assets loaded"))};t.tiles&&t.tiles.length>0&&fe(n,t.tiles,s,i,u,o.isDebugEnabled("console"),f),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(y=>{j(n,y,s,i,u,o.isDebugEnabled("console"))}),t.sprites&&t.sprites.length>0&&M(n,t.sprites,s,u,o.isDebugEnabled("console")),n.load.isLoading()||n.load.start()}function de(n){let e=0,t=0,o=0,r=0;n.tiles&&n.tiles.forEach(i=>{i.lazyLoad||(e+=i.columns*i.rows)}),n.singleTiles&&(o=n.singleTiles.length);const s=i=>{i.forEach(a=>{a.lazyLoad||(a.type==="atlas"?r++:a.type==="spritesheet"?t+=a.frame_count||1:t++),a.children&&s(a.children)})};return n.sprites&&s(n.sprites),{tiles:e,sprites:t,singleTiles:o,atlases:r}}function ue(n,e,t,o,r,s){if(!t||!Array.isArray(t.layers)){console.error(`Invalid or missing layers data for key: ${e}`);return}const i={original:JSON.parse(JSON.stringify(t)),basePath:o,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};W(t.layers,i,!1,s==null?void 0:s.lazyLoad),r.setData(e,i),r.isDebugEnabled("console")&&console.log(`Processed JSON for key "${e}":`,i),J(n,e,i.initialLoad,r)}function W(n,e,t,o){n.forEach(r=>{var a;let s=t||((a=r.attributes)==null?void 0:a.lazyLoad)===!0;o!==void 0&&(o===!0||Array.isArray(o)&&o.includes(r.name))&&(s=!0);const i=s?e.lazyLoad:e.initialLoad;switch(r.category){case"tileset":i.tiles.push(r);break;case"sprite":i.sprites.push(r);break;case"zone":i.zones.push(r);break;case"point":i.points.push(r);break;case"group":i.groups.push(r),Array.isArray(r.children)&&W(r.children,e,s,o);break}})}function he(n){return function(e,t){if(!Array.isArray(t)||t.length===0){console.error("loadMultiple requires an array of PSD configurations");return}let o=0;const r=t.map(s=>new Promise((i,a)=>{const c=`${s.path}/data.json`,l=`${s.key}_temp_json`;e.load.json(l,c),e.load.once(`filecomplete-json-${l}`,(f,u,y)=>{if(y){const b=pe(y,s.lazyLoad);o+=b,s._tempData=y,i()}else console.error(`Failed to load JSON for key: ${s.key}`),a(new Error(`Failed to load JSON for key: ${s.key}`))}),e.load.once("loaderror",f=>{f.key===l&&(console.error(`Failed to load JSON file: ${c}`),a(new Error(`Failed to load JSON file: ${c}`)))})}));e.load.isLoading()||e.load.start(),Promise.all(r).then(()=>{t.forEach(a=>{const c=a._tempData,l=ge(c,a.position),f={original:JSON.parse(JSON.stringify(l)),basePath:a.path,positionOffset:a.position,isMultiplePsd:!0,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};Z(l.layers,f,!1,a.lazyLoad),n.setData(a.key,f),n.isDebugEnabled("console")&&console.log(`Processed multi-PSD data for key "${a.key}":`,f)});let s=0;const i=()=>{s++;const a=s/o;e.events.emit("psdLoadProgress",a),n.isDebugEnabled("console")&&console.log(`â³ Multi-PSD Progress: ${s} of ${o} (${(a*100).toFixed(2)}%)`),s===o&&(e.events.emit("psdLoadComplete"),n.isDebugEnabled("console")&&console.log("All multi-PSD assets loaded"))};t.forEach(a=>{const c=n.getData(a.key);me(e,a.key,c.initialLoad,n,i)}),e.load.isLoading()||e.load.start()}).catch(s=>{console.error("Failed to load multiple PSDs:",s)})}}function ge(n,e){const t=JSON.parse(JSON.stringify(n));function o(r){r.forEach(s=>{s.x+=e.x,s.y+=e.y,s.instances&&Array.isArray(s.instances)&&s.instances.forEach(i=>{i.x+=e.x,i.y+=e.y}),s.children&&Array.isArray(s.children)&&o(s.children)})}return t.layers&&Array.isArray(t.layers)&&o(t.layers),t}function pe(n,e){let t=0;function o(r,s=!1){r.forEach(i=>{let a=s||i.lazyLoad===!0;if(e!==void 0&&(e===!0||Array.isArray(e)&&e.includes(i.name))&&(a=!0),!a)switch(i.category){case"tileset":t+=(i.columns||1)*(i.rows||1);break;case"sprite":i.type==="atlas"?t++:i.type==="spritesheet"?t+=i.frame_count||1:t++;break}i.children&&Array.isArray(i.children)&&o(i.children,a)})}return n.layers&&Array.isArray(n.layers)&&o(n.layers),t}function me(n,e,t,o,r){const s=o.getData(e);if(!s||!s.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const i=s.basePath,a=s.original.tile_slice_size||150;t.tiles&&t.tiles.length>0&&ve(n,t.tiles,i,a,r,o.isDebugEnabled("console"),[],e),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(c=>{K(n,c,i,a,r,o.isDebugEnabled("console"),e)}),t.sprites&&t.sprites.length>0&&ye(n,t.sprites,i,r,o.isDebugEnabled("console"),e)}function ye(n,e,t,o,r,s){e.forEach(i=>{const a=i.name,c=`${s}_${a}`,l=`${t}/${i.filePath}`,f=()=>{o()};i.type==="atlas"?be(n,a,c,l,i,f,r):i.type==="spritesheet"||i.type==="animation"?xe(n,a,c,l,i,f,r):Pe(n,a,c,l,f,r)})}function be(n,e,t,o,r,s,i){const a={frames:{}};Object.entries(r.frames).forEach(([l,f])=>{a.frames[l]={frame:{x:f.x,y:f.y,w:f.width,h:f.height},rotated:!1,trimmed:!1,sourceSize:{w:f.width,h:f.height},spriteSourceSize:{x:0,y:0,w:f.width,h:f.height}}}),n.load.atlas(t,o,a);const c=()=>{n.textures.exists(t)?(i&&console.log(`ðŸ—ºï¸ Loaded atlas: ${t} from ${o}`),n.load.off("complete",c),s()):setTimeout(c,100)};n.load.on("complete",c)}function xe(n,e,t,o,r,s,i){n.load.spritesheet(t,o,{frameWidth:r.frame_width,frameHeight:r.frame_height}),n.load.once(`filecomplete-spritesheet-${t}`,()=>{i&&console.log(`ðŸ’¥ Loaded spritesheet: ${t} from ${o}`);for(let a=0;a<(r.frame_count||1);a++)s()})}function Pe(n,e,t,o,r,s){n.load.image(t,o),n.load.once(`filecomplete-image-${t}`,()=>{s&&console.log(`ðŸŽ‘ Loaded image: ${t} from ${o}`),r()})}function ve(n,e,t,o,r,s,i,a){e.forEach(c=>{for(let l=0;l<c.columns;l++)for(let f=0;f<c.rows;f++){const u=`${c.name}_tile_${l}_${f}`,y=`${a}_${u}`;i.push(y);const b={tilesetName:c.name,col:l,row:f,filetype:c.filetype};K(n,b,t,o,()=>{const w=i.indexOf(y);w>-1&&i.splice(w,1),r()},s,a)}})}function K(n,e,t,o,r,s,i){const a=`${e.tilesetName}_tile_${e.col}_${e.row}`,c=`${i}_${a}`,l=`${t}/tiles/${e.tilesetName}/${o}/${a}.${e.filetype||"png"}`;n.textures.exists(c)?(r(),s&&console.log(`Tile already loaded: ${c}`)):(n.load.image(c,l),n.load.once(`filecomplete-image-${c}`,()=>{r(),s&&console.log(`ðŸ§© Loaded tile: ${c} from ${l}`)}))}function Z(n,e,t,o){n.forEach(r=>{let s=t||r.lazyLoad===!0;o!==void 0&&(o===!0||Array.isArray(o)&&o.includes(r.name))&&(s=!0);const i=s?e.lazyLoad:e.initialLoad;switch(r.category){case"tileset":i.tiles.push(r);break;case"sprite":i.sprites.push(r);break;case"zone":i.zones.push(r);break;case"point":i.points.push(r);break;case"group":i.groups.push(r),Array.isArray(r.children)&&Z(r.children,e,s,o);break}})}function $e(n){return{load(e,t,o,r){const s=`${o}/data.json`;e.load.json(t,s),e.load.once(`filecomplete-json-${t}`,(i,a,c)=>{c?ue(e,t,c,o,n,r):console.error(`Loaded JSON is empty or invalid for key: ${t}`)}),e.load.once("loaderror",i=>{i.key===t&&console.error(`Failed to load JSON file: ${s}`)}),e.load.isLoading()||e.load.start()},loadMultiple:he(n)}}function H(n,e,t){const o=n.getData(e);if(!o||!o.lazyLoad)return!1;const r=o.lazyLoad[t.category+"s"];return r?r.some(s=>s.name===t.name):!1}function V(n,e,t){const o=n.add.container(e.x,e.y);if(t.isDebugEnabled("shape")){const r=n.add.graphics();r.lineStyle(2,16711935,1),r.strokeRect(0,0,e.width,e.height),o.add(r)}if(t.isDebugEnabled("label")){const r=n.add.text(0,-20,`${e.name} (Lazy)`,{fontSize:"16px",color:"#ff00ff",backgroundColor:"#ffffff"});o.add(r)}return o}function O(n,e){n.hasOwnProperty("attributes")&&(e.attributes=n.attributes)}function we(n,e,t,o,r,s,i){const a=n.add.container(e.x,e.y);if(a.setName(e.name),a.setData("tileData",e),a.setData("tileSliceSize",o),a.setData("psdKey",i),a.setDepth(e.initialDepth),O(e,a),["setX","setY","setPosition","setBlendMode","setAlpha","setDepth","setMask"].forEach(u=>{_e(a,u)}),H(t,i,e)){const u=V(n,e,t);u&&a.add(u)}else{const u=t.getData(i),y=(u==null?void 0:u.isMultiplePsd)||!1;Ae(n,a,e,o,y,i)}r.add(a);const f=n.add.group();De(n,e,o,f,t),r.debugGroup=f}function Ae(n,e,t,o,r=!1,s){for(let i=0;i<t.columns;i++)for(let a=0;a<t.rows;a++){const c=i*o,l=a*o,u=`${r&&s?`${s}_${t.name}`:t.name}_tile_${i}_${a}`,y=U(n,{x:c,y:l,key:u,initialDepth:t.initialDepth},e);y&&e.add(y)}}function _e(n,e){const t=Phaser.GameObjects.Container.prototype[e];n[e]=function(...o){const r=t.apply(this,o);if(["setX","setY","setPosition"].includes(e)){const i=e==="setX"||e==="setPosition"?o[0]-this.x:0,a=e==="setY"?o[0]-this.y:e==="setPosition"?o[1]-this.y:0;this.each(c=>{i!==0&&(c.x+=i),a!==0&&(c.y+=a)})}else this.each(i=>{typeof i[e]=="function"&&i[e](...o)});const s=this.getData("pendingMethodCalls")||[];return s.push({method:e,args:o}),this.setData("pendingMethodCalls",s),r}}function U(n,e,t){if(n.textures.exists(e.key)){const o=n.add.image(e.x,e.y,e.key);return o.setOrigin(0,0),(t instanceof Phaser.GameObjects.Group||t instanceof Phaser.GameObjects.Container)&&t.add(o),o}else return console.warn(`Texture not found for tile: ${e.key}`),null}function De(n,e,t,o,r){if(r.isDebugEnabled("shape")){const i=n.add.graphics();i.setDepth(1e3),i.lineStyle(2,16711680,1),i.strokeRect(e.x,e.y,e.columns*t,e.rows*t),i.isDebugObject=!0,o.add(i)}if(r.isDebugEnabled("label")){const i=n.add.text(e.x,e.y-20,e.name,{fontSize:"16px",color:"#ff0000",backgroundColor:"#ffffff"});i.setDepth(1e3),i.isDebugObject=!0,o.add(i)}}function Le(n,e,t,o,r){const s=n.add.sprite(e.x,e.y,r||e.name);return s.setName(e.name),s.setOrigin(0,0),s.setDepth(e.initialDepth||0),O(e,s),e.frame!==void 0&&s.setFrame(e.frame),s}function Se(n,e,t,o,r){const s=n.add.group();s.name=e.name;const i=r||e.name;if(n.textures.exists(i)){const c=n.textures.get(i).getFrameNames(),l=Object.keys(e.frames).reduce((f,u,y)=>(f[u]=y,f),{});e.instances&&Array.isArray(e.instances)&&e.instances.forEach(f=>{const{name:u,x:y,y:b}=f,w=l[u];if(w!==void 0&&w<c.length){const $=c[w],g=n.add.sprite(y,b,i,$);g.setName(u),g.setOrigin(0,0),s.add(g),g.setDepth(e.initialDepth||0),t.isDebugEnabled("console")&&console.log(`Placed spritesheet instance: ${u}, at (${y}, ${b}), using frame: ${$}`)}else console.warn(`Frame for "${u}" not found in spritesheet "${i}"`)})}else console.error(`Texture "${i}" not found. Make sure the spritesheet is loaded correctly.`);return s.setDepth(e.initialDepth||0),O(e,s),s}function Ge(n,e,t,o,r){const s=n.add.group();s.name=e.name;const i=r||e.name;if(n.textures.exists(i)){const c=n.textures.get(i).getFrameNames();e.instances&&Array.isArray(e.instances)&&e.instances.forEach(l=>{const{name:f,x:u,y}=l;if(c.includes(f)){const b=n.add.sprite(u,y,i,f);b.setName(f),b.setOrigin(0,0),s.add(b),b.setDepth(e.initialDepth||0)}else console.warn(`Frame "${f}" not found in atlas "${i}"`)})}else console.error(`Texture "${i}" not found. Make sure the atlas is loaded correctly.`);return s.setDepth(e.initialDepth||0),s}function Me(n,e,t,o,r,s){var c,l,f,u,y,b,w,$;const i=r||e.name,a=n.add.sprite(e.x,e.y,i,0);if(a.setName(e.name),a.setOrigin(0,0),a.setDepth(e.initialDepth||0),O(e,a),e.frame_width&&e.frame_height){const g={key:i,frames:n.anims.generateFrameNumbers(i,{start:0,end:e.frame_count?e.frame_count-1:-1}),frameRate:((c=e.attributes)==null?void 0:c.frameRate)||24,repeat:((l=e.attributes)==null?void 0:l.repeat)!==void 0?e.attributes.repeat:-1};((f=e.attributes)==null?void 0:f.yoyo)!==void 0&&(g.yoyo=e.attributes.yoyo),((u=e.attributes)==null?void 0:u.delay)!==void 0&&(g.delay=e.attributes.delay),((y=e.attributes)==null?void 0:y.repeatDelay)!==void 0&&(g.repeatDelay=e.attributes.repeatDelay),((b=e.attributes)==null?void 0:b.duration)!==void 0&&(g.duration=e.attributes.duration),((w=e.attributes)==null?void 0:w.showOnStart)!==void 0&&(g.showOnStart=e.attributes.showOnStart),(($=e.attributes)==null?void 0:$.hideOnComplete)!==void 0&&(g.hideOnComplete=e.attributes.hideOnComplete),s&&(Object.assign(g,s),g.key=i,s.frames||(g.frames=n.anims.generateFrameNumbers(i,{start:0,end:e.frame_count?e.frame_count-1:-1}))),n.anims.exists(i)||n.anims.create(g),a.play(i)}return a}function q(n,e,t,o,r,s,i){if(e.lazyLoad){const l=V(n,e,t);l&&o.add(l),r();return}const a=t.getData(s),c=a!=null&&a.isMultiplePsd?`${s}_${e.name}`:e.name;if(n.textures.exists(c)){let l=null;switch(e.type){case"spritesheet":l=Se(n,e,t,s,c);break;case"atlas":l=Ge(n,e,t,s,c);break;case"animation":l=Me(n,e,t,s,c,i);break;default:l=Le(n,e,t,s,c);break}if(l){l instanceof Phaser.GameObjects.Group?l.getChildren().forEach(u=>{o.add(u)}):o.add(l),e.alpha!==void 0&&l.setAlpha(e.alpha),e.hidden!==void 0&&l.setVisible(!1),l.setDepth(e.initialDepth||0);const f=n.add.group();ke(n,e,f,t),o.debugGroup=f}else console.error(`Failed to place sprite: ${e.name}`)}else console.warn(`Texture not found for sprite: ${e.name} (looking for texture key: ${c})`);r()}function ke(n,e,t,o){if(o.isDebugEnabled("shape")){const s=n.add.graphics();s.setDepth(1e3),s.lineStyle(2,65280,1),s.strokeRect(e.x,e.y,e.width,e.height),s.isDebugObject=!0,t.add(s)}if(o.isDebugEnabled("label")){const s=n.add.text(e.x,e.y-20,e.name,{fontSize:"16px",color:"#00ff00",backgroundColor:"#ffffff"});s.setDepth(1e3),s.isDebugObject=!0,t.add(s)}}function ze(n,e,t,o,r,s){const i=Ce(n,e);if(i){o.add(i);const a=n.add.group();Ee(n,e,a,t),o.debugGroup=a}}function Ce(n,e){if(!e||e.children)return null;const t=F(e);let o,r;if(t instanceof Phaser.Geom.Polygon){const s=Phaser.Geom.Polygon.GetAABB(t);o=n.add.zone(s.x,s.y,s.width,s.height),r=t.points}else o=n.add.zone(t.x,t.y,t.width,t.height),r=[new Phaser.Geom.Point(t.x,t.y),new Phaser.Geom.Point(t.x+t.width,t.y),new Phaser.Geom.Point(t.x+t.width,t.y+t.height),new Phaser.Geom.Point(t.x,t.y+t.height)];return o.setName(e.name||"unnamed_zone"),O(e,o),o.setData("points",r),Object.keys(e).forEach(s=>{["name","subpaths","bbox","children"].includes(s)||o.setData(s,e[s])}),o}function F(n){if(n.subpaths&&Array.isArray(n.subpaths)&&n.subpaths.length>0&&Array.isArray(n.subpaths[0])){const e=n.subpaths[0].flatMap(t=>new Phaser.Geom.Point(t[0],t[1]));return new Phaser.Geom.Polygon(e)}else if(n.bbox&&typeof n.bbox=="object"){const{left:e,top:t,right:o,bottom:r}=n.bbox;if(typeof e=="number"&&typeof t=="number"&&typeof o=="number"&&typeof r=="number")return new Phaser.Geom.Rectangle(e,t,o-e,r-t)}return console.error("Unable to create zone shape. Invalid zone data:",n),new Phaser.Geom.Rectangle(0,0,1,1)}function Ee(n,e,t,o){if(o.isDebugEnabled("shape")){const s=F(e),i=n.add.graphics();i.lineStyle(2,255,1),s instanceof Phaser.Geom.Polygon?i.strokePoints(s.points,!0):i.strokeRect(s.x,s.y,s.width,s.height),i.setDepth(1e3),i.isDebugObject=!0,t.add(i)}if(o.isDebugEnabled("label")){const s=F(e);let i,a;if(s instanceof Phaser.Geom.Polygon){const l=Phaser.Geom.Polygon.GetAABB(s);i=l.centerX,a=l.centerY}else i=s.centerX,a=s.centerY;const c=n.add.text(i,a,e.name,{fontSize:"16px",color:"#0000ff",backgroundColor:"#ffffff"});c.setOrigin(.5),c.setDepth(1e3),c.isDebugObject=!0,t.add(c)}}function Te(n,e,t,o,r,s){const i=Ne(n,e);if(i){o.add(i);const a=n.add.group();Oe(n,e,a,t),o.debugGroup=a}}function Ne(n,e,t){if(e.children)return null;const o=n.add.container(e.x,e.y);return o.setData("pointData",e),o.setName(e.name),O(e,o),o}function Oe(n,e,t,o){if(o.isDebugEnabled("shape")){const s=n.add.circle(e.x,e.y,5,16711680);s.setStrokeStyle(2,16711680),s.setDepth(1e3),s.isDebugObject=!0,t.add(s)}if(o.isDebugEnabled("label")){const s=n.add.text(e.x,e.y-20,e.name,{fontSize:"16px",color:"#ff0000",backgroundColor:"#ffffff"});s.setOrigin(.5,1),s.setDepth(1e3),s.isDebugObject=!0,t.add(s)}}const Q=["setAlpha","setAngle","setActive","setAlpha","setBlendMode","setDepth","setDisplaySize","setFlip","setMask","setOrigin","setPipeline","setPosition","setRotation","setScale","setScrollFactor","setSize","setTint","setVisible","setX","setY","setZ"];function Ie(n,e){e instanceof Phaser.GameObjects.Group?Be(n,e):Re(n,e)}function Be(n,e){Q.forEach(t=>{e[t]=Xe(n,t)})}function Re(n,e){Q.forEach(t=>{t==="remove"&&(e[t]=(o={})=>{e.removedFromScene()})})}function Xe(n,e){return function(...t){const o=typeof t[t.length-1]=="object"&&!Array.isArray(t[t.length-1])?t.pop():{},r=o.depth!==void 0?o.depth:1/0;ee(this,e,t,r,0)}}function ee(n,e,t,o,r){r>o||(n instanceof Phaser.GameObjects.Group?r<o&&n.getChildren().forEach(i=>{ee(i,e,t,o,r+1)}):typeof n[e]=="function"&&n[e](...t))}function Ve(n){return function(t,o={}){let r,s=1/0;typeof t=="string"?(r=t,s=o.depth!==void 0?o.depth:1/0):typeof t=="object"&&(s=t.depth!==void 0?t.depth:1/0);let i=!1;const a=(l,f=0)=>{if(!(f>=s)){if(l instanceof Phaser.GameObjects.Group&&(l.getChildren().forEach(u=>a(u,f+1)),f===s)){l.clear(),i=!0;return}"parentContainer"in l&&l.parentContainer?l.parentContainer.remove(l):l.scene&&l.scene.children.remove(l),typeof l.destroy=="function"&&l.destroy(!0),i=!0}},c=(l,f)=>{if(f.length===0)return a(l),!0;if(l instanceof Phaser.GameObjects.Group){const u=f[0],y=l.getChildren().find(b=>b.name===u);if(y)return c(y,f.slice(1))}return!1};if(r){const l=r.split("/");i=c(this,l)}else a(this);return i||console.warn(`Object not found or already removed: ${r||"root"}`),i}}function Fe(n,e){e.remove=Ve()}function Ye(n,e){e instanceof Phaser.GameObjects.Group?Je(n,e):e instanceof Phaser.GameObjects.Sprite&&je(n,e)}function je(n,e){e.updateAnimation=function(t){return te(e,t)}}function Je(n,e){e.updateAnimation=function(t){function o(r){r instanceof Phaser.GameObjects.Sprite&&r.anims&&r.anims.currentAnim?te(r,t):r instanceof Phaser.GameObjects.Group&&r.getChildren().forEach(o)}return o(e),e}}function te(n,e){var i;const t=(i=n.anims.currentAnim)==null?void 0:i.key;if(!t)return console.warn("No animation currently playing on sprite"),n;const o=n.scene,r=o.anims.get(t);if(!r)return console.warn(`Animation ${t} not found`),n;const s={key:t,frames:r.frames.map(a=>({key:a.textureKey,frame:a.textureFrame})),frameRate:r.frameRate,duration:r.duration,repeat:r.repeat,repeatDelay:r.repeatDelay,yoyo:r.yoyo,showOnStart:r.showOnStart,hideOnComplete:r.hideOnComplete,...e};return s.key=t,o.anims.remove(t),o.anims.create(s),n.play(t),n}function We(n){return function(t,o={}){if(!t)return this;const r=t.split("/"),s=o.depth!==void 0?o.depth:1/0;function i(c,l,f){if(f>s||l.length===0)return null;const[u,...y]=l;let b;if(c instanceof Phaser.GameObjects.Group)b=c.getChildren();else if(c instanceof Phaser.GameObjects.Container)b=c.list;else return null;const w=b.filter($=>!$.isDebugObject);for(const $ of w)if($.name===u){if(y.length===0)return $;if($ instanceof Phaser.GameObjects.Group||$ instanceof Phaser.GameObjects.Container)return i($,y,f+1)}for(const $ of w)if($ instanceof Phaser.GameObjects.Group||$ instanceof Phaser.GameObjects.Container){const g=i($,l,f+1);if(g)return g}return null}let a=null;return this instanceof Phaser.GameObjects.Group||this instanceof Phaser.GameObjects.Container?a=i(this,r,0):a=this.name===r[0]?this:null,a?oe(n,a):console.warn(`Item not found at path: ${t}`),a}}function Ke(n,e){e.target=We(n)}function oe(n,e){Ie(n,e),Fe(n,e),Ye(n,e),Ke(n,e)}function Y(n,e){if(e.length===0)return n;const[t,...o]=e,r=n.find(s=>s.name===t);return r?o.length===0?r:Y(r.children||[],o):null}function Ze(n){return function(t,o,r,s={}){const i=n.getData(o);if(!i||!i.original)return console.error(`No data found for key: ${o}`),t.add.group();const a=i.original.tile_slice_size||150,c=t.add.group(),l=Y(i.original.layers,r.split("/"));if(!l)return console.error(`No layer found with path: ${r}`),c;const f=ne(t,l,n,a,c,o,s);return oe(n,f),t.events.emit("layerPlaced",r),f}}function ne(n,e,t,o,r,s,i){if(e.category==="group"){if(Array.isArray(e.children)&&(i.depth===void 0||i.depth>0)){const a=n.add.group();return a.name=e.name,e.children.forEach(c=>{const l=ne(n,c,t,o,a,s,{...i,depth:i.depth!==void 0?i.depth-1:void 0});l instanceof Phaser.GameObjects.GameObject&&a.add(l)}),r.add(a),a}return r}else{if(e.category==="group")return r;if(H(t,s,e)){const c=V(n,{...e},t);return c&&r.add(c),r}switch(e.category){case"tileset":return we(n,e,t,o,r,()=>{},s),r;case"sprite":return q(n,e,t,r,()=>{},s,i.animationOptions),r;case"zone":return ze(n,e,t,r),r;case"point":return Te(n,e,t,r),r;default:return console.error(`Unknown layer category: ${e.category}`),r}}}function He(n){return function(t,o,r){const s=n.getData(o);if(!s)return console.log(`No PSD data found for key: ${o}`),null;const i=r.split("/"),a=Y(s.original.layers,i);if(!a)return console.log(`Sprite not found: ${r}`),console.log(`Available sprites: ${JSON.stringify(s.original.layers.map(u=>u.name))}`),null;const l=s.isMultiplePsd||!1?`${o}_${a.name}`:a.name;if(t.textures.exists(l))return t.textures.get(l);const f=`${s.basePath}/${a.filePath}`;return t.load.image(l,f),t.load.once(`filecomplete-image-${l}`,()=>{console.log(`Texture loaded: ${l}`)}),t.load.start(),t.load.once("complete",()=>{console.log(`Load complete for: ${l}`)}),t.textures.exists(l)?t.textures.get(l):(console.log(`Failed to load texture: ${l}`),null)}}function Ue(n,e,t={}){const o=e.scene;let r=!1,s=!1,i=new Phaser.Math.Vector2,a=new Phaser.Math.Vector2,c=new Phaser.Math.Vector2;const f={...{easeDragging:!1,friction:.95,minSpeed:.1,ignore:[]},...t};function u(){f.useBounds&&(typeof f.useBounds=="object"?(console.log("using custom size"),e.setBounds(f.useBounds.x,f.useBounds.y,f.useBounds.width,f.useBounds.height)):console.warn("useBounds object must have {x, y, width, height} format"))}function y(p){const v=[];let A=p;for(;A;)A.name&&v.unshift(A.name),A=A.parentContainer||null;return v.join("/")}function b(p){if(!f.ignore||f.ignore.length===0)return!1;const v=y(p),A=p.name||"";for(const S of f.ignore)if(A===S||v===S||v.endsWith("/"+S)||v.startsWith(S+"/")||v===S||v.includes("/"+S+"/"))return!0;return!1}function w(p){if(!f.ignore||f.ignore.length===0)return!1;const v=o.input.hitTestPointer(p);for(const A of v)if(b(A))return!0;return!1}function $(p){s||w(p)||(r=!0,c.copy(p),i.copy(p),a.reset(),o.events.emit("draggableStart",e))}function g(p){if(!r)return;const v=p.x-i.x,A=p.y-i.y;e.scrollX-=v/e.zoom,e.scrollY-=A/e.zoom,a.set(-v,-A),i.copy(p),o.events.emit("draggableActive",e)}function D(){r=!1,f.easeDragging||a.reset(),o.events.emit("draggableComplete",e)}function L(){!r&&f.easeDragging&&(a.length()>f.minSpeed?(e.scrollX+=a.x/e.zoom,e.scrollY+=a.y/e.zoom,a.scale(f.friction),o.events.emit("draggableActive",e)):a.reset())}function P(){o.input.on("pointerdown",$),o.input.on("pointermove",g),o.input.on("pointerup",D),o.events.on("update",L)}return P(),u(),{isDragging:()=>r,isPaused:()=>s,getVelocity:()=>a.clone(),setOptions:p=>{Object.assign(f,p),u(),f.easeDragging||a.reset()},pause:()=>{s=!0,r&&(r=!1,a.reset(),o.events.emit("draggableComplete",e))},resume:()=>{s=!1}}}function qe(n,e,t={}){var I;const o=e.scene,r=t.targetKeys||Qe(n);if(r.length===0)return console.warn("No PSDs found for lazy loading"),{};const s=[];if(r.forEach(d=>{const m=n.getData(d);m&&m.lazyLoad&&(m.lazyLoad.sprites&&m.lazyLoad.sprites.forEach(_=>{s.push({..._,_psdKey:d})}),m.lazyLoad.tiles&&m.lazyLoad.tiles.forEach(_=>{S(_,m.original.tile_slice_size).forEach(h=>{s.push({...h,_psdKey:d})})}))}),s.length===0)return(I=t.debug)!=null&&I.console&&console.log("No lazy load items found in target PSDs:",r),{};let i,a=null,c=[],l=new Set,f=null,u=null;function y(){var d,m;t.createBoundaryCamera&&b(),w(),$(),((d=t.debug)!=null&&d.shape||(m=t.debug)!=null&&m.label)&&g(),L(),z()}function b(){u=o.cameras.add(),u.setVisible(!1),u.setZoom(1),u.setScroll(e.scrollX,e.scrollY),u.setSize(e.width,e.height)}function w(){const d=t.extendPreloadBounds||0;if(u){u.setScroll(e.scrollX,e.scrollY);const m=e.width/e.zoom,_=e.height/e.zoom,h=e.scrollX+e.width/2,x=e.scrollY+e.height/2;i=new Phaser.Geom.Rectangle(h-m/2-d,x-_/2-d,m+d*2,_+d*2)}else{const m=e.width/e.zoom,_=e.height/e.zoom;i=new Phaser.Geom.Rectangle(e.scrollX-d,e.scrollY-d,m+d*2,_+d*2)}}function $(){var m,_;const d=h=>{const x=o.add.rectangle(h.x,h.y,h.width,h.height);return x.setOrigin(0,0),x.setStrokeStyle(1,65280),x.setDepth(1e3),{boundary:x,data:{...h,loaded:!1}}};c=s.map(d),(m=t.debug)!=null&&m.shape?c.forEach(h=>h.boundary.setVisible(!0)):c.forEach(h=>h.boundary.setVisible(!1)),(_=t.debug)!=null&&_.label&&c.forEach(h=>{const x=o.add.text(h.boundary.x,h.boundary.y-20,h.data.name,{fontSize:"12px",color:"#00ffff",backgroundColor:"#000000"});x.setOrigin(0,1),x.setDepth(1001)})}function g(){a=o.add.graphics(),a.setDepth(1e3),D()}function D(){a&&(a.clear(),a.lineStyle(2,16711935,1),a.strokeRect(i.x,i.y,i.width,i.height))}function L(){var m;const d=c.filter(({boundary:_,data:h})=>!h.loaded&&!l.has(P(h))&&Phaser.Geom.Intersects.RectangleToRectangle(_.getBounds(),i));d.length>0&&((m=t.debug)!=null&&m.console&&console.log(`LazyLoad: ${d.length} objects to load`),o.events.emit("lazyLoadStart",d.length),d.forEach(p))}function P(d){if(!d)return"unknown";const m=d.category||d.type;return m==="tile"||m==="tileset"?`tile_${d.tilesetName||d.name}_${d.col}_${d.row}`:`sprite_${d.name}_${Math.round(d.x)}_${Math.round(d.y)}`}function p({data:d}){var x;const m=P(d);l.add(m);const _=d._psdKey;(x=t.debug)!=null&&x.console&&console.log(`LazyLoad: Loading object ${m} from PSD ${_}`);const h={sprites:d.category==="sprite"?[d]:[],singleTiles:d.category==="tile"||d.category==="tileset"?[d]:[]};J(o,_,h,n),o.load.once("complete",()=>{v(d)}),o.load.start()}function v(d){var x,C,E;const m=P(d);if(l.delete(m),d.loaded=!0,(x=t.debug)!=null&&x.console&&console.log(`LazyLoad: Object loaded ${m}`),d.category==="sprite"){const G=o.add.group();q(o,d,n,G,()=>{G.getChildren().forEach(B=>{B.setDepth&&d.initialDepth!==void 0&&B.setDepth(d.initialDepth)}),o.children.sort("depth")},d._psdKey)}else if(d.category==="tile"||d.category==="tileset"){const G=A(o,d);U(o,{x:d.x-G.x,y:d.y-G.y,key:`${d.tilesetName}_tile_${d.col}_${d.row}`,initialDepth:d.initialDepth,tilesetName:d.tilesetName,col:d.col,row:d.row},G)}const _=c.filter(({data:G})=>G.loaded).length/c.length,h=Array.from(l);o.events.emit("lazyLoadProgress",_,h),(C=t.debug)!=null&&C.console&&console.log(`LazyLoad: Progress ${_.toFixed(2)}, Remaining:`,h),c.every(({data:G})=>G.loaded)&&(o.events.emit("lazyLoadingComplete"),(E=t.debug)!=null&&E.console&&console.log("LazyLoad: All objects loaded")),D()}function A(d,m){const _=d.children.list.find(E=>E instanceof Phaser.GameObjects.Container&&E.name===m.tilesetName);if(_)return _;const h=m.x-m.col*m.tile_slice_size,x=m.y-m.row*m.tile_slice_size,C=d.add.container(h,x);return C.setName(m.tilesetName),C.setDepth(m.initialDepth),C}function S(d,m){const _=[];for(let h=0;h<d.columns;h++)for(let x=0;x<d.rows;x++)_.push({category:"tile",name:`${d.name}_tile_${h}_${x}`,x:d.x+h*m,y:d.y+x*m,width:m,height:m,tile_slice_size:m,filetype:d.filetype||"png",tilesetName:d.name,col:h,row:x,initialDepth:d.initialDepth});return _}function z(){const d=t.checkInterval||300;f=window.setInterval(()=>{X()},d)}function X(){var d,m;w(),L(),((d=t.debug)!=null&&d.shape||(m=t.debug)!=null&&m.label)&&D()}return y(),{update:X,destroy:()=>{f!==null&&(window.clearInterval(f),f=null),c.forEach(d=>d.boundary.destroy()),a&&a.destroy(),u&&(o.cameras.remove(u),u=null)}}}function Qe(n){const e=n.psdData;return Object.keys(e||{})}function et(n,e,t,o={}){const r=e;if(t.includes("draggable")&&Object.assign(r,Ue(n,e,o.draggable)),t.includes("lazyLoad")){const s=typeof o.lazyLoad=="boolean"?o.lazyLoad?{}:{}:o.lazyLoad||{};Object.assign(r,qe(n,e,s))}return r}function tt(n){return function(e){let t,o;if(Array.isArray(e))if(e.length===2)typeof e[1]=="function"?(t={normal:e[0]},o={click:e[1]}):(t=e[0],o=e[1]);else if(e.length===3)t={normal:e[0],hover:e[1]},o={click:e[2]};else{console.error("Button: Invalid array format");return}else{console.error("Button: Invalid input format");return}if(!t.normal){console.error("Button requires at least a normal image");return}let r=t.normal,s=t.normal;if(s instanceof Phaser.GameObjects.Group){const g=s.getChildren();if(g.length===0){console.error("Button target group is empty");return}r=g[0]}else if(s instanceof Phaser.GameObjects.Container){if(s.list.length===0){console.error("Button target container is empty");return}r=s.list[0]}const i=r.scene;if(!i){console.error("Button target must have a valid scene");return}if(typeof r.setInteractive!="function"){console.error("Button target does not support interaction:",r.constructor.name);return}let a="normal";const c=r;let l,f,u,y;if(typeof c.getBounds=="function"){const g=c.getBounds();l=g.centerX||g.x+g.width/2,f=g.centerY||g.y+g.height/2,u=g.width,y=g.height}else l=c.x||0,f=c.y||0,u=c.width||c.displayWidth||100,y=c.height||c.displayHeight||100;const b=i.add.rectangle(l,f,u,y,0,0);b.setInteractive(),b.setDepth(Number.MAX_SAFE_INTEGER),b.setVisible(!0),t.normal&&t.normal.setVisible(!0),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);function w(g){t.normal&&t.normal.setVisible(!1),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);const D=t[g];D?D.setVisible(!0):t.normal&&t.normal.setVisible(!0),a=g}const $=i.sys.game.device.input.touch;return b.on("pointerdown",(g,D,L,P)=>{t.active&&w("active"),o.mousePress&&o.mousePress(s,{localX:D,localY:L,event:P},g)}),b.on("pointerup",(g,D,L,P)=>{var p;t.active&&(!$&&t.hover&&((p=b.input)!=null&&p.isOver)?w("hover"):w("normal")),o.click&&o.click(s,{localX:D,localY:L,event:P},g)}),!$&&t.hover&&(b.on("pointerover",(g,D,L,P)=>{w("hover"),o.mouseOver&&o.mouseOver(s,{localX:D,localY:L,event:P},g)}),b.on("pointerout",(g,D)=>{a!=="active"&&(w("normal"),o.mouseOut&&o.mouseOut(s,{event:D},g))})),a="normal",{destroy:()=>{b.off("pointerover"),b.off("pointerout"),b.off("pointerdown"),b.off("pointerup"),b.destroy()},getCurrentState:()=>a,showState:g=>{w(g)}}}}function ot(n){return function(e,t,o={}){const r=e.scene;if(!r){console.error("Unable to determine scene for fillZone");return}const s=e.getData("points");if(!s||s.length===0){console.error("Zone does not have valid points data");return}const i=new Phaser.Geom.Polygon(s),a=Phaser.Geom.Polygon.GetAABB(i);let c,l;if(t instanceof Phaser.GameObjects.Group){const L=t.getChildren()[0];if(!L){console.error("Group is empty");return}c=L.texture.key,l=o.useFrames||[L.frame.name]}else c=t.texture.key,l=o.useFrames||[t.frame.name];const f=r.textures.get(c);if(!f){console.error(`Texture not found: ${c}`);return}if(!l||l.length===0){const L=f.getFrameNames();L.length>0?l=L:l=Array.from({length:f.frameTotal},(P,p)=>p)}const u=r.add.group(),y=o.minInstances!==void 0?o.minInstances:5,b=o.maxInstances!==void 0?o.maxInstances:10,w=Phaser.Math.Between(y,b);let $=0,g=w*10,D=0;for(;$<w&&D<g;){const L=Phaser.Math.Between(a.left,a.right),P=Phaser.Math.Between(a.top,a.bottom);if(Phaser.Geom.Polygon.Contains(i,L,P)){const p=Phaser.Math.RND.pick(l),v=r.add.sprite(L,P,c,p);if(o.scaleRange){const A=Phaser.Math.FloatBetween(o.scaleRange[0],o.scaleRange[1]);v.setScale(A)}if(o.tint&&o.tint.length>0){const A=Phaser.Math.RND.pick(o.tint);v.setTint(A)}u.add(v),$++}D++}return console.log(`fillZone completed. Sprites placed: ${$}, Target: ${w}, Attempts: ${D}`),u}}function nt(n){return function(e,t,o,r={}){const s=t.scene,i=r.bounceBack||!1,a=r.joystickRadius||50;e.setOrigin(.5,.5),e.setPosition(e.x+e.width/2,e.y+e.height/2);const c={x:e.x,y:e.y},l=t.getData("points"),f=l?new Phaser.Geom.Polygon(l):t.getBounds();let u=null;const y=(P,p)=>{const v=se(f),A=new Phaser.Math.Vector2(P-v.x,p-v.y);A.length()>a&&A.setLength(a);const z={x:v.x+A.x,y:v.y+A.y};return l?Phaser.Geom.Polygon.Contains(f,z.x,z.y)?z:st(f,z.x,z.y):{x:Phaser.Math.Clamp(z.x,f.left,f.right),y:Phaser.Math.Clamp(z.y,f.top,f.bottom)}},b=(P,p)=>{const v=se(f);return{x:(P-v.x)/a,y:(p-v.y)/a}},w=(P,p)=>P.x>=p.left&&P.x<=p.right&&P.y>=p.top&&P.y<=p.bottom,$=P=>{u===null&&w(P,e.getBounds())&&(u=P,s.events.emit("joystickStart",{[o]:{isActive:!0,position:{x:e.x,y:e.y},change:{x:0,y:0},normalized:{x:0,y:0}}}))},g=P=>{if(P===u){const{x:p,y:v}=y(P.x,P.y);e.setPosition(p,v);const A={x:p-c.x,y:v-c.y},S=b(p,v);s.events.emit("joystickActive",{[o]:{isActive:!0,position:{x:p,y:v},change:A,normalized:S}})}},D=P=>{P===u&&(u=null,i?s.tweens.add({targets:e,x:c.x,y:c.y,duration:300,ease:"Bounce.out",onComplete:()=>{s.events.emit("joystickRelease",{[o]:{isActive:!1,position:c,change:{x:0,y:0},normalized:{x:0,y:0}}})}}):s.events.emit("joystickRelease",{[o]:{isActive:!1,position:{x:e.x,y:e.y},change:{x:e.x-c.x,y:e.y-c.y},normalized:b(e.x,e.y)}}))};s.input.on("pointerdown",$),s.input.on("pointermove",g),s.input.on("pointerup",D),s.input.on("pointerupoutside",D);function L(){s.input.off("pointerdown",$),s.input.off("pointermove",g),s.input.off("pointerup",D),s.input.off("pointerupoutside",D)}return{control:(P,p)=>{let v=new Phaser.Math.Vector2,A=0;const S=new Phaser.Math.Vector2(P.x,P.y),z=new Phaser.Math.Vector2(c.x,c.y),X=(h,x)=>{if(!p.directionLock)return[h,x];if(p.directionLock===4)return Math.abs(h)>Math.abs(x)?[h,0]:[0,x];if(p.directionLock===8){const C=Math.atan2(x,h),G=Math.round(8*C/(2*Math.PI)+8)%8*Math.PI/4;return[Math.cos(G),Math.sin(G)]}return[h,x]},I=(h,x,C)=>{switch([h,x]=X(h,x),p.type){case"speed":const E=p.maxSpeed||300;P.x+=h*E*C/1e3,P.y+=x*E*C/1e3;break;case"velocity":const G=P.body;if(G){const R=p.force||1;G.setVelocity(h*R*60,x*R*60)}break;case"unit":const B=s.time.now,ft=p.repeatRate||0,ie=p.pixels||100,re=.2;if((Math.abs(h)>re||Math.abs(x)>re)&&(A===0||B-A>=ft)){const R=Math.atan2(x,h);P.x+=Math.round(Math.cos(R)*ie),P.y+=Math.round(Math.sin(R)*ie),A=B}break;case"tracked":const ae=p.multiplier||1,dt=(h-z.x)*ae,ut=(x-z.y)*ae;P.setPosition(S.x+dt,S.y+ut);break}},d=h=>{if(h[o])if(p.type==="tracked"){const x=h[o].position;I(x.x,x.y,0)}else v.set(h[o].normalized.x,h[o].normalized.y),A===0&&I(v.x,v.y,0)},m=h=>{if(h[o])if(v.reset(),A=0,p.type==="velocity"){const x=P.body;x&&x.setVelocity(0,0)}else p.type==="tracked"&&r.bounceBack&&P.setPosition(S.x,S.y)},_=(h,x)=>{p.type!=="tracked"&&(v.x!==0||v.y!==0)&&I(v.x,v.y,x)};return s.events.on("joystickActive",d),s.events.on("joystickRelease",m),s.events.on("update",_),{destroy:()=>{L(),s.events.off("joystickActive",d),s.events.off("joystickRelease",m),s.events.off("update",_)}}},destroy:L}}}function st(n,e,t){let o=new Phaser.Geom.Point,r=Number.MAX_VALUE;for(let s=0;s<n.points.length;s++){const i=n.points[s],a=n.points[(s+1)%n.points.length],c=it(i,a,e,t),l=Phaser.Math.Distance.Between(e,t,c.x,c.y);l<r&&(r=l,o=c)}return o}function it(n,e,t,o){const r=e.x-n.x,s=e.y-n.y,i=((t-n.x)*r+(o-n.y)*s)/(r*r+s*s),a=Phaser.Math.Clamp(i,0,1);return new Phaser.Geom.Point(n.x+a*r,n.y+a*s)}function se(n){let e=0,t=0;for(const o of n.points)e+=o.x,t+=o.y;return new Phaser.Geom.Point(e/n.points.length,t/n.points.length)}function rt(n){return function(e,t,o={}){const r=e.scene,i={...{targetPositionY:"center",targetPositionX:"center",targetOffset:[0,0],speed:300,easing:!0},...o};let a,c,l=0,f=0;switch(Array.isArray(t)?[a,c]=t:(a=t.x,c=t.y,l=t.width||0,f=t.height||0),a+=l/2,c+=f/2,i.targetPositionX){case"left":a+=e.width/2;break;case"right":a-=e.width/2;break}switch(i.targetPositionY){case"top":c+=e.height/2;break;case"bottom":c-=e.height/2;break}a+=i.targetOffset[0],c+=i.targetOffset[1];const u=a-e.width/2,y=c-e.height/2,b=u-e.scrollX,w=i.speed;let $=Phaser.Math.Easing.Linear;i.easing===!0?$=Phaser.Math.Easing.Cubic.InOut:typeof i.easing=="function"&&($=i.easing),r.events.emit("panToStart"),r.tweens.add({targets:e,scrollX:u,scrollY:y,duration:w,ease:$,onUpdate:()=>{const g=1-(e.scrollX-u)/b;r.events.emit("panToProgress",g)},onComplete:()=>{r.events.emit("panToComplete")}})}}function at(n){return function(e){const{camera:t,target:o,scrollFactor:r=.25}=e;if(!o){console.warn('[P2P parallax] No valid "target" was provided.');return}let s,i;if(typeof t=="string"){if(i=o.scene,!i){console.warn(`[P2P parallax] Could not resolve scene from target for camera "${t}".`);return}s=i.cameras.getCamera(t),s||(s=i.cameras.main)}else if(t instanceof Phaser.Cameras.Scene2D.Camera)s=t,i=s.scene;else{if(i=o.scene,!i){console.warn("[P2P parallax] Could not find scene from target to use a default camera.");return}s=i.cameras.main}if(!s){console.warn("[P2P parallax] Could not resolve a valid camera.");return}if(!i){console.warn("[P2P parallax] Could not resolve a valid scene.");return}const a=i.sys;a._parallaxItems||(a._parallaxItems=[],i.events.on("update",()=>{const c=a._parallaxItems||[];for(const l of c)l.target.x=l.initX+l.camera.scrollX*l.factor,l.target.y=l.initY+l.camera.scrollY*l.factor})),a._parallaxItems.push({target:o,camera:s,factor:r,initX:o.x,initY:o.y})}}function lt(n){return{button:tt(),fillZone:ot(),joystick:nt(),panTo:rt(),parallax:at()}}class ct extends k.Plugins.BasePlugin{constructor(t){super(t);T(this,"psdData",{});T(this,"options");T(this,"load");T(this,"place");T(this,"getTexture");T(this,"use");T(this,"createCamera");this.options={},console.log("%câœ¨ PSD-to-Phaser v0.0.5 âœ¨","background: black; color: white; padding: 1px 3px; border-radius: 2px;"),this.load=$e(this),this.place=Ze(this),this.getTexture=He(this),this.use=lt(),this.createCamera=(o,r,s)=>et(this,o,r,s)}init(t={}){this.options={debug:!1,applyAlphaAll:!1,applyBlendModesAll:!1,...t},typeof this.options.debug=="boolean"&&(this.options.debug=this.options.debug?{shape:!0,label:!0,console:!0}:!1),this.options.debug&&console.log("PsdToPhaserPlugin initialized with options:",this.options)}setData(t,o){this.psdData[t]=o,this.isDebugEnabled("console")&&console.log(`Data set for key "${t}":`,o)}getData(t){return this.psdData[t]}isDebugEnabled(t){return typeof this.options.debug=="object"&&!!this.options.debug[t]}}return ct}));
