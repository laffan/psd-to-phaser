(function(z,D){typeof exports=="object"&&typeof module<"u"?module.exports=D(require("phaser")):typeof define=="function"&&define.amd?define(["phaser"],D):(z=typeof globalThis<"u"?globalThis:z||self,z.PsdToPhaserPlugin=D(z.Phaser))})(this,(function(z){"use strict";var kt=Object.defineProperty;var Lt=(z,D,O)=>D in z?kt(z,D,{enumerable:!0,configurable:!0,writable:!0,value:O}):z[D]=O;var N=(z,D,O)=>Lt(z,typeof D!="symbol"?D+"":D,O);function D(o){return o.category==="sprite"}function O(o){return o.category==="tileset"}function Z(o){return o.category==="zone"}function H(o){return o.category==="point"}function J(o){return o.category==="group"&&Array.isArray(o.children)}function E(o){return o.mask===!0&&typeof o.maskPath=="string"}function pe(o,e,t,n,s){return new Promise(i=>{let a=e.length;e.forEach(r=>{const l=r.name,c=`${t}/${r.filePath}`,f=()=>{a--,n(),a===0&&i()};E(r)&&K(o,r.name,t,r.maskPath,n,s),r.type==="atlas"?ye(o,l,c,r,f,s):r.type==="spritesheet"||r.type==="animation"?be(o,l,c,r,f,s):xe(o,l,c,f,s)}),a===0&&i()})}function K(o,e,t,n,s,i){const a=`${e}_mask`,r=`${t}/${n}`;o.textures.exists(a)?(s(),i&&console.log(`Mask already loaded: ${a}`)):(o.load.image(a,r),o.load.once(`filecomplete-image-${a}`,()=>{i&&console.log(`ðŸŽ­ Loaded mask: ${a} from ${r}`),s()}))}function ye(o,e,t,n,s,i){console.log(`[${Date.now()}] Starting loadAtlas for key: ${e}`);const a={frames:{}};Object.entries(n.frames).forEach(([l,c])=>{a.frames[l]={frame:{x:c.x,y:c.y,w:c.width,h:c.height},rotated:!1,trimmed:!1,sourceSize:{w:c.width,h:c.height},spriteSourceSize:{x:0,y:0,w:c.width,h:c.height}}}),o.load.atlas(e,t,a);const r=()=>{o.textures.exists(e)?(i&&console.log(`ðŸ—ºï¸ Loaded atlas: ${e} from ${t}`),o.load.off("complete",r),s()):setTimeout(r,100)};o.load.on("complete",r),o.load.on("loaderror",l=>{console.error("Error loading file: ",l),o.load.off("complete",r)})}function be(o,e,t,n,s,i){o.load.spritesheet(e,t,{frameWidth:n.frame_width,frameHeight:n.frame_height}),o.load.once(`filecomplete-spritesheet-${e}`,()=>{i&&console.log(`ðŸ’¥ Loaded spritesheet: ${e} from ${t}`);for(let a=0;a<(n.frame_count??1);a++)s()})}function xe(o,e,t,n,s){o.load.image(e,t),o.load.once(`filecomplete-image-${e}`,()=>{s&&console.log(`ðŸŽ‘ Loaded image: ${e} from ${t}`),n()})}function U(o,e,t,n,s,i){const a=`${e.tilesetName}_tile_${e.col}_${e.row}`,r=`${t}/tiles/${e.tilesetName}/${n}/${a}.${e.filetype??"png"}`;!o.textures.exists(a)&&!o.textures.getTextureKeys().includes(a)&&!o.load.textureManager.exists(a)?(o.load.image(a,r),o.load.once(`filecomplete-image-${a}`,()=>{s(),i&&console.log(`ðŸ§© Loaded tile: ${a} from ${r}`)}),o.load.start()):(s(),i&&console.log(`Tile already loaded or loading: ${a}`))}function Pe(o,e,t,n,s,i,a){e.forEach(r=>{for(let l=0;l<r.columns;l++)for(let c=0;c<r.rows;c++){const f={tilesetName:r.name,col:l,row:c,filetype:r.filetype},d=`${r.name}_tile_${l}_${c}`;a.push(d),U(o,f,t,n,()=>{const h=a.indexOf(d);h>-1&&a.splice(h,1),s()},i)}})}function q(o,e,t,n){const s=n.getData(e);if(!s||!s.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const i=s.basePath,a=s.original.tile_slice_size??150,r=$e(t),l=r.tiles+r.sprites+r.singleTiles+r.atlases+r.masks;let c=0;const f=[];n.isDebugEnabled("console")&&(console.log(`Total assets to load: ${l}`),console.log(`Tiles to load: ${r.tiles}`),console.log(`Sprites to load: ${r.sprites}`),console.log(`Single tiles to load: ${r.singleTiles}`),console.log(`Atlases to load: ${r.atlases}`),console.log(`Masks to load: ${r.masks}`),console.log(`Tile slice size: ${a}`));const d=()=>{c++;const h=c/l;o.events.emit("psdLoadProgress",h),n.isDebugEnabled("console")&&console.log(`â³ Progress: ${c} of ${l} ( ${(h*100).toFixed(2)}% )`),c===l&&(o.events.emit("psdLoadComplete"),n.isDebugEnabled("console")&&console.log("All PSD assets loaded"))};t.tiles&&t.tiles.length>0&&Pe(o,t.tiles,i,a,d,n.isDebugEnabled("console"),f),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(h=>{U(o,h,i,a,d,n.isDebugEnabled("console"))}),t.sprites&&t.sprites.length>0&&pe(o,t.sprites,i,d,n.isDebugEnabled("console")),t.tiles&&t.tiles.length>0&&t.tiles.forEach(h=>{!h.lazyLoad&&E(h)&&K(o,h.name,i,h.maskPath,d,n.isDebugEnabled("console"))}),t.groups&&t.groups.length>0&&t.groups.forEach(h=>{E(h)&&K(o,h.name,i,h.maskPath,d,n.isDebugEnabled("console"))}),o.load.isLoading()||o.load.start()}function $e(o){let e=0,t=0,n=0,s=0,i=0;o.tiles&&o.tiles.forEach(r=>{r.lazyLoad||(e+=r.columns*r.rows,E(r)&&i++)}),o.singleTiles&&(n=o.singleTiles.length);const a=r=>{r.forEach(l=>{l.lazyLoad||(l.type==="atlas"?s++:l.type==="spritesheet"?t+=l.frame_count??1:t++,E(l)&&i++)})};return o.sprites&&a(o.sprites),o.groups&&o.groups.forEach(r=>{E(r)&&i++}),{tiles:e,sprites:t,singleTiles:n,atlases:s,masks:i}}function ve(o,e,t,n,s,i){if(!t||!Array.isArray(t.layers)){console.error(`Invalid or missing layers data for key: ${e}`);return}const a={original:JSON.parse(JSON.stringify(t)),basePath:n,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};Q(t.layers,a,!1,i==null?void 0:i.lazyLoad),s.setData(e,a),s.isDebugEnabled("console")&&console.log(`Processed JSON for key "${e}":`,a),q(o,e,a.initialLoad,s)}function Q(o,e,t,n){o.forEach(s=>{var r;let i=t||((r=s.attributes)==null?void 0:r.lazyLoad)===!0;n!==void 0&&(n===!0||Array.isArray(n)&&n.includes(s.name))&&(i=!0);const a=i?e.lazyLoad:e.initialLoad;O(s)?a.tiles.push(s):D(s)?a.sprites.push(s):Z(s)?a.zones.push(s):H(s)?a.points.push(s):J(s)&&(a.groups.push(s),Q(s.children,e,i,n))})}function we(o){return function(e,t){if(!Array.isArray(t)||t.length===0){console.error("loadMultiple requires an array of PSD configurations");return}let n=0;const s=t.map(i=>new Promise((a,r)=>{const l=`${i.path}/data.json`,c=`${i.key}_temp_json`;e.load.json(c,l),e.load.once(`filecomplete-json-${c}`,(f,d,h)=>{if(h){const x=Le(h,i.lazyLoad);n+=x,i._tempData=h,a()}else console.error(`Failed to load JSON for key: ${i.key}`),r(new Error(`Failed to load JSON for key: ${i.key}`))}),e.load.once("loaderror",f=>{f.key===c&&(console.error(`Failed to load JSON file: ${l}`),r(new Error(`Failed to load JSON file: ${l}`)))})}));e.load.isLoading()||e.load.start(),Promise.all(s).then(()=>{t.forEach(r=>{const l=r._tempData,c=ke(l,r.position),f={original:JSON.parse(JSON.stringify(c)),basePath:r.path,positionOffset:r.position,isMultiplePsd:!0,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};te(c.layers,f,!1,r.lazyLoad),o.setData(r.key,f),o.isDebugEnabled("console")&&console.log(`Processed multi-PSD data for key "${r.key}":`,f)});let i=0;const a=()=>{i++;const r=i/n;e.events.emit("psdLoadProgress",r),o.isDebugEnabled("console")&&console.log(`â³ Multi-PSD Progress: ${i} of ${n} (${(r*100).toFixed(2)}%)`),i===n&&(e.events.emit("psdLoadComplete"),o.isDebugEnabled("console")&&console.log("All multi-PSD assets loaded"))};t.forEach(r=>{const l=o.getData(r.key);l&&Se(e,r.key,l.initialLoad,o,a)}),e.load.isLoading()||e.load.start()}).catch(i=>{console.error("Failed to load multiple PSDs:",i)})}}function ke(o,e){const t=JSON.parse(JSON.stringify(o));function n(s){s.forEach(i=>{i.x+=e.x,i.y+=e.y,i.instances&&Array.isArray(i.instances)&&i.instances.forEach(a=>{a.x+=e.x,a.y+=e.y}),i.children&&Array.isArray(i.children)&&n(i.children)})}return t.layers&&Array.isArray(t.layers)&&n(t.layers),t}function Le(o,e){let t=0;function n(s,i=!1){s.forEach(a=>{let r=i||a.lazyLoad===!0;if(e!==void 0&&(e===!0||Array.isArray(e)&&e.includes(a.name))&&(r=!0),!r)switch(a.category){case"tileset":t+=(a.columns||1)*(a.rows||1);break;case"sprite":a.type==="atlas"?t++:a.type==="spritesheet"?t+=a.frame_count||1:t++;break}a.children&&Array.isArray(a.children)&&n(a.children,r)})}return o.layers&&Array.isArray(o.layers)&&n(o.layers),t}function Se(o,e,t,n,s){const i=n.getData(e);if(!i||!i.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const a=i.basePath,r=i.original.tile_slice_size||150;t.tiles&&t.tiles.length>0&&ze(o,t.tiles,a,r,s,n.isDebugEnabled("console"),[],e),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(l=>{ee(o,l,a,r,s,n.isDebugEnabled("console"),e)}),t.sprites&&t.sprites.length>0&&_e(o,t.sprites,a,s,n.isDebugEnabled("console"),e)}function _e(o,e,t,n,s,i){e.forEach(a=>{const r=a.name,l=`${i}_${r}`,c=`${t}/${a.filePath}`,f=()=>{n()};a.type==="atlas"?Me(o,r,l,c,a,f,s):a.type==="spritesheet"||a.type==="animation"?Ae(o,r,l,c,a,f,s):De(o,r,l,c,f,s)})}function Me(o,e,t,n,s,i,a){const r={frames:{}};Object.entries(s.frames).forEach(([c,f])=>{r.frames[c]={frame:{x:f.x,y:f.y,w:f.width,h:f.height},rotated:!1,trimmed:!1,sourceSize:{w:f.width,h:f.height},spriteSourceSize:{x:0,y:0,w:f.width,h:f.height}}}),o.load.atlas(t,n,r);const l=()=>{o.textures.exists(t)?(a&&console.log(`ðŸ—ºï¸ Loaded atlas: ${t} from ${n}`),o.load.off("complete",l),i()):setTimeout(l,100)};o.load.on("complete",l)}function Ae(o,e,t,n,s,i,a){o.load.spritesheet(t,n,{frameWidth:s.frame_width,frameHeight:s.frame_height}),o.load.once(`filecomplete-spritesheet-${t}`,()=>{a&&console.log(`ðŸ’¥ Loaded spritesheet: ${t} from ${n}`);for(let r=0;r<(s.frame_count||1);r++)i()})}function De(o,e,t,n,s,i){o.load.image(t,n),o.load.once(`filecomplete-image-${t}`,()=>{i&&console.log(`ðŸŽ‘ Loaded image: ${t} from ${n}`),s()})}function ze(o,e,t,n,s,i,a,r){e.forEach(l=>{for(let c=0;c<l.columns;c++)for(let f=0;f<l.rows;f++){const d=`${l.name}_tile_${c}_${f}`,h=`${r}_${d}`;a.push(h);const x={tilesetName:l.name,col:c,row:f,filetype:l.filetype};ee(o,x,t,n,()=>{const w=a.indexOf(h);w>-1&&a.splice(w,1),s()},i,r)}})}function ee(o,e,t,n,s,i,a){const r=`${e.tilesetName}_tile_${e.col}_${e.row}`,l=`${a}_${r}`,c=`${t}/tiles/${e.tilesetName}/${n}/${r}.${e.filetype||"png"}`;o.textures.exists(l)?(s(),i&&console.log(`Tile already loaded: ${l}`)):(o.load.image(l,c),o.load.once(`filecomplete-image-${l}`,()=>{s(),i&&console.log(`ðŸ§© Loaded tile: ${l} from ${c}`)}))}function te(o,e,t,n){o.forEach(s=>{let i=t||s.lazyLoad===!0;n!==void 0&&(n===!0||Array.isArray(n)&&n.includes(s.name))&&(i=!0);const a=i?e.lazyLoad:e.initialLoad;switch(s.category){case"tileset":a.tiles.push(s);break;case"sprite":a.sprites.push(s);break;case"zone":a.zones.push(s);break;case"point":a.points.push(s);break;case"group":a.groups.push(s),Array.isArray(s.children)&&te(s.children,e,i,n);break}})}function Ge(o){return{load(e,t,n,s){const i=`${n}/data.json`;e.load.json(t,i),e.load.once(`filecomplete-json-${t}`,(a,r,l)=>{l?ve(e,t,l,n,o,s):console.error(`Loaded JSON is empty or invalid for key: ${t}`)}),e.load.once("loaderror",a=>{a.key===t&&console.error(`Failed to load JSON file: ${i}`)}),e.load.isLoading()||e.load.start()},loadMultiple:we(o)}}function oe(o,e,t){const n=o.getData(e);if(!n||!n.lazyLoad)return!1;const i={sprite:"sprites",tileset:"tiles",zone:"zones",point:"points",group:"groups"}[t.category];if(!i)return!1;const a=n.lazyLoad[i];return a?a.some(r=>r.name===t.name):!1}function W(o,e,t){const n=o.add.container(e.x,e.y);if(t.isDebugEnabled("shape")){const s=o.add.graphics();s.lineStyle(2,16711935,1),s.strokeRect(0,0,e.width,e.height),n.add(s)}if(t.isDebugEnabled("label")){const s=o.add.text(0,-20,`${e.name} (Lazy)`,{fontSize:"16px",color:"#ff00ff",backgroundColor:"#ffffff"});n.add(s)}return n}function B(o,e){o.attributes&&(e.attributes=o.attributes)}function R(o,e,t){if(!E(e))return null;const n=`${e.name}_mask`;if(!o.textures.exists(n))return console.warn(`Mask texture not found: ${n}`),null;const s=o.add.image(e.x,e.y,n);s.setOrigin(0,0),s.setVisible(!1);const i=s.createBitmapMask();return t.setMask&&t.setMask(i),s}function Ce(o,e,t){if(!E(e))return null;const n=`${e.name}_mask`;if(!o.textures.exists(n))return console.warn(`Mask texture not found: ${n}`),null;const s=o.add.image(e.x,e.y,n);s.setOrigin(0,0),s.setVisible(!1);const i=s.createBitmapMask();return t.setMask(i),s}const Ee={sprite:65280,tileset:16711680,zone:255,point:16711680,group:16776960},ne=1e3;function F(o,e,t,n){const s={shape:null,label:null},i=Ee[n.type],a=`#${i.toString(16).padStart(6,"0")}`;return e.isDebugEnabled("shape")&&(s.shape=Te(o,n,i),s.shape&&(s.shape.setDepth(ne),s.shape.isDebugObject=!0,t.add(s.shape))),e.isDebugEnabled("label")&&(s.label=Ne(o,n,a),s.label&&(s.label.setDepth(ne),s.label.isDebugObject=!0,t.add(s.label))),s}function Te(o,e,t){switch(e.type){case"point":const n=o.add.circle(e.x,e.y,5,t);return n.setStrokeStyle(2,t),n;case"zone":if(e.zoneShape){const s=o.add.graphics();return s.lineStyle(2,t,1),e.zoneShape instanceof Phaser.Geom.Polygon?s.strokePoints(e.zoneShape.points,!0):s.strokeRect(e.zoneShape.x,e.zoneShape.y,e.zoneShape.width,e.zoneShape.height),s}return null;case"sprite":case"tileset":case"group":default:if(e.width!==void 0&&e.height!==void 0){const s=o.add.graphics();return s.lineStyle(2,t,1),s.strokeRect(e.x,e.y,e.width,e.height),s}return null}}function Ne(o,e,t){const n={fontSize:"16px",color:t,backgroundColor:"#ffffff"};let s=e.x,i=e.y-20,a=0,r=0;switch(e.type){case"point":a=.5,r=1;break;case"zone":if(e.zoneShape){if(e.zoneShape instanceof Phaser.Geom.Polygon){const c=Phaser.Geom.Polygon.GetAABB(e.zoneShape);s=c.centerX,i=c.centerY}else s=e.zoneShape.centerX,i=e.zoneShape.centerY;a=.5,r=.5}break}const l=o.add.text(s,i,e.name,n);return l.setOrigin(a,r),l}function Oe(o,e,t,n,s,i,a){const r=o.add.container(e.x,e.y);if(r.setName(e.name),r.setData("tileData",e),r.setData("tileSliceSize",n),r.setData("psdKey",a),r.setDepth(e.initialDepth??0),B(e,r),["setX","setY","setPosition","setBlendMode","setAlpha","setDepth","setMask"].forEach(d=>{Ie(r,d)}),oe(t,a,e)){const d=W(o,e,t);d&&r.add(d)}else{const d=t.getData(a),h=(d==null?void 0:d.isMultiplePsd)||!1;Be(o,r,e,n,h,a)}Ce(o,e,r),s.add(r);const f=o.add.group();F(o,t,f,{type:"tileset",name:e.name,x:e.x,y:e.y,width:e.columns*n,height:e.rows*n}),s.debugGroup=f}function Be(o,e,t,n,s=!1,i){for(let a=0;a<t.columns;a++)for(let r=0;r<t.rows;r++){const l=a*n,c=r*n,d=`${s&&i?`${i}_${t.name}`:t.name}_tile_${a}_${r}`,h=se(o,{x:l,y:c,key:d,initialDepth:t.initialDepth},e);h&&e.add(h)}}function Ie(o,e){const t=Phaser.GameObjects.Container.prototype[e];o[e]=function(...n){const s=t.apply(this,n);if(["setX","setY","setPosition"].includes(e)){const a=e==="setX"||e==="setPosition"?n[0]-this.x:0,r=e==="setY"?n[0]-this.y:e==="setPosition"?n[1]-this.y:0;this.each(l=>{a!==0&&(l.x+=a),r!==0&&(l.y+=r)})}else this.each(a=>{typeof a[e]=="function"&&a[e](...n)});const i=this.getData("pendingMethodCalls")||[];return i.push({method:e,args:n}),this.setData("pendingMethodCalls",i),s}}function se(o,e,t){if(o.textures.exists(e.key)){const n=o.add.image(e.x,e.y,e.key);return n.setOrigin(0,0),(t instanceof Phaser.GameObjects.Group||t instanceof Phaser.GameObjects.Container)&&t.add(n),n}else return console.warn(`Texture not found for tile: ${e.key}`),null}function Re(o,e,t,n,s){const i=o.add.sprite(e.x,e.y,s||e.name);return i.setName(e.name),i.setOrigin(0,0),i.setDepth(e.initialDepth??0),B(e,i),e.frame!==void 0&&i.setFrame(e.frame),R(o,e,i),i}function Xe(o,e,t,n,s){const i=o.add.group();i.name=e.name;const a=s||e.name;if(o.textures.exists(a)){const l=o.textures.get(a).getFrameNames(),c=Object.keys(e.frames).reduce((f,d,h)=>(f[d]=h,f),{});e.instances&&e.instances.forEach(f=>{const{name:d,x:h,y:x}=f,w=c[d];if(w!==void 0&&w<l.length){const v=l[w],m=o.add.sprite(h,x,a,v);m.setName(d),m.setOrigin(0,0),i.add(m),m.setDepth(e.initialDepth??0),t.isDebugEnabled("console")&&console.log(`Placed spritesheet instance: ${d}, at (${h}, ${x}), using frame: ${v}`)}else console.warn(`Frame for "${d}" not found in spritesheet "${a}"`)})}else console.error(`Texture "${a}" not found. Make sure the spritesheet is loaded correctly.`);return i.setDepth(e.initialDepth??0),B(e,i),e.mask&&e.maskPath&&i.getChildren().forEach(r=>{R(o,e,r)}),i}function Ve(o,e,t,n,s){const i=o.add.group();i.name=e.name;const a=s||e.name;if(o.textures.exists(a)){const l=o.textures.get(a).getFrameNames();e.instances&&e.instances.forEach(c=>{const{name:f,x:d,y:h}=c;if(l.includes(f)){const x=o.add.sprite(d,h,a,f);x.setName(f),x.setOrigin(0,0),i.add(x),x.setDepth(e.initialDepth??0)}else console.warn(`Frame "${f}" not found in atlas "${a}"`)})}else console.error(`Texture "${a}" not found. Make sure the atlas is loaded correctly.`);return i.setDepth(e.initialDepth??0),B(e,i),e.mask&&e.maskPath&&i.getChildren().forEach(r=>{R(o,e,r)}),i}function Fe(o,e,t,n,s,i){var l,c,f,d,h,x,w,v;const a=s||e.name,r=o.add.sprite(e.x,e.y,a,0);if(r.setName(e.name),r.setOrigin(0,0),r.setDepth(e.initialDepth??0),B(e,r),R(o,e,r),e.frame_width&&e.frame_height){const m={key:a,frames:o.anims.generateFrameNumbers(a,{start:0,end:e.frame_count?e.frame_count-1:-1}),frameRate:((l=e.attributes)==null?void 0:l.frameRate)||24,repeat:((c=e.attributes)==null?void 0:c.repeat)!==void 0?e.attributes.repeat:-1};((f=e.attributes)==null?void 0:f.yoyo)!==void 0&&(m.yoyo=e.attributes.yoyo),((d=e.attributes)==null?void 0:d.delay)!==void 0&&(m.delay=e.attributes.delay),((h=e.attributes)==null?void 0:h.repeatDelay)!==void 0&&(m.repeatDelay=e.attributes.repeatDelay),((x=e.attributes)==null?void 0:x.duration)!==void 0&&(m.duration=e.attributes.duration),((w=e.attributes)==null?void 0:w.showOnStart)!==void 0&&(m.showOnStart=e.attributes.showOnStart),((v=e.attributes)==null?void 0:v.hideOnComplete)!==void 0&&(m.hideOnComplete=e.attributes.hideOnComplete),i&&(Object.assign(m,i),m.key=a,i.frames||(m.frames=o.anims.generateFrameNumbers(a,{start:0,end:e.frame_count?e.frame_count-1:-1}))),o.anims.exists(a)||o.anims.create(m),r.play(a)}return r}function ie(o,e,t,n,s,i,a){if(e.lazyLoad){const c=W(o,e,t);c&&n.add(c),s();return}const r=t.getData(i),l=r!=null&&r.isMultiplePsd?`${i}_${e.name}`:e.name;if(o.textures.exists(l)){let c=null;switch(e.type){case"spritesheet":c=Xe(o,e,t,i,l);break;case"atlas":c=Ve(o,e,t,i,l);break;case"animation":c=Fe(o,e,t,i,l,a);break;default:c=Re(o,e,t,i,l);break}if(c){c instanceof Phaser.GameObjects.Group?c.getChildren().forEach(d=>{n.add(d)}):n.add(c),e.alpha!==void 0&&c.setAlpha(e.alpha),e.hidden!==void 0&&c.setVisible(!1),c.setDepth(e.initialDepth||0);const f=o.add.group();F(o,t,f,{type:"sprite",name:e.name,x:e.x,y:e.y,width:e.width,height:e.height}),n.debugGroup=f}else console.error(`Failed to place sprite: ${e.name}`)}else console.warn(`Texture not found for sprite: ${e.name} (looking for texture key: ${l})`);s()}function Ye(o,e,t,n,s,i){const a=je(o,e);if(a){n.add(a);const r=o.add.group(),l=ae(e);F(o,t,r,{type:"zone",name:e.name,x:e.x,y:e.y,zoneShape:l}),n.debugGroup=r}}function je(o,e){const t=ae(e);let n,s;if(t instanceof Phaser.Geom.Polygon){const i=Phaser.Geom.Polygon.GetAABB(t);n=o.add.zone(i.x,i.y,i.width,i.height),s=t.points}else n=o.add.zone(t.x,t.y,t.width,t.height),s=[new Phaser.Geom.Point(t.x,t.y),new Phaser.Geom.Point(t.x+t.width,t.y),new Phaser.Geom.Point(t.x+t.width,t.y+t.height),new Phaser.Geom.Point(t.x,t.y+t.height)];return n.setName(e.name||"unnamed_zone"),B(e,n),n.setData("points",s),n.setData("category",e.category),n.setData("x",e.x),n.setData("y",e.y),n.setData("width",e.width),n.setData("height",e.height),e.initialDepth!==void 0&&n.setData("initialDepth",e.initialDepth),e.attributes&&n.setData("attributes",e.attributes),n}function ae(o){if(o.subpaths&&Array.isArray(o.subpaths)&&o.subpaths.length>0&&Array.isArray(o.subpaths[0])){const e=o.subpaths[0].flatMap(t=>new Phaser.Geom.Point(t[0],t[1]));return new Phaser.Geom.Polygon(e)}else if(o.bbox&&typeof o.bbox=="object"){const{left:e,top:t,right:n,bottom:s}=o.bbox;if(typeof e=="number"&&typeof t=="number"&&typeof n=="number"&&typeof s=="number")return new Phaser.Geom.Rectangle(e,t,n-e,s-t)}return console.error("Unable to create zone shape. Invalid zone data:",o),new Phaser.Geom.Rectangle(0,0,1,1)}function Je(o,e,t,n,s,i){const a=Ke(o,e);if(a){n.add(a);const r=o.add.group();F(o,t,r,{type:"point",name:e.name,x:e.x,y:e.y}),n.debugGroup=r}}function Ke(o,e){const t=o.add.container(e.x,e.y);return t.setData("pointData",e),t.setName(e.name),B(e,t),t}const re=["setAlpha","setAngle","setActive","setAlpha","setBlendMode","setDepth","setDisplaySize","setFlip","setMask","setOrigin","setPipeline","setPosition","setRotation","setScale","setScrollFactor","setSize","setTint","setVisible","setX","setY","setZ"];function We(o,e){e instanceof Phaser.GameObjects.Group?Ze(o,e):He(o,e)}function Ze(o,e){re.forEach(t=>{e[t]=Ue(o,t)})}function He(o,e){re.forEach(t=>{t==="remove"&&(e[t]=(n={})=>{e.removedFromScene()})})}function Ue(o,e){return function(...t){const n=typeof t[t.length-1]=="object"&&!Array.isArray(t[t.length-1])?t.pop():{},s=n.depth!==void 0?n.depth:1/0;le(this,e,t,s,0)}}function le(o,e,t,n,s){s>n||(o instanceof Phaser.GameObjects.Group?s<n&&o.getChildren().forEach(a=>{le(a,e,t,n,s+1)}):typeof o[e]=="function"&&o[e](...t))}function qe(o){return function(t,n={}){let s,i=1/0;typeof t=="string"?(s=t,i=n.depth!==void 0?n.depth:1/0):typeof t=="object"&&(i=t.depth!==void 0?t.depth:1/0);let a=!1;const r=(c,f=0)=>{if(!(f>=i)){if(c instanceof Phaser.GameObjects.Group&&(c.getChildren().forEach(d=>r(d,f+1)),f===i)){c.clear(),a=!0;return}"parentContainer"in c&&c.parentContainer?c.parentContainer.remove(c):c.scene&&c.scene.children.remove(c),typeof c.destroy=="function"&&c.destroy(!0),a=!0}},l=(c,f)=>{if(f.length===0)return r(c),!0;if(c instanceof Phaser.GameObjects.Group){const d=f[0],h=c.getChildren().find(x=>x.name===d);if(h)return l(h,f.slice(1))}return!1};if(s){const c=s.split("/");a=l(this,c)}else r(this);return a||console.warn(`Object not found or already removed: ${s||"root"}`),a}}function Qe(o,e){e.remove=qe()}function et(o,e){e instanceof Phaser.GameObjects.Group?ot(o,e):e instanceof Phaser.GameObjects.Sprite&&tt(o,e)}function tt(o,e){e.updateAnimation=function(t){return ce(e,t)}}function ot(o,e){e.updateAnimation=function(t){function n(s){s instanceof Phaser.GameObjects.Sprite&&s.anims&&s.anims.currentAnim?ce(s,t):s instanceof Phaser.GameObjects.Group&&s.getChildren().forEach(n)}return n(e),e}}function ce(o,e){var a;const t=(a=o.anims.currentAnim)==null?void 0:a.key;if(!t)return console.warn("No animation currently playing on sprite"),o;const n=o.scene,s=n.anims.get(t);if(!s)return console.warn(`Animation ${t} not found`),o;const i={key:t,frames:s.frames.map(r=>({key:r.textureKey,frame:r.textureFrame})),frameRate:s.frameRate,duration:s.duration,repeat:s.repeat,repeatDelay:s.repeatDelay,yoyo:s.yoyo,showOnStart:s.showOnStart,hideOnComplete:s.hideOnComplete,...e};return i.key=t,n.anims.remove(t),n.anims.create(i),o.play(t),o}function nt(o){return function(t,n={}){if(!t)return this;const s=t.split("/"),i=n.depth!==void 0?n.depth:1/0;function a(l,c,f){if(f>i||c.length===0)return null;const[d,...h]=c;let x;if(l instanceof Phaser.GameObjects.Group)x=l.getChildren();else if(l instanceof Phaser.GameObjects.Container)x=l.list;else return null;const w=x.filter(v=>!v.isDebugObject);for(const v of w)if(v.name===d){if(h.length===0)return v;if(v instanceof Phaser.GameObjects.Group||v instanceof Phaser.GameObjects.Container)return a(v,h,f+1)}for(const v of w)if(v instanceof Phaser.GameObjects.Group||v instanceof Phaser.GameObjects.Container){const m=a(v,c,f+1);if(m)return m}return null}let r=null;return this instanceof Phaser.GameObjects.Group||this instanceof Phaser.GameObjects.Container?r=a(this,s,0):r=this.name===s[0]?this:null,r?fe(o,r):console.warn(`Item not found at path: ${t}`),r}}function st(o,e){e.target=nt(o)}function fe(o,e){We(o,e),Qe(o,e),et(o,e),st(o,e)}function Y(o,e){if(e.length===0)return null;const[t,...n]=e,s=o.find(i=>i.name===t);return s?n.length===0?s:J(s)?Y(s.children,n):null:null}function it(o){return function(t,n,s,i={}){const a=o.getData(n);if(!a||!a.original)return console.error(`No data found for key: ${n}`),t.add.group();const r=a.original.tile_slice_size||150,l=t.add.group(),c=Y(a.original.layers,s.split("/"));if(!c)return console.error(`No layer found with path: ${s}`),l;const f=ue(t,c,o,r,l,n,i);return fe(o,f),t.events.emit("layerPlaced",s),f}}function ue(o,e,t,n,s,i,a){if(J(e)){if(a.depth===void 0||a.depth>0){const l=o.add.group();return l.name=e.name,e.children.forEach(c=>{const f=ue(o,c,t,n,l,i,{...a,depth:a.depth!==void 0?a.depth-1:void 0});f instanceof Phaser.GameObjects.GameObject&&l.add(f)}),E(e)&&l.getChildren().forEach(c=>{R(o,e,c)}),s.add(l),l}return s}if(oe(t,i,e)){const l=W(o,e,t);return l&&s.add(l),s}return O(e)?(Oe(o,e,t,n,s,()=>{},i),s):D(e)?(ie(o,e,t,s,()=>{},i,a.animationOptions),s):Z(e)?(Ye(o,e,t,s),s):H(e)?(Je(o,e,t,s),s):(console.error(`Unknown layer category: ${e.category}`),s)}function at(o){return function(t,n,s){const i=o.getData(n);if(!i)return console.log(`No PSD data found for key: ${n}`),null;const a=s.split("/"),r=Y(i.original.layers,a);if(!r)return console.log(`Sprite not found: ${s}`),console.log(`Available sprites: ${JSON.stringify(i.original.layers.map(d=>d.name))}`),null;if(!D(r))return console.log(`Layer "${s}" is not a sprite layer`),null;const c=i.isMultiplePsd||!1?`${n}_${r.name}`:r.name;if(t.textures.exists(c))return t.textures.get(c);const f=`${i.basePath}/${r.filePath}`;return t.load.image(c,f),t.load.once(`filecomplete-image-${c}`,()=>{console.log(`Texture loaded: ${c}`)}),t.load.start(),t.load.once("complete",()=>{console.log(`Load complete for: ${c}`)}),t.textures.exists(c)?t.textures.get(c):(console.log(`Failed to load texture: ${c}`),null)}}function rt(o){return function(t,n,s){const i=o.getData(n);if(!i)return console.log(`No PSD data found for key: ${n}`),null;const a=s.split("/"),r=Y(i.original.layers,a);if(!r)return console.log(`Layer not found: ${s}`),null;if(!E(r))return console.log(`Layer "${s}" does not have a mask`),null;const l=`${r.name}_mask`;if(!t.textures.exists(l)){const d=`${i.basePath}/${r.maskPath}`;return t.load.image(l,d),t.load.once(`filecomplete-image-${l}`,()=>{o.isDebugEnabled("console")&&console.log(`ðŸŽ­ Loaded mask on-demand: ${l}`)}),t.load.start(),console.log(`Mask texture "${l}" is being loaded. Call getMask again after load completes.`),null}const c=t.add.image(r.x,r.y,l);c.setOrigin(0,0),c.setVisible(!1);const f=c.createBitmapMask();return{maskImage:c,bitmapMask:f}}}function lt(o,e,t={}){const n=e.scene;let s=!1,i=!1,a=new Phaser.Math.Vector2,r=new Phaser.Math.Vector2,l=new Phaser.Math.Vector2;const f={...{easeDragging:!1,friction:.95,minSpeed:.1,ignore:[]},...t};function d(){f.useBounds&&(typeof f.useBounds=="object"?(console.log("using custom size"),e.setBounds(f.useBounds.x,f.useBounds.y,f.useBounds.width,f.useBounds.height)):console.warn("useBounds object must have {x, y, width, height} format"))}function h(p){const $=[];let k=p;for(;k;)k.name&&$.unshift(k.name),k=k.parentContainer||null;return $.join("/")}function x(p){if(!f.ignore||f.ignore.length===0)return!1;const $=h(p),k=p.name||"";for(const M of f.ignore)if(k===M||$===M||$.endsWith("/"+M)||$.startsWith(M+"/")||$===M||$.includes("/"+M+"/"))return!0;return!1}function w(p){if(!f.ignore||f.ignore.length===0)return!1;const $=n.input.hitTestPointer(p);for(const k of $)if(x(k))return!0;return!1}function v(p){i||w(p)||(s=!0,l.copy(p),a.copy(p),r.reset(),n.events.emit("draggableStart",e))}function m(p){if(!s)return;const $=p.x-a.x,k=p.y-a.y;e.scrollX-=$/e.zoom,e.scrollY-=k/e.zoom,r.set(-$,-k),a.copy(p),n.events.emit("draggableActive",e)}function S(){s=!1,f.easeDragging||r.reset(),n.events.emit("draggableComplete",e)}function _(){!s&&f.easeDragging&&(r.length()>f.minSpeed?(e.scrollX+=r.x/e.zoom,e.scrollY+=r.y/e.zoom,r.scale(f.friction),n.events.emit("draggableActive",e)):r.reset())}function P(){n.input.on("pointerdown",v),n.input.on("pointermove",m),n.input.on("pointerup",S),n.events.on("update",_)}return P(),d(),{isDragging:()=>s,isPaused:()=>i,getVelocity:()=>r.clone(),setOptions:p=>{Object.assign(f,p),d(),f.easeDragging||r.reset()},pause:()=>{i=!0,s&&(s=!1,r.reset(),n.events.emit("draggableComplete",e))},resume:()=>{i=!1}}}function ct(o,e,t={}){var I;const n=e.scene,s=t.targetKeys||ft(o);if(s.length===0)return console.warn("No PSDs found for lazy loading"),{};const i=[];if(s.forEach(u=>{const y=o.getData(u);if(y&&y.lazyLoad&&(y.lazyLoad.sprites&&y.lazyLoad.sprites.forEach(L=>{i.push({...L,_psdKey:u})}),y.lazyLoad.tiles)){const L=y.original.tile_slice_size??150;y.lazyLoad.tiles.forEach(g=>{M(g,L).forEach(b=>{i.push({...b,_psdKey:u})})})}}),i.length===0)return(I=t.debug)!=null&&I.console&&console.log("No lazy load items found in target PSDs:",s),{};let a,r=null,l=[],c=new Set,f=null,d=null;function h(){var u,y;t.createBoundaryCamera&&x(),w(),v(),((u=t.debug)!=null&&u.shape||(y=t.debug)!=null&&y.label)&&m(),_(),G()}function x(){d=n.cameras.add(),d.setVisible(!1),d.setZoom(1),d.setScroll(e.scrollX,e.scrollY),d.setSize(e.width,e.height)}function w(){const u=t.extendPreloadBounds||0;if(d){d.setScroll(e.scrollX,e.scrollY);const y=e.width/e.zoom,L=e.height/e.zoom,g=e.scrollX+e.width/2,b=e.scrollY+e.height/2;a=new Phaser.Geom.Rectangle(g-y/2-u,b-L/2-u,y+u*2,L+u*2)}else{const y=e.width/e.zoom,L=e.height/e.zoom;a=new Phaser.Geom.Rectangle(e.scrollX-u,e.scrollY-u,y+u*2,L+u*2)}}function v(){var y,L;const u=g=>{const b=n.add.rectangle(g.x,g.y,g.width,g.height);return b.setOrigin(0,0),b.setStrokeStyle(1,65280),b.setDepth(1e3),{boundary:b,data:{...g,loaded:!1}}};l=i.map(u),(y=t.debug)!=null&&y.shape?l.forEach(g=>g.boundary.setVisible(!0)):l.forEach(g=>g.boundary.setVisible(!1)),(L=t.debug)!=null&&L.label&&l.forEach(g=>{const b=n.add.text(g.boundary.x,g.boundary.y-20,g.data.name,{fontSize:"12px",color:"#00ffff",backgroundColor:"#000000"});b.setOrigin(0,1),b.setDepth(1001)})}function m(){r=n.add.graphics(),r.setDepth(1e3),S()}function S(){r&&(r.clear(),r.lineStyle(2,16711935,1),r.strokeRect(a.x,a.y,a.width,a.height))}function _(){var y;const u=l.filter(({boundary:L,data:g})=>!g.loaded&&!c.has(P(g))&&Phaser.Geom.Intersects.RectangleToRectangle(L.getBounds(),a));u.length>0&&((y=t.debug)!=null&&y.console&&console.log(`LazyLoad: ${u.length} objects to load`),n.events.emit("lazyLoadStart",u.length),u.forEach(p))}function P(u){if(!u)return"unknown";const y=u.category||u.type;return y==="tile"||y==="tileset"?`tile_${u.tilesetName||u.name}_${u.col}_${u.row}`:`sprite_${u.name}_${Math.round(u.x)}_${Math.round(u.y)}`}function p({data:u}){var b;const y=P(u);c.add(y);const L=u._psdKey;(b=t.debug)!=null&&b.console&&console.log(`LazyLoad: Loading object ${y} from PSD ${L}`);const g={sprites:u.category==="sprite"?[u]:[],tiles:[],groups:[],singleTiles:u.category==="tile"||u.category==="tileset"?[u]:[]};q(n,L,g,o),n.load.once("complete",()=>{$(u)}),n.load.start()}function $(u){var b,C,T;const y=P(u);if(c.delete(y),u.loaded=!0,(b=t.debug)!=null&&b.console&&console.log(`LazyLoad: Object loaded ${y}`),u.category==="sprite"){const A=n.add.group();ie(n,u,o,A,()=>{A.getChildren().forEach(X=>{X.setDepth&&u.initialDepth!==void 0&&X.setDepth(u.initialDepth)}),n.children.sort("depth")},u._psdKey)}else if(u.category==="tile"||u.category==="tileset"){const A=k(n,u);se(n,{x:u.x-A.x,y:u.y-A.y,key:`${u.tilesetName}_tile_${u.col}_${u.row}`,initialDepth:u.initialDepth,tilesetName:u.tilesetName,col:u.col,row:u.row},A)}const L=l.filter(({data:A})=>A.loaded).length/l.length,g=Array.from(c);n.events.emit("lazyLoadProgress",L,g),(C=t.debug)!=null&&C.console&&console.log(`LazyLoad: Progress ${L.toFixed(2)}, Remaining:`,g),l.every(({data:A})=>A.loaded)&&(n.events.emit("lazyLoadingComplete"),(T=t.debug)!=null&&T.console&&console.log("LazyLoad: All objects loaded")),S()}function k(u,y){const L=u.children.list.find(T=>T instanceof Phaser.GameObjects.Container&&T.name===y.tilesetName);if(L)return L;const g=y.x-y.col*y.tile_slice_size,b=y.y-y.row*y.tile_slice_size,C=u.add.container(g,b);return C.setName(y.tilesetName),C.setDepth(y.initialDepth),C}function M(u,y){const L=[];for(let g=0;g<u.columns;g++)for(let b=0;b<u.rows;b++)L.push({category:"tile",name:`${u.name}_tile_${g}_${b}`,x:u.x+g*y,y:u.y+b*y,width:y,height:y,tile_slice_size:y,filetype:u.filetype||"png",tilesetName:u.name,col:g,row:b,initialDepth:u.initialDepth});return L}function G(){const u=t.checkInterval||300;f=window.setInterval(()=>{j()},u)}function j(){var u,y;w(),_(),((u=t.debug)!=null&&u.shape||(y=t.debug)!=null&&y.label)&&S()}return h(),{update:j,destroy:()=>{f!==null&&(window.clearInterval(f),f=null),l.forEach(u=>u.boundary.destroy()),r&&r.destroy(),d&&(n.cameras.remove(d),d=null)}}}function ft(o){return o.getAllKeys()}function ut(o,e,t,n={}){const s=e;if(t.includes("draggable")&&Object.assign(s,lt(o,e,n.draggable)),t.includes("lazyLoad")){const i=typeof n.lazyLoad=="boolean"?{}:n.lazyLoad??{};Object.assign(s,ct(o,e,i))}return s}function dt(o){return function(e){let t,n;if(Array.isArray(e))if(e.length===2)typeof e[1]=="function"?(t={normal:e[0]},n={click:e[1]}):(t=e[0],n=e[1]);else if(e.length===3)t={normal:e[0],hover:e[1]},n={click:e[2]};else{console.error("Button: Invalid array format");return}else{console.error("Button: Invalid input format");return}if(!t.normal){console.error("Button requires at least a normal image");return}let s=t.normal,i=t.normal;if(i instanceof Phaser.GameObjects.Group){const m=i.getChildren();if(m.length===0){console.error("Button target group is empty");return}s=m[0]}else if(i instanceof Phaser.GameObjects.Container){if(i.list.length===0){console.error("Button target container is empty");return}s=i.list[0]}const a=s.scene;if(!a){console.error("Button target must have a valid scene");return}if(typeof s.setInteractive!="function"){console.error("Button target does not support interaction:",s.constructor.name);return}let r="normal";const l=s;let c,f,d,h;if(typeof l.getBounds=="function"){const m=l.getBounds();c=m.centerX||m.x+m.width/2,f=m.centerY||m.y+m.height/2,d=m.width,h=m.height}else c=l.x||0,f=l.y||0,d=l.width||l.displayWidth||100,h=l.height||l.displayHeight||100;const x=a.add.rectangle(c,f,d,h,0,0);x.setInteractive(),x.setDepth(Number.MAX_SAFE_INTEGER),x.setVisible(!0),t.normal&&t.normal.setVisible(!0),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);function w(m){t.normal&&t.normal.setVisible(!1),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);const S=t[m];S?S.setVisible(!0):t.normal&&t.normal.setVisible(!0),r=m}const v=a.sys.game.device.input.touch;return x.on("pointerdown",(m,S,_,P)=>{t.active&&w("active"),n.mousePress&&n.mousePress(i,{localX:S,localY:_,event:P},m)}),x.on("pointerup",(m,S,_,P)=>{var p;t.active&&(!v&&t.hover&&((p=x.input)!=null&&p.isOver)?w("hover"):w("normal")),n.click&&n.click(i,{localX:S,localY:_,event:P},m)}),!v&&t.hover&&(x.on("pointerover",(m,S,_,P)=>{w("hover"),n.mouseOver&&n.mouseOver(i,{localX:S,localY:_,event:P},m)}),x.on("pointerout",(m,S)=>{r!=="active"&&(w("normal"),n.mouseOut&&n.mouseOut(i,{event:S},m))})),r="normal",{destroy:()=>{x.off("pointerover"),x.off("pointerout"),x.off("pointerdown"),x.off("pointerup"),x.destroy()},getCurrentState:()=>r,showState:m=>{w(m)}}}}function ht(o){return function(e,t,n={}){const s=e.scene;if(!s){console.error("Unable to determine scene for fillZone");return}const i=e.getData("points");if(!i||i.length===0){console.error("Zone does not have valid points data");return}const a=new Phaser.Geom.Polygon(i),r=Phaser.Geom.Polygon.GetAABB(a);let l,c;if(t instanceof Phaser.GameObjects.Group){const _=t.getChildren()[0];if(!_){console.error("Group is empty");return}l=_.texture.key,c=n.useFrames||[_.frame.name]}else l=t.texture.key,c=n.useFrames||[t.frame.name];const f=s.textures.get(l);if(!f){console.error(`Texture not found: ${l}`);return}if(!c||c.length===0){const _=f.getFrameNames();_.length>0?c=_:c=Array.from({length:f.frameTotal},(P,p)=>p)}const d=s.add.group(),h=n.minInstances!==void 0?n.minInstances:5,x=n.maxInstances!==void 0?n.maxInstances:10,w=Phaser.Math.Between(h,x);let v=0,m=w*10,S=0;for(;v<w&&S<m;){const _=Phaser.Math.Between(r.left,r.right),P=Phaser.Math.Between(r.top,r.bottom);if(Phaser.Geom.Polygon.Contains(a,_,P)){const p=Phaser.Math.RND.pick(c),$=s.add.sprite(_,P,l,p);if(n.scaleRange){const k=Phaser.Math.FloatBetween(n.scaleRange[0],n.scaleRange[1]);$.setScale(k)}if(n.tint&&n.tint.length>0){const k=Phaser.Math.RND.pick(n.tint);$.setTint(k)}d.add($),v++}S++}return console.log(`fillZone completed. Sprites placed: ${v}, Target: ${w}, Attempts: ${S}`),d}}function gt(o){return function(e,t,n,s={}){const i=t.scene,a=s.bounceBack||!1,r=s.joystickRadius||50;e.setOrigin(.5,.5),e.setPosition(e.x+e.width/2,e.y+e.height/2);const l={x:e.x,y:e.y},c=t.getData("points"),f=c?new Phaser.Geom.Polygon(c):t.getBounds();let d=null;const h=(P,p)=>{const $=de(f),k=new Phaser.Math.Vector2(P-$.x,p-$.y);k.length()>r&&k.setLength(r);const G={x:$.x+k.x,y:$.y+k.y};return c?Phaser.Geom.Polygon.Contains(f,G.x,G.y)?G:mt(f,G.x,G.y):{x:Phaser.Math.Clamp(G.x,f.left,f.right),y:Phaser.Math.Clamp(G.y,f.top,f.bottom)}},x=(P,p)=>{const $=de(f);return{x:(P-$.x)/r,y:(p-$.y)/r}},w=(P,p)=>P.x>=p.left&&P.x<=p.right&&P.y>=p.top&&P.y<=p.bottom,v=P=>{d===null&&w(P,e.getBounds())&&(d=P,i.events.emit("joystickStart",{[n]:{isActive:!0,position:{x:e.x,y:e.y},change:{x:0,y:0},normalized:{x:0,y:0}}}))},m=P=>{if(P===d){const{x:p,y:$}=h(P.x,P.y);e.setPosition(p,$);const k={x:p-l.x,y:$-l.y},M=x(p,$);i.events.emit("joystickActive",{[n]:{isActive:!0,position:{x:p,y:$},change:k,normalized:M}})}},S=P=>{P===d&&(d=null,a?i.tweens.add({targets:e,x:l.x,y:l.y,duration:300,ease:"Bounce.out",onComplete:()=>{i.events.emit("joystickRelease",{[n]:{isActive:!1,position:l,change:{x:0,y:0},normalized:{x:0,y:0}}})}}):i.events.emit("joystickRelease",{[n]:{isActive:!1,position:{x:e.x,y:e.y},change:{x:e.x-l.x,y:e.y-l.y},normalized:x(e.x,e.y)}}))};i.input.on("pointerdown",v),i.input.on("pointermove",m),i.input.on("pointerup",S),i.input.on("pointerupoutside",S);function _(){i.input.off("pointerdown",v),i.input.off("pointermove",m),i.input.off("pointerup",S),i.input.off("pointerupoutside",S)}return{control:(P,p)=>{let $=new Phaser.Math.Vector2,k=0;const M=new Phaser.Math.Vector2(P.x,P.y),G=new Phaser.Math.Vector2(l.x,l.y),j=(g,b)=>{if(!p.directionLock)return[g,b];if(p.directionLock===4)return Math.abs(g)>Math.abs(b)?[g,0]:[0,b];if(p.directionLock===8){const C=Math.atan2(b,g),A=Math.round(8*C/(2*Math.PI)+8)%8*Math.PI/4;return[Math.cos(A),Math.sin(A)]}return[g,b]},I=(g,b,C)=>{switch([g,b]=j(g,b),p.type){case"speed":const T=p.maxSpeed||300;P.x+=g*T*C/1e3,P.y+=b*T*C/1e3;break;case"velocity":const A=P.body;if(A){const V=p.force||1;A.setVelocity(g*V*60,b*V*60)}break;case"unit":const X=i.time.now,$t=p.repeatRate||0,he=p.pixels||100,ge=.2;if((Math.abs(g)>ge||Math.abs(b)>ge)&&(k===0||X-k>=$t)){const V=Math.atan2(b,g);P.x+=Math.round(Math.cos(V)*he),P.y+=Math.round(Math.sin(V)*he),k=X}break;case"tracked":const me=p.multiplier||1,vt=(g-G.x)*me,wt=(b-G.y)*me;P.setPosition(M.x+vt,M.y+wt);break}},u=g=>{if(g[n])if(p.type==="tracked"){const b=g[n].position;I(b.x,b.y,0)}else $.set(g[n].normalized.x,g[n].normalized.y),k===0&&I($.x,$.y,0)},y=g=>{if(g[n])if($.reset(),k=0,p.type==="velocity"){const b=P.body;b&&b.setVelocity(0,0)}else p.type==="tracked"&&s.bounceBack&&P.setPosition(M.x,M.y)},L=(g,b)=>{p.type!=="tracked"&&($.x!==0||$.y!==0)&&I($.x,$.y,b)};return i.events.on("joystickActive",u),i.events.on("joystickRelease",y),i.events.on("update",L),{destroy:()=>{_(),i.events.off("joystickActive",u),i.events.off("joystickRelease",y),i.events.off("update",L)}}},destroy:_}}}function mt(o,e,t){let n=new Phaser.Geom.Point,s=Number.MAX_VALUE;for(let i=0;i<o.points.length;i++){const a=o.points[i],r=o.points[(i+1)%o.points.length],l=pt(a,r,e,t),c=Phaser.Math.Distance.Between(e,t,l.x,l.y);c<s&&(s=c,n=l)}return n}function pt(o,e,t,n){const s=e.x-o.x,i=e.y-o.y,a=((t-o.x)*s+(n-o.y)*i)/(s*s+i*i),r=Phaser.Math.Clamp(a,0,1);return new Phaser.Geom.Point(o.x+r*s,o.y+r*i)}function de(o){let e=0,t=0;for(const n of o.points)e+=n.x,t+=n.y;return new Phaser.Geom.Point(e/o.points.length,t/o.points.length)}function yt(o){return function(e,t,n={}){const s=e.scene,a={...{targetPositionY:"center",targetPositionX:"center",targetOffset:[0,0],speed:300,easing:!0},...n};let r,l,c=0,f=0;switch(Array.isArray(t)?[r,l]=t:(r=t.x,l=t.y,c=t.width||0,f=t.height||0),r+=c/2,l+=f/2,a.targetPositionX){case"left":r+=e.width/2;break;case"right":r-=e.width/2;break}switch(a.targetPositionY){case"top":l+=e.height/2;break;case"bottom":l-=e.height/2;break}r+=a.targetOffset[0],l+=a.targetOffset[1];const d=r-e.width/2,h=l-e.height/2,x=d-e.scrollX,w=a.speed;let v=Phaser.Math.Easing.Linear;a.easing===!0?v=Phaser.Math.Easing.Cubic.InOut:typeof a.easing=="function"&&(v=a.easing),s.events.emit("panToStart"),s.tweens.add({targets:e,scrollX:d,scrollY:h,duration:w,ease:v,onUpdate:()=>{const m=1-(e.scrollX-d)/x;s.events.emit("panToProgress",m)},onComplete:()=>{s.events.emit("panToComplete")}})}}function bt(o){return function(e){const{camera:t,target:n,scrollFactor:s=.25}=e;if(!n){console.warn('[P2P parallax] No valid "target" was provided.');return}let i,a;if(typeof t=="string"){if(a=n.scene,!a){console.warn(`[P2P parallax] Could not resolve scene from target for camera "${t}".`);return}i=a.cameras.getCamera(t),i||(i=a.cameras.main)}else if(t instanceof Phaser.Cameras.Scene2D.Camera)i=t,a=i.scene;else{if(a=n.scene,!a){console.warn("[P2P parallax] Could not find scene from target to use a default camera.");return}i=a.cameras.main}if(!i){console.warn("[P2P parallax] Could not resolve a valid camera.");return}if(!a){console.warn("[P2P parallax] Could not resolve a valid scene.");return}const r=a.sys;r._parallaxItems||(r._parallaxItems=[],a.events.on("update",()=>{const l=r._parallaxItems||[];for(const c of l)c.target.x=c.initX+c.camera.scrollX*c.factor,c.target.y=c.initY+c.camera.scrollY*c.factor})),r._parallaxItems.push({target:n,camera:i,factor:s,initX:n.x,initY:n.y})}}function xt(o){return{button:dt(),fillZone:ht(),joystick:gt(),panTo:yt(),parallax:bt()}}class Pt extends z.Plugins.BasePlugin{constructor(t){super(t);N(this,"psdData",{});N(this,"options");N(this,"load");N(this,"place");N(this,"getTexture");N(this,"getMask");N(this,"use");N(this,"createCamera");this.options={},console.log("%câœ¨ PSD-to-Phaser v0.0.5 âœ¨","background: black; color: white; padding: 1px 3px; border-radius: 2px;"),this.load=Ge(this),this.place=it(this),this.getTexture=at(this),this.getMask=rt(this),this.use=xt(),this.createCamera=(n,s,i)=>ut(this,n,s,i)}init(t={}){this.options={debug:!1,applyAlphaAll:!1,applyBlendModesAll:!1,...t},typeof this.options.debug=="boolean"&&(this.options.debug=this.options.debug?{shape:!0,label:!0,console:!0}:!1),this.options.debug&&console.log("PsdToPhaserPlugin initialized with options:",this.options)}setData(t,n){this.psdData[t]=n,this.isDebugEnabled("console")&&console.log(`Data set for key "${t}":`,n)}getData(t){return this.psdData[t]}getAllKeys(){return Object.keys(this.psdData)}isDebugEnabled(t){return typeof this.options.debug=="object"&&!!this.options.debug[t]}}return Pt}));
