(function(E,z){typeof exports=="object"&&typeof module<"u"?module.exports=z(require("phaser")):typeof define=="function"&&define.amd?define(["phaser"],z):(E=typeof globalThis<"u"?globalThis:E||self,E.PsdToPhaserPlugin=z(E.Phaser))})(this,(function(E){"use strict";function z(o){return o.category==="sprite"}function J(o){return o.category==="tileset"}function W(o){return o.category==="zone"}function j(o){return o.category==="point"}function F(o){return o.category==="group"&&Array.isArray(o.children)}function G(o){return o.mask===!0&&typeof o.maskPath=="string"}function Pe(o,e,t,n,s){return new Promise(i=>{let a=e.length;e.forEach(r=>{const l=r.name,c=`${t}/${r.filePath}`,f=()=>{a--,n(),a===0&&i()};G(r)&&V(o,r.name,t,r.maskPath,n,s),r.type==="atlas"?$e(o,l,c,r,f,s):r.type==="spritesheet"||r.type==="animation"?ve(o,l,c,r,f,s):we(o,l,c,f,s)}),a===0&&i()})}function V(o,e,t,n,s,i){const a=`${e}_mask`,r=`${t}/${n}`;o.textures.exists(a)?(s(),i&&console.log(`Mask already loaded: ${a}`)):(o.load.image(a,r),o.load.once(`filecomplete-image-${a}`,()=>{i&&console.log(`ðŸŽ­ Loaded mask: ${a} from ${r}`),s()}))}function $e(o,e,t,n,s,i){console.log(`[${Date.now()}] Starting loadAtlas for key: ${e}`);const a={frames:{}};Object.entries(n.frames).forEach(([l,c])=>{a.frames[l]={frame:{x:c.x,y:c.y,w:c.width,h:c.height},rotated:!1,trimmed:!1,sourceSize:{w:c.width,h:c.height},spriteSourceSize:{x:0,y:0,w:c.width,h:c.height}}}),o.load.atlas(e,t,a);const r=()=>{o.textures.exists(e)?(i&&console.log(`ðŸ—ºï¸ Loaded atlas: ${e} from ${t}`),o.load.off("complete",r),s()):setTimeout(r,100)};o.load.on("complete",r),o.load.on("loaderror",l=>{console.error("Error loading file: ",l),o.load.off("complete",r)})}function ve(o,e,t,n,s,i){o.load.spritesheet(e,t,{frameWidth:n.frame_width,frameHeight:n.frame_height}),o.load.once(`filecomplete-spritesheet-${e}`,()=>{i&&console.log(`ðŸ’¥ Loaded spritesheet: ${e} from ${t}`);for(let a=0;a<(n.frame_count??1);a++)s()})}function we(o,e,t,n,s){o.load.image(e,t),o.load.once(`filecomplete-image-${e}`,()=>{s&&console.log(`ðŸŽ‘ Loaded image: ${e} from ${t}`),n()})}function Z(o,e,t,n,s,i){const a=`${e.tilesetName}_tile_${e.col}_${e.row}`,r=`${t}/tiles/${e.tilesetName}/${n}/${a}.${e.filetype??"png"}`;!o.textures.exists(a)&&!o.textures.getTextureKeys().includes(a)&&!o.load.textureManager.exists(a)?(o.load.image(a,r),o.load.once(`filecomplete-image-${a}`,()=>{s(),i&&console.log(`ðŸ§© Loaded tile: ${a} from ${r}`)}),o.load.start()):(s(),i&&console.log(`Tile already loaded or loading: ${a}`))}function ke(o,e,t,n,s,i,a){e.forEach(r=>{for(let l=0;l<r.columns;l++)for(let c=0;c<r.rows;c++){const f={tilesetName:r.name,col:l,row:c,filetype:r.filetype},d=`${r.name}_tile_${l}_${c}`;a.push(d),Z(o,f,t,n,()=>{const h=a.indexOf(d);h>-1&&a.splice(h,1),s()},i)}})}function H(o,e,t,n){const s=n.getData(e);if(!s||!s.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const i=s.basePath,a=s.original.tile_slice_size??150,r=Me(t),l=r.tiles+r.sprites+r.singleTiles+r.atlases+r.masks;let c=0;const f=[];n.isDebugEnabled("console")&&(console.log(`Total assets to load: ${l}`),console.log(`Tiles to load: ${r.tiles}`),console.log(`Sprites to load: ${r.sprites}`),console.log(`Single tiles to load: ${r.singleTiles}`),console.log(`Atlases to load: ${r.atlases}`),console.log(`Masks to load: ${r.masks}`),console.log(`Tile slice size: ${a}`));const d=()=>{c++;const h=c/l;o.events.emit("psdLoadProgress",h),n.isDebugEnabled("console")&&console.log(`â³ Progress: ${c} of ${l} ( ${(h*100).toFixed(2)}% )`),c===l&&(o.events.emit("psdLoadComplete"),n.isDebugEnabled("console")&&console.log("All PSD assets loaded"))};t.tiles&&t.tiles.length>0&&ke(o,t.tiles,i,a,d,n.isDebugEnabled("console"),f),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(h=>{Z(o,h,i,a,d,n.isDebugEnabled("console"))}),t.sprites&&t.sprites.length>0&&Pe(o,t.sprites,i,d,n.isDebugEnabled("console")),t.tiles&&t.tiles.length>0&&t.tiles.forEach(h=>{!h.lazyLoad&&G(h)&&V(o,h.name,i,h.maskPath,d,n.isDebugEnabled("console"))}),t.groups&&t.groups.length>0&&t.groups.forEach(h=>{G(h)&&V(o,h.name,i,h.maskPath,d,n.isDebugEnabled("console"))}),o.load.isLoading()||o.load.start()}function Me(o){let e=0,t=0,n=0,s=0,i=0;o.tiles&&o.tiles.forEach(r=>{r.lazyLoad||(e+=r.columns*r.rows,G(r)&&i++)}),o.singleTiles&&(n=o.singleTiles.length);const a=r=>{r.forEach(l=>{l.lazyLoad||(l.type==="atlas"?s++:l.type==="spritesheet"?t+=l.frame_count??1:t++,G(l)&&i++)})};return o.sprites&&a(o.sprites),o.groups&&o.groups.forEach(r=>{G(r)&&i++}),{tiles:e,sprites:t,singleTiles:n,atlases:s,masks:i}}function Se(o,e,t,n,s,i){if(!t||!Array.isArray(t.layers)){console.error(`Invalid or missing layers data for key: ${e}`);return}const a={original:JSON.parse(JSON.stringify(t)),basePath:n,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};U(t.layers,a,!1,i?.lazyLoad),s.setData(e,a),s.isDebugEnabled("console")&&console.log(`Processed JSON for key "${e}":`,a),H(o,e,a.initialLoad,s)}function U(o,e,t,n){o.forEach(s=>{let i=t||s.attributes?.lazyLoad===!0;n!==void 0&&(n===!0||Array.isArray(n)&&n.includes(s.name))&&(i=!0);const a=i?e.lazyLoad:e.initialLoad;J(s)?a.tiles.push(s):z(s)?a.sprites.push(s):W(s)?a.zones.push(s):j(s)?a.points.push(s):F(s)&&(a.groups.push(s),U(s.children,e,i,n))})}function Le(o){return function(e,t){if(!Array.isArray(t)||t.length===0){console.error("loadMultiple requires an array of PSD configurations");return}let n=0;const s=t.map(i=>new Promise((a,r)=>{const l=`${i.path}/data.json`,c=`${i.key}_temp_json`;e.load.json(c,l),e.load.once(`filecomplete-json-${c}`,(f,d,h)=>{if(h){const b=Ae(h,i.lazyLoad);n+=b,i._tempData=h,a()}else console.error(`Failed to load JSON for key: ${i.key}`),r(new Error(`Failed to load JSON for key: ${i.key}`))}),e.load.once("loaderror",f=>{f.key===c&&(console.error(`Failed to load JSON file: ${l}`),r(new Error(`Failed to load JSON file: ${l}`)))})}));e.load.isLoading()||e.load.start(),Promise.all(s).then(()=>{t.forEach(r=>{const l=r._tempData,c=_e(l,r.position),f={original:JSON.parse(JSON.stringify(c)),basePath:r.path,positionOffset:r.position,isMultiplePsd:!0,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};Q(c.layers,f,!1,r.lazyLoad),o.setData(r.key,f),o.isDebugEnabled("console")&&console.log(`Processed multi-PSD data for key "${r.key}":`,f)});let i=0;const a=()=>{i++;const r=i/n;e.events.emit("psdLoadProgress",r),o.isDebugEnabled("console")&&console.log(`â³ Multi-PSD Progress: ${i} of ${n} (${(r*100).toFixed(2)}%)`),i===n&&(e.events.emit("psdLoadComplete"),o.isDebugEnabled("console")&&console.log("All multi-PSD assets loaded"))};t.forEach(r=>{const l=o.getData(r.key);l&&De(e,r.key,l.initialLoad,o,a)}),e.load.isLoading()||e.load.start()}).catch(i=>{console.error("Failed to load multiple PSDs:",i)})}}function _e(o,e){const t=JSON.parse(JSON.stringify(o));function n(s){s.forEach(i=>{i.x+=e.x,i.y+=e.y,i.instances&&Array.isArray(i.instances)&&i.instances.forEach(a=>{a.x+=e.x,a.y+=e.y}),i.children&&Array.isArray(i.children)&&n(i.children)})}return t.layers&&Array.isArray(t.layers)&&n(t.layers),t}function Ae(o,e){let t=0;function n(s,i=!1){s.forEach(a=>{let r=i||a.lazyLoad===!0;if(e!==void 0&&(e===!0||Array.isArray(e)&&e.includes(a.name))&&(r=!0),!r)switch(a.category){case"tileset":t+=(a.columns||1)*(a.rows||1);break;case"sprite":a.type==="atlas"?t++:a.type==="spritesheet"?t+=a.frame_count||1:t++;break}a.children&&Array.isArray(a.children)&&n(a.children,r)})}return o.layers&&Array.isArray(o.layers)&&n(o.layers),t}function De(o,e,t,n,s){const i=n.getData(e);if(!i||!i.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const a=i.basePath,r=i.original.tile_slice_size||150;t.tiles&&t.tiles.length>0&&Te(o,t.tiles,a,r,s,n.isDebugEnabled("console"),[],e),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(l=>{q(o,l,a,r,s,n.isDebugEnabled("console"),e)}),t.sprites&&t.sprites.length>0&&Ge(o,t.sprites,a,s,n.isDebugEnabled("console"),e)}function Ge(o,e,t,n,s,i){e.forEach(a=>{const r=a.name,l=`${i}_${r}`,c=`${t}/${a.filePath}`,f=()=>{n()};a.type==="atlas"?ze(o,r,l,c,a,f,s):a.type==="spritesheet"||a.type==="animation"?Ce(o,r,l,c,a,f,s):Ee(o,r,l,c,f,s)})}function ze(o,e,t,n,s,i,a){const r={frames:{}};Object.entries(s.frames).forEach(([c,f])=>{r.frames[c]={frame:{x:f.x,y:f.y,w:f.width,h:f.height},rotated:!1,trimmed:!1,sourceSize:{w:f.width,h:f.height},spriteSourceSize:{x:0,y:0,w:f.width,h:f.height}}}),o.load.atlas(t,n,r);const l=()=>{o.textures.exists(t)?(a&&console.log(`ðŸ—ºï¸ Loaded atlas: ${t} from ${n}`),o.load.off("complete",l),i()):setTimeout(l,100)};o.load.on("complete",l)}function Ce(o,e,t,n,s,i,a){o.load.spritesheet(t,n,{frameWidth:s.frame_width,frameHeight:s.frame_height}),o.load.once(`filecomplete-spritesheet-${t}`,()=>{a&&console.log(`ðŸ’¥ Loaded spritesheet: ${t} from ${n}`);for(let r=0;r<(s.frame_count||1);r++)i()})}function Ee(o,e,t,n,s,i){o.load.image(t,n),o.load.once(`filecomplete-image-${t}`,()=>{i&&console.log(`ðŸŽ‘ Loaded image: ${t} from ${n}`),s()})}function Te(o,e,t,n,s,i,a,r){e.forEach(l=>{for(let c=0;c<l.columns;c++)for(let f=0;f<l.rows;f++){const d=`${l.name}_tile_${c}_${f}`,h=`${r}_${d}`;a.push(h);const b={tilesetName:l.name,col:c,row:f,filetype:l.filetype};q(o,b,t,n,()=>{const k=a.indexOf(h);k>-1&&a.splice(k,1),s()},i,r)}})}function q(o,e,t,n,s,i,a){const r=`${e.tilesetName}_tile_${e.col}_${e.row}`,l=`${a}_${r}`,c=`${t}/tiles/${e.tilesetName}/${n}/${r}.${e.filetype||"png"}`;o.textures.exists(l)?(s(),i&&console.log(`Tile already loaded: ${l}`)):(o.load.image(l,c),o.load.once(`filecomplete-image-${l}`,()=>{s(),i&&console.log(`ðŸ§© Loaded tile: ${l} from ${c}`)}))}function Q(o,e,t,n){o.forEach(s=>{let i=t||s.lazyLoad===!0;n!==void 0&&(n===!0||Array.isArray(n)&&n.includes(s.name))&&(i=!0);const a=i?e.lazyLoad:e.initialLoad;switch(s.category){case"tileset":a.tiles.push(s);break;case"sprite":a.sprites.push(s);break;case"zone":a.zones.push(s);break;case"point":a.points.push(s);break;case"group":a.groups.push(s),Array.isArray(s.children)&&Q(s.children,e,i,n);break}})}function Ne(o){return{load(e,t,n,s){const i=`${n}/data.json`;e.load.json(t,i),e.load.once(`filecomplete-json-${t}`,(a,r,l)=>{l?Se(e,t,l,n,o,s):console.error(`Loaded JSON is empty or invalid for key: ${t}`)}),e.load.once("loaderror",a=>{a.key===t&&console.error(`Failed to load JSON file: ${i}`)}),e.load.isLoading()||e.load.start()},loadMultiple:Le(o)}}function ee(o,e,t){const n=o.getData(e);if(!n||!n.lazyLoad)return!1;const i={sprite:"sprites",tileset:"tiles",zone:"zones",point:"points",group:"groups"}[t.category];if(!i)return!1;const a=n.lazyLoad[i];return a?a.some(r=>r.name===t.name):!1}function Y(o,e,t){const n=o.add.container(e.x,e.y);if(t.isDebugEnabled("shape")){const s=o.add.graphics();s.lineStyle(2,16711935,1),s.strokeRect(0,0,e.width,e.height),n.add(s)}if(t.isDebugEnabled("label")){const s=o.add.text(0,-20,`${e.name} (Lazy)`,{fontSize:"16px",color:"#ff00ff",backgroundColor:"#ffffff"});n.add(s)}return n}function T(o,e){o.attributes&&(e.attributes=o.attributes)}function Ie(o,e,t){if(!G(e))return null;const n=`${e.name}_mask`;if(!o.textures.exists(n))return console.warn(`Mask texture not found: ${n}`),null;const s=o.add.image(e.x,e.y,n);s.setOrigin(0,0),s.setVisible(!1);const i=s.createBitmapMask();return t.setMask&&t.setMask(i),s}function Be(o,e,t){if(!G(e))return null;const n=`${e.name}_mask`;if(!o.textures.exists(n))return console.warn(`Mask texture not found: ${n}`),null;const s=o.add.image(e.x,e.y,n);s.setOrigin(0,0),s.setVisible(!1);const i=s.createBitmapMask();return t.setMask(i),s}function te(o,e,t){if(!G(e))return null;const n=`${e.name}_mask`,s=`${e.name}_mask_alpha`;if(!o.textures.exists(n))return console.warn(`Mask texture not found: ${n}`),null;let i=s;o.textures.exists(s)||Oe(o,n,s)||(i=n,console.warn("Failed to convert mask luminance to alpha, using original texture"));const a=o.add.image(e.x,e.y,i);a.setOrigin(0,0),a.setVisible(!1);const r=a.createBitmapMask(),l=t.getChildren();return console.log(`ðŸŽ­ Applying mask "${n}" to ${l.length} children at position (${e.x}, ${e.y})`),l.forEach((c,f)=>{"setMask"in c&&typeof c.setMask=="function"&&(c.setMask(r),console.log(`  - Applied mask to child ${f}: ${c.name||"unnamed"}`))}),a}function Oe(o,e,t){try{const s=o.textures.get(e).getSourceImage();if(!s||!s.width||!s.height)return!1;const i=document.createElement("canvas");i.width=s.width,i.height=s.height;const a=i.getContext("2d");if(!a)return!1;a.drawImage(s,0,0);const r=a.getImageData(0,0,i.width,i.height),l=r.data;for(let c=0;c<l.length;c+=4){const f=l[c],d=l[c+1],h=l[c+2],b=(f+d+h)/3;l[c]=255,l[c+1]=255,l[c+2]=255,l[c+3]=b}return a.putImageData(r,0,0),o.textures.addCanvas(t,i),console.log(`ðŸŽ­ Converted mask "${e}" luminance to alpha â†’ "${t}"`),!0}catch(n){return console.error("Failed to convert mask luminance to alpha:",n),!1}}const Re={sprite:65280,tileset:16711680,zone:255,point:16711680,group:16776960},oe=1e3;function B(o,e,t,n){const s={shape:null,label:null},i=Re[n.type],a=`#${i.toString(16).padStart(6,"0")}`;return e.isDebugEnabled("shape")&&(s.shape=Xe(o,n,i),s.shape&&(s.shape.setDepth(oe),s.shape.isDebugObject=!0,t.add(s.shape))),e.isDebugEnabled("label")&&(s.label=Fe(o,n,a),s.label&&(s.label.setDepth(oe),s.label.isDebugObject=!0,t.add(s.label))),s}function Xe(o,e,t){switch(e.type){case"point":const n=o.add.circle(e.x,e.y,5,t);return n.setStrokeStyle(2,t),n;case"zone":if(e.zoneShape){const s=o.add.graphics();return s.lineStyle(2,t,1),e.zoneShape instanceof Phaser.Geom.Polygon?s.strokePoints(e.zoneShape.points,!0):s.strokeRect(e.zoneShape.x,e.zoneShape.y,e.zoneShape.width,e.zoneShape.height),s}return null;default:if(e.width!==void 0&&e.height!==void 0){const s=o.add.graphics();return s.lineStyle(2,t,1),s.strokeRect(e.x,e.y,e.width,e.height),s}return null}}function Fe(o,e,t){const n={fontSize:"16px",color:t,backgroundColor:"#ffffff"};let s=e.x,i=e.y-20,a=0,r=0;switch(e.type){case"point":a=.5,r=1;break;case"zone":if(e.zoneShape){if(e.zoneShape instanceof Phaser.Geom.Polygon){const c=Phaser.Geom.Polygon.GetAABB(e.zoneShape);s=c.centerX,i=c.centerY}else s=e.zoneShape.centerX,i=e.zoneShape.centerY;a=.5,r=.5}break}const l=o.add.text(s,i,e.name,n);return l.setOrigin(a,r),l}function Ve(o,e,t,n,s,i,a){const r=o.add.container(e.x,e.y);if(r.setName(e.name),r.setData("tileData",e),r.setData("tileSliceSize",n),r.setData("psdKey",a),r.setDepth(e.initialDepth??0),T(e,r),["setX","setY","setPosition","setBlendMode","setAlpha","setDepth","setMask"].forEach(d=>{Ke(r,d)}),ee(t,a,e)){const d=Y(o,e,t);d&&r.add(d)}else{const h=t.getData(a)?.isMultiplePsd||!1;Ye(o,r,e,n,h,a)}Be(o,e,r),s.add(r);const f=o.add.group();B(o,t,f,{type:"tileset",name:e.name,x:e.x,y:e.y,width:e.columns*n,height:e.rows*n}),s.debugGroup=f}function Ye(o,e,t,n,s=!1,i){for(let a=0;a<t.columns;a++)for(let r=0;r<t.rows;r++){const l=a*n,c=r*n,d=`${s&&i?`${i}_${t.name}`:t.name}_tile_${a}_${r}`,h=ne(o,{x:l,y:c,key:d,initialDepth:t.initialDepth},e);h&&e.add(h)}}function Ke(o,e){const t=Phaser.GameObjects.Container.prototype[e];o[e]=function(...n){const s=t.apply(this,n);if(["setX","setY","setPosition"].includes(e)){const a=e==="setX"||e==="setPosition"?n[0]-this.x:0,r=e==="setY"?n[0]-this.y:e==="setPosition"?n[1]-this.y:0;this.each(l=>{a!==0&&(l.x+=a),r!==0&&(l.y+=r)})}else this.each(a=>{typeof a[e]=="function"&&a[e](...n)});const i=this.getData("pendingMethodCalls")||[];return i.push({method:e,args:n}),this.setData("pendingMethodCalls",i),s}}function ne(o,e,t){if(o.textures.exists(e.key)){const n=o.add.image(e.x,e.y,e.key);return n.setOrigin(0,0),(t instanceof Phaser.GameObjects.Group||t instanceof Phaser.GameObjects.Container)&&t.add(n),n}else return console.warn(`Texture not found for tile: ${e.key}`),null}function se(o,e,t){t.setName(e.name),t.setOrigin(0,0),t.setDepth(e.initialDepth??0),T(e,t),Ie(o,e,t)}function ie(o,e){e.name=o.name,e.setDepth(o.initialDepth??0),T(o,e)}function ae(o,e,t){e.mask&&e.maskPath&&te(o,e,t)}function O(o,e){return e||o.name}function re(o,e,t){o.setName(e),o.setOrigin(0,0),o.setDepth(t)}function Je(o,e,t,n,s){const i=O(e,s),a=o.add.sprite(e.x,e.y,i);return se(o,e,a),e.frame!==void 0&&a.setFrame(e.frame),a}function We(o,e,t,n,s){const i=o.add.group(),a=O(e,s);if(o.textures.exists(a)){const l=o.textures.get(a).getFrameNames(),c=Object.keys(e.frames).reduce((f,d,h)=>(f[d]=h,f),{});e.instances&&e.instances.forEach(f=>{const{name:d,x:h,y:b}=f,k=c[d];if(k!==void 0&&k<l.length){const v=l[k],x=o.add.sprite(h,b,a,v);re(x,d,e.initialDepth??0),i.add(x),t.isDebugEnabled("console")&&console.log(`Placed spritesheet instance: ${d}, at (${h}, ${b}), using frame: ${v}`)}else console.warn(`Frame for "${d}" not found in spritesheet "${a}"`)})}else console.error(`Texture "${a}" not found. Make sure the spritesheet is loaded correctly.`);return ie(e,i),ae(o,e,i),i}function je(o,e,t,n,s){const i=o.add.group(),a=O(e,s);if(o.textures.exists(a)){const l=o.textures.get(a).getFrameNames();e.instances&&e.instances.forEach(c=>{const{name:f,x:d,y:h}=c;if(l.includes(f)){const b=o.add.sprite(d,h,a,f);re(b,f,e.initialDepth??0),i.add(b)}else console.warn(`Frame "${f}" not found in atlas "${a}"`)})}else console.error(`Texture "${a}" not found. Make sure the atlas is loaded correctly.`);return ie(e,i),ae(o,e,i),i}function Ze(o,e,t,n,s,i){const a=O(e,s),r=o.add.sprite(e.x,e.y,a,0);if(se(o,e,r),e.frame_width&&e.frame_height){const l={key:a,frames:o.anims.generateFrameNumbers(a,{start:0,end:e.frame_count?e.frame_count-1:-1}),frameRate:e.attributes?.frameRate||24,repeat:e.attributes?.repeat!==void 0?e.attributes.repeat:-1};e.attributes?.yoyo!==void 0&&(l.yoyo=e.attributes.yoyo),e.attributes?.delay!==void 0&&(l.delay=e.attributes.delay),e.attributes?.repeatDelay!==void 0&&(l.repeatDelay=e.attributes.repeatDelay),e.attributes?.duration!==void 0&&(l.duration=e.attributes.duration),e.attributes?.showOnStart!==void 0&&(l.showOnStart=e.attributes.showOnStart),e.attributes?.hideOnComplete!==void 0&&(l.hideOnComplete=e.attributes.hideOnComplete),i&&(Object.assign(l,i),l.key=a,i.frames||(l.frames=o.anims.generateFrameNumbers(a,{start:0,end:e.frame_count?e.frame_count-1:-1}))),o.anims.exists(a)||o.anims.create(l),r.play(a)}return r}function le(o,e,t,n,s,i,a){if(e.lazyLoad){const c=Y(o,e,t);c&&n.add(c),s();return}const l=t.getData(i)?.isMultiplePsd?`${i}_${e.name}`:e.name;if(o.textures.exists(l)){let c=null;switch(e.type){case"spritesheet":c=We(o,e,t,i,l);break;case"atlas":c=je(o,e,t,i,l);break;case"animation":c=Ze(o,e,t,i,l,a);break;default:c=Je(o,e,t,i,l);break}if(c){c instanceof Phaser.GameObjects.Group?c.getChildren().forEach(d=>{n.add(d)}):n.add(c),e.alpha!==void 0&&c.setAlpha(e.alpha),e.hidden!==void 0&&c.setVisible(!1),c.setDepth(e.initialDepth||0);const f=o.add.group();B(o,t,f,{type:"sprite",name:e.name,x:e.x,y:e.y,width:e.width,height:e.height}),n.debugGroup=f}else console.error(`Failed to place sprite: ${e.name}`)}else console.warn(`Texture not found for sprite: ${e.name} (looking for texture key: ${l})`);s()}function He(o,e,t,n,s,i){const a=Ue(o,e);if(a){n.add(a);const r=o.add.group(),l=ce(e);B(o,t,r,{type:"zone",name:e.name,x:e.x,y:e.y,zoneShape:l}),n.debugGroup=r}}function Ue(o,e){const t=ce(e);let n,s;if(t instanceof Phaser.Geom.Polygon){const i=Phaser.Geom.Polygon.GetAABB(t);n=o.add.zone(i.x,i.y,i.width,i.height),s=t.points}else n=o.add.zone(t.x,t.y,t.width,t.height),s=[new Phaser.Geom.Point(t.x,t.y),new Phaser.Geom.Point(t.x+t.width,t.y),new Phaser.Geom.Point(t.x+t.width,t.y+t.height),new Phaser.Geom.Point(t.x,t.y+t.height)];return n.setName(e.name||"unnamed_zone"),T(e,n),n.setData("points",s),n.setData("category",e.category),n.setData("x",e.x),n.setData("y",e.y),n.setData("width",e.width),n.setData("height",e.height),e.initialDepth!==void 0&&n.setData("initialDepth",e.initialDepth),e.attributes&&n.setData("attributes",e.attributes),n}function ce(o){if(o.subpaths&&Array.isArray(o.subpaths)&&o.subpaths.length>0&&Array.isArray(o.subpaths[0])){const e=o.subpaths[0].flatMap(t=>new Phaser.Geom.Point(t[0],t[1]));return new Phaser.Geom.Polygon(e)}else if(o.bbox&&typeof o.bbox=="object"){const{left:e,top:t,right:n,bottom:s}=o.bbox;if(typeof e=="number"&&typeof t=="number"&&typeof n=="number"&&typeof s=="number")return new Phaser.Geom.Rectangle(e,t,n-e,s-t)}return console.error("Unable to create zone shape. Invalid zone data:",o),new Phaser.Geom.Rectangle(0,0,1,1)}function qe(o,e,t,n,s,i){const a=Qe(o,e);if(a){n.add(a);const r=o.add.group();B(o,t,r,{type:"point",name:e.name,x:e.x,y:e.y}),n.debugGroup=r}}function Qe(o,e){const t=o.add.container(e.x,e.y);return t.setData("pointData",e),t.setName(e.name),T(e,t),t}const fe=["setAlpha","setAngle","setActive","setAlpha","setBlendMode","setDepth","setDisplaySize","setFlip","setMask","setOrigin","setPipeline","setPosition","setRotation","setScale","setScrollFactor","setSize","setTint","setVisible","setX","setY","setZ"];function et(o,e){e instanceof Phaser.GameObjects.Group?tt(o,e):ot(o,e)}function tt(o,e){fe.forEach(t=>{e[t]=nt(o,t)})}function ot(o,e){fe.forEach(t=>{t==="remove"&&(e[t]=(n={})=>{e.removedFromScene()})})}function nt(o,e){return function(...t){const n=typeof t[t.length-1]=="object"&&!Array.isArray(t[t.length-1])?t.pop():{},s=n.depth!==void 0?n.depth:1/0;ue(this,e,t,s,0)}}function ue(o,e,t,n,s){s>n||(o instanceof Phaser.GameObjects.Group?s<n&&o.getChildren().forEach(a=>{ue(a,e,t,n,s+1)}):typeof o[e]=="function"&&o[e](...t))}function st(o){return function(t,n={}){let s,i=1/0;typeof t=="string"?(s=t,i=n.depth!==void 0?n.depth:1/0):typeof t=="object"&&(i=t.depth!==void 0?t.depth:1/0);let a=!1;const r=(c,f=0)=>{if(!(f>=i)){if(c instanceof Phaser.GameObjects.Group&&(c.getChildren().forEach(d=>r(d,f+1)),f===i)){c.clear(),a=!0;return}"parentContainer"in c&&c.parentContainer?c.parentContainer.remove(c):c.scene&&c.scene.children.remove(c),typeof c.destroy=="function"&&c.destroy(!0),a=!0}},l=(c,f)=>{if(f.length===0)return r(c),!0;if(c instanceof Phaser.GameObjects.Group){const d=f[0],h=c.getChildren().find(b=>b.name===d);if(h)return l(h,f.slice(1))}return!1};if(s){const c=s.split("/");a=l(this,c)}else r(this);return a||console.warn(`Object not found or already removed: ${s||"root"}`),a}}function it(o,e){e.remove=st()}function at(o,e){e instanceof Phaser.GameObjects.Group?lt(o,e):e instanceof Phaser.GameObjects.Sprite&&rt(o,e)}function rt(o,e){e.updateAnimation=function(t){return de(e,t)}}function lt(o,e){e.updateAnimation=function(t){function n(s){s instanceof Phaser.GameObjects.Sprite&&s.anims&&s.anims.currentAnim?de(s,t):s instanceof Phaser.GameObjects.Group&&s.getChildren().forEach(n)}return n(e),e}}function de(o,e){const t=o.anims.currentAnim?.key;if(!t)return console.warn("No animation currently playing on sprite"),o;const n=o.scene,s=n.anims.get(t);if(!s)return console.warn(`Animation ${t} not found`),o;const i={key:t,frames:s.frames.map(a=>({key:a.textureKey,frame:a.textureFrame})),frameRate:s.frameRate,duration:s.duration,repeat:s.repeat,repeatDelay:s.repeatDelay,yoyo:s.yoyo,showOnStart:s.showOnStart,hideOnComplete:s.hideOnComplete,...e};return i.key=t,n.anims.remove(t),n.anims.create(i),o.play(t),o}function ct(o){return function(t,n={}){if(!t)return this;const s=t.split("/"),i=n.depth!==void 0?n.depth:1/0;function a(l,c,f){if(f>i||c.length===0)return null;const[d,...h]=c;let b;if(l instanceof Phaser.GameObjects.Group)b=l.getChildren();else if(l instanceof Phaser.GameObjects.Container)b=l.list;else return null;const k=b.filter(v=>!v.isDebugObject);for(const v of k)if(v.name===d){if(h.length===0)return v;if(v instanceof Phaser.GameObjects.Group||v instanceof Phaser.GameObjects.Container)return a(v,h,f+1)}for(const v of k)if(v instanceof Phaser.GameObjects.Group||v instanceof Phaser.GameObjects.Container){const x=a(v,c,f+1);if(x)return x}return null}let r=null;return this instanceof Phaser.GameObjects.Group||this instanceof Phaser.GameObjects.Container?r=a(this,s,0):r=this.name===s[0]?this:null,r?he(o,r):console.warn(`Item not found at path: ${t}`),r}}function ft(o,e){e.target=ct(o)}function he(o,e){et(o,e),it(o,e),at(o,e),ft(o,e)}function R(o,e){if(e.length===0)return null;const[t,...n]=e,s=o.find(i=>i.name===t);return s?n.length===0?s:F(s)?R(s.children,n):null:null}function ut(o){return function(t,n,s,i={}){const a=o.getData(n);if(!a||!a.original)return console.error(`No data found for key: ${n}`),t.add.group();const r=a.original.tile_slice_size||150,l=t.add.group(),c=R(a.original.layers,s.split("/"));if(!c)return console.error(`No layer found with path: ${s}`),l;const f=ge(t,c,o,r,l,n,i);return he(o,f),t.events.emit("layerPlaced",s),f}}function ge(o,e,t,n,s,i,a){if(F(e)){if(a.depth===void 0||a.depth>0){const l=o.add.group();return l.name=e.name,e.children.forEach(c=>{const f=ge(o,c,t,n,l,i,{...a,depth:a.depth!==void 0?a.depth-1:void 0});f instanceof Phaser.GameObjects.GameObject&&l.add(f)}),G(e)&&te(o,e,l),s.add(l),l}return s}if(ee(t,i,e)){const l=Y(o,e,t);return l&&s.add(l),s}return J(e)?(Ve(o,e,t,n,s,()=>{},i),s):z(e)?(le(o,e,t,s,()=>{},i,a.animationOptions),s):W(e)?(He(o,e,t,s),s):j(e)?(qe(o,e,t,s),s):(console.error(`Unknown layer category: ${e.category}`),s)}function dt(o){return function(t,n,s){const i=o.getData(n);if(!i)return console.log(`No PSD data found for key: ${n}`),null;const a=s.split("/"),r=R(i.original.layers,a);if(!r)return console.log(`Sprite not found: ${s}`),console.log(`Available sprites: ${JSON.stringify(i.original.layers.map(d=>d.name))}`),null;if(!z(r))return console.log(`Layer "${s}" is not a sprite layer`),null;const c=i.isMultiplePsd||!1?`${n}_${r.name}`:r.name;if(t.textures.exists(c))return t.textures.get(c);const f=`${i.basePath}/${r.filePath}`;return t.load.image(c,f),t.load.once(`filecomplete-image-${c}`,()=>{console.log(`Texture loaded: ${c}`)}),t.load.start(),t.load.once("complete",()=>{console.log(`Load complete for: ${c}`)}),t.textures.exists(c)?t.textures.get(c):(console.log(`Failed to load texture: ${c}`),null)}}function ht(o){return function(t,n,s){const i=o.getData(n);if(!i)return console.log(`No PSD data found for key: ${n}`),null;const a=s.split("/"),r=R(i.original.layers,a);if(!r)return console.log(`Layer not found: ${s}`),null;if(!G(r))return console.log(`Layer "${s}" does not have a mask`),null;const l=`${r.name}_mask`;if(!t.textures.exists(l)){const d=`${i.basePath}/${r.maskPath}`;return t.load.image(l,d),t.load.once(`filecomplete-image-${l}`,()=>{o.isDebugEnabled("console")&&console.log(`ðŸŽ­ Loaded mask on-demand: ${l}`)}),t.load.start(),console.log(`Mask texture "${l}" is being loaded. Call getMask again after load completes.`),null}const c=t.add.image(r.x,r.y,l);c.setOrigin(0,0),c.setVisible(!1);const f=c.createBitmapMask();return{maskImage:c,bitmapMask:f}}}function gt(o,e,t={}){const n=e.scene;let s=!1,i=!1,a=new Phaser.Math.Vector2,r=new Phaser.Math.Vector2,l=new Phaser.Math.Vector2;const f={...{easeDragging:!1,friction:.95,minSpeed:.1,ignore:[]},...t};function d(){f.useBounds&&(typeof f.useBounds=="object"?(console.log("using custom size"),e.setBounds(f.useBounds.x,f.useBounds.y,f.useBounds.width,f.useBounds.height)):console.warn("useBounds object must have {x, y, width, height} format"))}function h(m){const P=[];let w=m;for(;w;)w.name&&P.unshift(w.name),w=w.parentContainer||null;return P.join("/")}function b(m){if(!f.ignore||f.ignore.length===0)return!1;const P=h(m),w=m.name||"";for(const A of f.ignore)if(w===A||P===A||P.endsWith("/"+A)||P.startsWith(A+"/")||P===A||P.includes("/"+A+"/"))return!0;return!1}function k(m){if(!f.ignore||f.ignore.length===0)return!1;const P=n.input.hitTestPointer(m);for(const w of P)if(b(w))return!0;return!1}function v(m){i||k(m)||(s=!0,l.copy(m),a.copy(m),r.reset(),n.events.emit("draggableStart",e))}function x(m){if(!s)return;const P=m.x-a.x,w=m.y-a.y;e.scrollX-=P/e.zoom,e.scrollY-=w/e.zoom,r.set(-P,-w),a.copy(m),n.events.emit("draggableActive",e)}function S(){s=!1,f.easeDragging||r.reset(),n.events.emit("draggableComplete",e)}function L(){!s&&f.easeDragging&&(r.length()>f.minSpeed?(e.scrollX+=r.x/e.zoom,e.scrollY+=r.y/e.zoom,r.scale(f.friction),n.events.emit("draggableActive",e)):r.reset())}function p(){n.input.on("pointerdown",v),n.input.on("pointermove",x),n.input.on("pointerup",S),n.events.on("update",L)}return p(),d(),{isDragging:()=>s,isPaused:()=>i,getVelocity:()=>r.clone(),setOptions:m=>{Object.assign(f,m),d(),f.easeDragging||r.reset()},pause:()=>{i=!0,s&&(s=!1,r.reset(),n.events.emit("draggableComplete",e))},resume:()=>{i=!1}}}function mt(o,e,t={}){const n=e.scene,s=t.targetKeys||pt(o);if(s.length===0)return console.warn("No PSDs found for lazy loading"),{};const i=[];if(s.forEach(u=>{const g=o.getData(u);if(g&&g.lazyLoad&&(g.lazyLoad.sprites&&g.lazyLoad.sprites.forEach($=>{i.push({...$,_psdKey:u})}),g.lazyLoad.tiles)){const $=g.original.tile_slice_size??150;g.lazyLoad.tiles.forEach(_=>{A(_,$).forEach(y=>{i.push({...y,_psdKey:u})})})}}),i.length===0)return t.debug?.console&&console.log("No lazy load items found in target PSDs:",s),{};let a,r=null,l=[],c=new Set,f=null,d=null;function h(){t.createBoundaryCamera&&b(),k(),v(),(t.debug?.shape||t.debug?.label)&&x(),L(),D()}function b(){d=n.cameras.add(),d.setVisible(!1),d.setZoom(1),d.setScroll(e.scrollX,e.scrollY),d.setSize(e.width,e.height)}function k(){const u=t.extendPreloadBounds||0;if(d){d.setScroll(e.scrollX,e.scrollY);const g=e.width/e.zoom,$=e.height/e.zoom,_=e.scrollX+e.width/2,y=e.scrollY+e.height/2;a=new Phaser.Geom.Rectangle(_-g/2-u,y-$/2-u,g+u*2,$+u*2)}else{const g=e.width/e.zoom,$=e.height/e.zoom;a=new Phaser.Geom.Rectangle(e.scrollX-u,e.scrollY-u,g+u*2,$+u*2)}}function v(){const u=g=>{const $=n.add.rectangle(g.x,g.y,g.width,g.height);return $.setOrigin(0,0),$.setStrokeStyle(1,65280),$.setDepth(1e3),{boundary:$,data:{...g,loaded:!1}}};l=i.map(u),t.debug?.shape?l.forEach(g=>g.boundary.setVisible(!0)):l.forEach(g=>g.boundary.setVisible(!1)),t.debug?.label&&l.forEach(g=>{const $=n.add.text(g.boundary.x,g.boundary.y-20,g.data.name,{fontSize:"12px",color:"#00ffff",backgroundColor:"#000000"});$.setOrigin(0,1),$.setDepth(1001)})}function x(){r=n.add.graphics(),r.setDepth(1e3),S()}function S(){r&&(r.clear(),r.lineStyle(2,16711935,1),r.strokeRect(a.x,a.y,a.width,a.height))}function L(){const u=l.filter(({boundary:g,data:$})=>!$.loaded&&!c.has(p($))&&Phaser.Geom.Intersects.RectangleToRectangle(g.getBounds(),a));u.length>0&&(t.debug?.console&&console.log(`LazyLoad: ${u.length} objects to load`),n.events.emit("lazyLoadStart",u.length),u.forEach(m))}function p(u){if(!u)return"unknown";const g=u.category||u.type;return g==="tile"||g==="tileset"?`tile_${u.tilesetName||u.name}_${u.col}_${u.row}`:`sprite_${u.name}_${Math.round(u.x)}_${Math.round(u.y)}`}function m({data:u}){const g=p(u);c.add(g);const $=u._psdKey;t.debug?.console&&console.log(`LazyLoad: Loading object ${g} from PSD ${$}`);const _={sprites:u.category==="sprite"?[u]:[],tiles:[],groups:[],singleTiles:u.category==="tile"||u.category==="tileset"?[u]:[]};H(n,$,_,o),n.load.once("complete",()=>{P(u)}),n.load.start()}function P(u){const g=p(u);if(c.delete(g),u.loaded=!0,t.debug?.console&&console.log(`LazyLoad: Object loaded ${g}`),u.category==="sprite"){const y=n.add.group();le(n,u,o,y,()=>{y.getChildren().forEach(M=>{M.setDepth&&u.initialDepth!==void 0&&M.setDepth(u.initialDepth)}),n.children.sort("depth")},u._psdKey)}else if(u.category==="tile"||u.category==="tileset"){const y=w(n,u);ne(n,{x:u.x-y.x,y:u.y-y.y,key:`${u.tilesetName}_tile_${u.col}_${u.row}`,initialDepth:u.initialDepth,tilesetName:u.tilesetName,col:u.col,row:u.row},y)}const $=l.filter(({data:y})=>y.loaded).length/l.length,_=Array.from(c);n.events.emit("lazyLoadProgress",$,_),t.debug?.console&&console.log(`LazyLoad: Progress ${$.toFixed(2)}, Remaining:`,_),l.every(({data:y})=>y.loaded)&&(n.events.emit("lazyLoadingComplete"),t.debug?.console&&console.log("LazyLoad: All objects loaded")),S()}function w(u,g){const $=u.children.list.find(C=>C instanceof Phaser.GameObjects.Container&&C.name===g.tilesetName);if($)return $;const _=g.x-g.col*g.tile_slice_size,y=g.y-g.row*g.tile_slice_size,M=u.add.container(_,y);return M.setName(g.tilesetName),M.setDepth(g.initialDepth),M}function A(u,g){const $=[];for(let _=0;_<u.columns;_++)for(let y=0;y<u.rows;y++)$.push({category:"tile",name:`${u.name}_tile_${_}_${y}`,x:u.x+_*g,y:u.y+y*g,width:g,height:g,tile_slice_size:g,filetype:u.filetype||"png",tilesetName:u.name,col:_,row:y,initialDepth:u.initialDepth});return $}function D(){const u=t.checkInterval||300;f=window.setInterval(()=>{X()},u)}function X(){k(),L(),(t.debug?.shape||t.debug?.label)&&S()}return h(),{update:X,destroy:()=>{f!==null&&(window.clearInterval(f),f=null),l.forEach(u=>u.boundary.destroy()),r&&r.destroy(),d&&(n.cameras.remove(d),d=null)}}}function pt(o){return o.getAllKeys()}function yt(o,e,t,n={}){const s=e;if(t.includes("draggable")&&Object.assign(s,gt(o,e,n.draggable)),t.includes("lazyLoad")){const i=typeof n.lazyLoad=="boolean"?{}:n.lazyLoad??{};Object.assign(s,mt(o,e,i))}return s}function bt(o){return function(e){let t,n;if(Array.isArray(e))if(e.length===2)typeof e[1]=="function"?(t={normal:e[0]},n={click:e[1]}):(t=e[0],n=e[1]);else if(e.length===3)t={normal:e[0],hover:e[1]},n={click:e[2]};else{console.error("Button: Invalid array format");return}else{console.error("Button: Invalid input format");return}if(!t.normal){console.error("Button requires at least a normal image");return}let s=t.normal,i=t.normal;if(i instanceof Phaser.GameObjects.Group){const x=i.getChildren();if(x.length===0){console.error("Button target group is empty");return}s=x[0]}else if(i instanceof Phaser.GameObjects.Container){if(i.list.length===0){console.error("Button target container is empty");return}s=i.list[0]}const a=s.scene;if(!a){console.error("Button target must have a valid scene");return}if(typeof s.setInteractive!="function"){console.error("Button target does not support interaction:",s.constructor.name);return}let r="normal";const l=s;let c,f,d,h;if(typeof l.getBounds=="function"){const x=l.getBounds();c=x.centerX||x.x+x.width/2,f=x.centerY||x.y+x.height/2,d=x.width,h=x.height}else c=l.x||0,f=l.y||0,d=l.width||l.displayWidth||100,h=l.height||l.displayHeight||100;const b=a.add.rectangle(c,f,d,h,0,0);b.setInteractive(),b.setDepth(Number.MAX_SAFE_INTEGER),b.setVisible(!0),t.normal&&t.normal.setVisible(!0),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);function k(x){t.normal&&t.normal.setVisible(!1),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);const S=t[x];S?S.setVisible(!0):t.normal&&t.normal.setVisible(!0),r=x}const v=a.sys.game.device.input.touch;return b.on("pointerdown",(x,S,L,p)=>{t.active&&k("active"),n.mousePress&&n.mousePress(i,{localX:S,localY:L,event:p},x)}),b.on("pointerup",(x,S,L,p)=>{t.active&&(!v&&t.hover&&b.input?.isOver?k("hover"):k("normal")),n.click&&n.click(i,{localX:S,localY:L,event:p},x)}),!v&&t.hover&&(b.on("pointerover",(x,S,L,p)=>{k("hover"),n.mouseOver&&n.mouseOver(i,{localX:S,localY:L,event:p},x)}),b.on("pointerout",(x,S)=>{r!=="active"&&(k("normal"),n.mouseOut&&n.mouseOut(i,{event:S},x))})),r="normal",{destroy:()=>{b.off("pointerover"),b.off("pointerout"),b.off("pointerdown"),b.off("pointerup"),b.destroy()},getCurrentState:()=>r,showState:x=>{k(x)}}}}function xt(o){return function(e,t,n={}){const s=e.scene;if(!s){console.error("Unable to determine scene for fillZone");return}const i=e.getData("points");if(!i||i.length===0){console.error("Zone does not have valid points data");return}const a=new Phaser.Geom.Polygon(i),r=Phaser.Geom.Polygon.GetAABB(a);let l,c;if(t instanceof Phaser.GameObjects.Group){const L=t.getChildren()[0];if(!L){console.error("Group is empty");return}l=L.texture.key,c=n.useFrames||[L.frame.name]}else l=t.texture.key,c=n.useFrames||[t.frame.name];const f=s.textures.get(l);if(!f){console.error(`Texture not found: ${l}`);return}if(!c||c.length===0){const L=f.getFrameNames();L.length>0?c=L:c=Array.from({length:f.frameTotal},(p,m)=>m)}const d=s.add.group(),h=n.minInstances!==void 0?n.minInstances:5,b=n.maxInstances!==void 0?n.maxInstances:10,k=Phaser.Math.Between(h,b);let v=0,x=k*10,S=0;for(;v<k&&S<x;){const L=Phaser.Math.Between(r.left,r.right),p=Phaser.Math.Between(r.top,r.bottom);if(Phaser.Geom.Polygon.Contains(a,L,p)){const m=Phaser.Math.RND.pick(c),P=s.add.sprite(L,p,l,m);if(n.scaleRange){const w=Phaser.Math.FloatBetween(n.scaleRange[0],n.scaleRange[1]);P.setScale(w)}if(n.tint&&n.tint.length>0){const w=Phaser.Math.RND.pick(n.tint);P.setTint(w)}d.add(P),v++}S++}return console.log(`fillZone completed. Sprites placed: ${v}, Target: ${k}, Attempts: ${S}`),d}}function Pt(o){return function(e,t,n,s={}){const i=t.scene,a=s.bounceBack||!1,r=s.joystickRadius||50;e.setOrigin(.5,.5),e.setPosition(e.x+e.width/2,e.y+e.height/2);const l={x:e.x,y:e.y},c=t.getData("points"),f=c?new Phaser.Geom.Polygon(c):t.getBounds();let d=null;const h=(p,m)=>{const P=me(f),w=new Phaser.Math.Vector2(p-P.x,m-P.y);w.length()>r&&w.setLength(r);const D={x:P.x+w.x,y:P.y+w.y};return c?Phaser.Geom.Polygon.Contains(f,D.x,D.y)?D:$t(f,D.x,D.y):{x:Phaser.Math.Clamp(D.x,f.left,f.right),y:Phaser.Math.Clamp(D.y,f.top,f.bottom)}},b=(p,m)=>{const P=me(f);return{x:(p-P.x)/r,y:(m-P.y)/r}},k=(p,m)=>p.x>=m.left&&p.x<=m.right&&p.y>=m.top&&p.y<=m.bottom,v=p=>{d===null&&k(p,e.getBounds())&&(d=p,i.events.emit("joystickStart",{[n]:{isActive:!0,position:{x:e.x,y:e.y},change:{x:0,y:0},normalized:{x:0,y:0}}}))},x=p=>{if(p===d){const{x:m,y:P}=h(p.x,p.y);e.setPosition(m,P);const w={x:m-l.x,y:P-l.y},A=b(m,P);i.events.emit("joystickActive",{[n]:{isActive:!0,position:{x:m,y:P},change:w,normalized:A}})}},S=p=>{p===d&&(d=null,a?i.tweens.add({targets:e,x:l.x,y:l.y,duration:300,ease:"Bounce.out",onComplete:()=>{i.events.emit("joystickRelease",{[n]:{isActive:!1,position:l,change:{x:0,y:0},normalized:{x:0,y:0}}})}}):i.events.emit("joystickRelease",{[n]:{isActive:!1,position:{x:e.x,y:e.y},change:{x:e.x-l.x,y:e.y-l.y},normalized:b(e.x,e.y)}}))};i.input.on("pointerdown",v),i.input.on("pointermove",x),i.input.on("pointerup",S),i.input.on("pointerupoutside",S);function L(){i.input.off("pointerdown",v),i.input.off("pointermove",x),i.input.off("pointerup",S),i.input.off("pointerupoutside",S)}return{control:(p,m)=>{let P=new Phaser.Math.Vector2,w=0;const A=new Phaser.Math.Vector2(p.x,p.y),D=new Phaser.Math.Vector2(l.x,l.y),X=(y,M)=>{if(!m.directionLock)return[y,M];if(m.directionLock===4)return Math.abs(y)>Math.abs(M)?[y,0]:[0,M];if(m.directionLock===8){const C=Math.atan2(M,y),N=Math.round(8*C/(2*Math.PI)+8)%8*Math.PI/4;return[Math.cos(N),Math.sin(N)]}return[y,M]},u=(y,M,C)=>{switch([y,M]=X(y,M),m.type){case"speed":const K=m.maxSpeed||300;p.x+=y*K*C/1e3,p.y+=M*K*C/1e3;break;case"velocity":const N=p.body;if(N){const I=m.force||1;N.setVelocity(y*I*60,M*I*60)}break;case"unit":const pe=i.time.now,Lt=m.repeatRate||0,ye=m.pixels||100,be=.2;if((Math.abs(y)>be||Math.abs(M)>be)&&(w===0||pe-w>=Lt)){const I=Math.atan2(M,y);p.x+=Math.round(Math.cos(I)*ye),p.y+=Math.round(Math.sin(I)*ye),w=pe}break;case"tracked":const xe=m.multiplier||1,_t=(y-D.x)*xe,At=(M-D.y)*xe;p.setPosition(A.x+_t,A.y+At);break}},g=y=>{if(y[n])if(m.type==="tracked"){const M=y[n].position;u(M.x,M.y,0)}else P.set(y[n].normalized.x,y[n].normalized.y),w===0&&u(P.x,P.y,0)},$=y=>{if(y[n])if(P.reset(),w=0,m.type==="velocity"){const M=p.body;M&&M.setVelocity(0,0)}else m.type==="tracked"&&s.bounceBack&&p.setPosition(A.x,A.y)},_=(y,M)=>{m.type!=="tracked"&&(P.x!==0||P.y!==0)&&u(P.x,P.y,M)};return i.events.on("joystickActive",g),i.events.on("joystickRelease",$),i.events.on("update",_),{destroy:()=>{L(),i.events.off("joystickActive",g),i.events.off("joystickRelease",$),i.events.off("update",_)}}},destroy:L}}}function $t(o,e,t){let n=new Phaser.Geom.Point,s=Number.MAX_VALUE;for(let i=0;i<o.points.length;i++){const a=o.points[i],r=o.points[(i+1)%o.points.length],l=vt(a,r,e,t),c=Phaser.Math.Distance.Between(e,t,l.x,l.y);c<s&&(s=c,n=l)}return n}function vt(o,e,t,n){const s=e.x-o.x,i=e.y-o.y,a=((t-o.x)*s+(n-o.y)*i)/(s*s+i*i),r=Phaser.Math.Clamp(a,0,1);return new Phaser.Geom.Point(o.x+r*s,o.y+r*i)}function me(o){let e=0,t=0;for(const n of o.points)e+=n.x,t+=n.y;return new Phaser.Geom.Point(e/o.points.length,t/o.points.length)}function wt(o){return function(e,t,n={}){const s=e.scene,a={...{targetPositionY:"center",targetPositionX:"center",targetOffset:[0,0],speed:300,easing:!0},...n};let r,l,c=0,f=0;switch(Array.isArray(t)?[r,l]=t:(r=t.x,l=t.y,c=t.width||0,f=t.height||0),r+=c/2,l+=f/2,a.targetPositionX){case"left":r+=e.width/2;break;case"right":r-=e.width/2;break}switch(a.targetPositionY){case"top":l+=e.height/2;break;case"bottom":l-=e.height/2;break}r+=a.targetOffset[0],l+=a.targetOffset[1];const d=r-e.width/2,h=l-e.height/2,b=d-e.scrollX,k=a.speed;let v=Phaser.Math.Easing.Linear;a.easing===!0?v=Phaser.Math.Easing.Cubic.InOut:typeof a.easing=="function"&&(v=a.easing),s.events.emit("panToStart"),s.tweens.add({targets:e,scrollX:d,scrollY:h,duration:k,ease:v,onUpdate:()=>{const x=1-(e.scrollX-d)/b;s.events.emit("panToProgress",x)},onComplete:()=>{s.events.emit("panToComplete")}})}}function kt(o){return function(e){const{camera:t,target:n,scrollFactor:s=.25}=e;if(!n){console.warn('[P2P parallax] No valid "target" was provided.');return}let i,a;if(typeof t=="string"){if(a=n.scene,!a){console.warn(`[P2P parallax] Could not resolve scene from target for camera "${t}".`);return}i=a.cameras.getCamera(t),i||(i=a.cameras.main)}else if(t instanceof Phaser.Cameras.Scene2D.Camera)i=t,a=i.scene;else{if(a=n.scene,!a){console.warn("[P2P parallax] Could not find scene from target to use a default camera.");return}i=a.cameras.main}if(!i){console.warn("[P2P parallax] Could not resolve a valid camera.");return}if(!a){console.warn("[P2P parallax] Could not resolve a valid scene.");return}const r=a.sys;r._parallaxItems||(r._parallaxItems=[],a.events.on("update",()=>{const l=r._parallaxItems||[];for(const c of l)c.target.x=c.initX+c.camera.scrollX*c.factor,c.target.y=c.initY+c.camera.scrollY*c.factor})),r._parallaxItems.push({target:n,camera:i,factor:s,initX:n.x,initY:n.y})}}function Mt(o){return{button:bt(),fillZone:xt(),joystick:Pt(),panTo:wt(),parallax:kt()}}class St extends E.Plugins.BasePlugin{psdData={};options;load;place;getTexture;getMask;use;createCamera;constructor(e){super(e),this.options={},console.log("%câœ¨ PSD-to-Phaser v0.0.6 âœ¨","background: black; color: white; padding: 1px 3px; border-radius: 2px;"),this.load=Ne(this),this.place=ut(this),this.getTexture=dt(this),this.getMask=ht(this),this.use=Mt(),this.createCamera=(t,n,s)=>yt(this,t,n,s)}init(e={}){this.options={debug:!1,applyAlphaAll:!1,applyBlendModesAll:!1,...e},typeof this.options.debug=="boolean"&&(this.options.debug=this.options.debug?{shape:!0,label:!0,console:!0}:!1),this.options.debug&&console.log("PsdToPhaserPlugin initialized with options:",this.options)}setData(e,t){this.psdData[e]=t,this.isDebugEnabled("console")&&console.log(`Data set for key "${e}":`,t)}getData(e){return this.psdData[e]}getAllKeys(){return Object.keys(this.psdData)}isDebugEnabled(e){return typeof this.options.debug=="object"&&!!this.options.debug[e]}}return St}));
