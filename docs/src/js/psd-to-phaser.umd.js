(function(E,G){typeof exports=="object"&&typeof module<"u"?module.exports=G(require("phaser")):typeof define=="function"&&define.amd?define(["phaser"],G):(E=typeof globalThis<"u"?globalThis:E||self,E.PsdToPhaserPlugin=G(E.Phaser))})(this,(function(E){"use strict";function G(o){return o.category==="sprite"}function W(o){return o.category==="tileset"}function j(o){return o.category==="zone"}function Z(o){return o.category==="point"}function V(o){return o.category==="group"&&Array.isArray(o.children)}function z(o){return o.mask===!0&&typeof o.maskPath=="string"}function Pe(o,e,t,n,s){return new Promise(i=>{let a=e.length;e.forEach(r=>{const l=r.name,c=`${t}/${r.filePath}`,f=()=>{a--,n(),a===0&&i()};z(r)&&F(o,r.name,t,r.maskPath,n,s),r.type==="atlas"?$e(o,l,c,r,f,s):r.type==="spritesheet"||r.type==="animation"?ve(o,l,c,r,f,s):we(o,l,c,f,s)}),a===0&&i()})}function F(o,e,t,n,s,i){const a=`${e}_mask`,r=`${t}/${n}`;o.textures.exists(a)?(s(),i&&console.log(`Mask already loaded: ${a}`)):(o.load.image(a,r),o.load.once(`filecomplete-image-${a}`,()=>{i&&console.log(`ðŸŽ­ Loaded mask: ${a} from ${r}`),s()}))}function $e(o,e,t,n,s,i){console.log(`[${Date.now()}] Starting loadAtlas for key: ${e}`);const a={frames:{}};Object.entries(n.frames).forEach(([l,c])=>{a.frames[l]={frame:{x:c.x,y:c.y,w:c.width,h:c.height},rotated:!1,trimmed:!1,sourceSize:{w:c.width,h:c.height},spriteSourceSize:{x:0,y:0,w:c.width,h:c.height}}}),o.load.atlas(e,t,a);const r=()=>{o.textures.exists(e)?(i&&console.log(`ðŸ—ºï¸ Loaded atlas: ${e} from ${t}`),o.load.off("complete",r),s()):setTimeout(r,100)};o.load.on("complete",r),o.load.on("loaderror",l=>{console.error("Error loading file: ",l),o.load.off("complete",r)})}function ve(o,e,t,n,s,i){o.load.spritesheet(e,t,{frameWidth:n.frame_width,frameHeight:n.frame_height}),o.load.once(`filecomplete-spritesheet-${e}`,()=>{i&&console.log(`ðŸ’¥ Loaded spritesheet: ${e} from ${t}`);for(let a=0;a<(n.frame_count??1);a++)s()})}function we(o,e,t,n,s){o.load.image(e,t),o.load.once(`filecomplete-image-${e}`,()=>{s&&console.log(`ðŸŽ‘ Loaded image: ${e} from ${t}`),n()})}function H(o,e,t,n,s,i){const a=`${e.tilesetName}_tile_${e.col}_${e.row}`,r=`${t}/tiles/${e.tilesetName}/${n}/${a}.${e.filetype??"png"}`;!o.textures.exists(a)&&!o.textures.getTextureKeys().includes(a)&&!o.load.textureManager.exists(a)?(o.load.image(a,r),o.load.once(`filecomplete-image-${a}`,()=>{s(),i&&console.log(`ðŸ§© Loaded tile: ${a} from ${r}`)}),o.load.start()):(s(),i&&console.log(`Tile already loaded or loading: ${a}`))}function ke(o,e,t,n,s,i,a){e.forEach(r=>{for(let l=0;l<r.columns;l++)for(let c=0;c<r.rows;c++){const f={tilesetName:r.name,col:l,row:c,filetype:r.filetype},d=`${r.name}_tile_${l}_${c}`;a.push(d),H(o,f,t,n,()=>{const g=a.indexOf(d);g>-1&&a.splice(g,1),s()},i)}})}function U(o,e,t,n){const s=n.getData(e);if(!s||!s.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const i=s.basePath,a=s.original.tile_slice_size??150,r=Se(t),l=r.tiles+r.sprites+r.singleTiles+r.atlases+r.masks;let c=0;const f=[];n.isDebugEnabled("console")&&(console.log(`Total assets to load: ${l}`),console.log(`Tiles to load: ${r.tiles}`),console.log(`Sprites to load: ${r.sprites}`),console.log(`Single tiles to load: ${r.singleTiles}`),console.log(`Atlases to load: ${r.atlases}`),console.log(`Masks to load: ${r.masks}`),console.log(`Tile slice size: ${a}`));const d=()=>{c++;const g=c/l;o.events.emit("psdLoadProgress",g),n.isDebugEnabled("console")&&console.log(`â³ Progress: ${c} of ${l} ( ${(g*100).toFixed(2)}% )`),c===l&&(o.events.emit("psdLoadComplete"),n.isDebugEnabled("console")&&console.log("All PSD assets loaded"))};t.tiles&&t.tiles.length>0&&ke(o,t.tiles,i,a,d,n.isDebugEnabled("console"),f),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(g=>{H(o,g,i,a,d,n.isDebugEnabled("console"))}),t.sprites&&t.sprites.length>0&&Pe(o,t.sprites,i,d,n.isDebugEnabled("console")),t.tiles&&t.tiles.length>0&&t.tiles.forEach(g=>{!g.lazyLoad&&z(g)&&F(o,g.name,i,g.maskPath,d,n.isDebugEnabled("console"))}),t.groups&&t.groups.length>0&&t.groups.forEach(g=>{z(g)&&F(o,g.name,i,g.maskPath,d,n.isDebugEnabled("console"))}),o.load.isLoading()||o.load.start()}function Se(o){let e=0,t=0,n=0,s=0,i=0;o.tiles&&o.tiles.forEach(r=>{r.lazyLoad||(e+=r.columns*r.rows,z(r)&&i++)}),o.singleTiles&&(n=o.singleTiles.length);const a=r=>{r.forEach(l=>{l.lazyLoad||(l.type==="atlas"?s++:l.type==="spritesheet"?t+=l.frame_count??1:t++,z(l)&&i++)})};return o.sprites&&a(o.sprites),o.groups&&o.groups.forEach(r=>{z(r)&&i++}),{tiles:e,sprites:t,singleTiles:n,atlases:s,masks:i}}function Le(o,e,t,n,s,i){if(!t||!Array.isArray(t.layers)){console.error(`Invalid or missing layers data for key: ${e}`);return}const a={original:JSON.parse(JSON.stringify(t)),basePath:n,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};q(t.layers,a,!1,i?.lazyLoad),s.setData(e,a),s.isDebugEnabled("console")&&console.log(`Processed JSON for key "${e}":`,a),U(o,e,a.initialLoad,s)}function q(o,e,t,n){o.forEach(s=>{let i=t||s.attributes?.lazyLoad===!0;n!==void 0&&(n===!0||Array.isArray(n)&&n.includes(s.name))&&(i=!0);const a=i?e.lazyLoad:e.initialLoad;W(s)?a.tiles.push(s):G(s)?a.sprites.push(s):j(s)?a.zones.push(s):Z(s)?a.points.push(s):V(s)&&(a.groups.push(s),q(s.children,e,i,n))})}function _e(o){return function(e,t){if(!Array.isArray(t)||t.length===0){console.error("loadMultiple requires an array of PSD configurations");return}let n=0;const s=t.map(i=>new Promise((a,r)=>{const l=`${i.path}/data.json`,c=`${i.key}_temp_json`;e.load.json(c,l),e.load.once(`filecomplete-json-${c}`,(f,d,g)=>{if(g){const P=Ae(g,i.lazyLoad);n+=P,i._tempData=g,a()}else console.error(`Failed to load JSON for key: ${i.key}`),r(new Error(`Failed to load JSON for key: ${i.key}`))}),e.load.once("loaderror",f=>{f.key===c&&(console.error(`Failed to load JSON file: ${l}`),r(new Error(`Failed to load JSON file: ${l}`)))})}));e.load.isLoading()||e.load.start(),Promise.all(s).then(()=>{t.forEach(r=>{const l=r._tempData,c=Me(l,r.position),f={original:JSON.parse(JSON.stringify(c)),basePath:r.path,positionOffset:r.position,isMultiplePsd:!0,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};ee(c.layers,f,!1,r.lazyLoad),o.setData(r.key,f),o.isDebugEnabled("console")&&console.log(`Processed multi-PSD data for key "${r.key}":`,f)});let i=0;const a=()=>{i++;const r=i/n;e.events.emit("psdLoadProgress",r),o.isDebugEnabled("console")&&console.log(`â³ Multi-PSD Progress: ${i} of ${n} (${(r*100).toFixed(2)}%)`),i===n&&(e.events.emit("psdLoadComplete"),o.isDebugEnabled("console")&&console.log("All multi-PSD assets loaded"))};t.forEach(r=>{const l=o.getData(r.key);l&&De(e,r.key,l.initialLoad,o,a)}),e.load.isLoading()||e.load.start()}).catch(i=>{console.error("Failed to load multiple PSDs:",i)})}}function Me(o,e){const t=JSON.parse(JSON.stringify(o));function n(s){s.forEach(i=>{i.x+=e.x,i.y+=e.y,i.instances&&Array.isArray(i.instances)&&i.instances.forEach(a=>{a.x+=e.x,a.y+=e.y}),i.children&&Array.isArray(i.children)&&n(i.children)})}return t.layers&&Array.isArray(t.layers)&&n(t.layers),t}function Ae(o,e){let t=0;function n(s,i=!1){s.forEach(a=>{let r=i||a.lazyLoad===!0;if(e!==void 0&&(e===!0||Array.isArray(e)&&e.includes(a.name))&&(r=!0),!r)switch(a.category){case"tileset":t+=(a.columns||1)*(a.rows||1);break;case"sprite":a.type==="atlas"?t++:a.type==="spritesheet"?t+=a.frame_count||1:t++;break}a.children&&Array.isArray(a.children)&&n(a.children,r)})}return o.layers&&Array.isArray(o.layers)&&n(o.layers),t}function De(o,e,t,n,s){const i=n.getData(e);if(!i||!i.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const a=i.basePath,r=i.original.tile_slice_size||150;t.tiles&&t.tiles.length>0&&Te(o,t.tiles,a,r,s,n.isDebugEnabled("console"),[],e),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(l=>{Q(o,l,a,r,s,n.isDebugEnabled("console"),e)}),t.sprites&&t.sprites.length>0&&ze(o,t.sprites,a,s,n.isDebugEnabled("console"),e)}function ze(o,e,t,n,s,i){e.forEach(a=>{const r=a.name,l=`${i}_${r}`,c=`${t}/${a.filePath}`,f=()=>{n()};a.type==="atlas"?Ge(o,r,l,c,a,f,s):a.type==="spritesheet"||a.type==="animation"?Ce(o,r,l,c,a,f,s):Ee(o,r,l,c,f,s)})}function Ge(o,e,t,n,s,i,a){const r={frames:{}};Object.entries(s.frames).forEach(([c,f])=>{r.frames[c]={frame:{x:f.x,y:f.y,w:f.width,h:f.height},rotated:!1,trimmed:!1,sourceSize:{w:f.width,h:f.height},spriteSourceSize:{x:0,y:0,w:f.width,h:f.height}}}),o.load.atlas(t,n,r);const l=()=>{o.textures.exists(t)?(a&&console.log(`ðŸ—ºï¸ Loaded atlas: ${t} from ${n}`),o.load.off("complete",l),i()):setTimeout(l,100)};o.load.on("complete",l)}function Ce(o,e,t,n,s,i,a){o.load.spritesheet(t,n,{frameWidth:s.frame_width,frameHeight:s.frame_height}),o.load.once(`filecomplete-spritesheet-${t}`,()=>{a&&console.log(`ðŸ’¥ Loaded spritesheet: ${t} from ${n}`);for(let r=0;r<(s.frame_count||1);r++)i()})}function Ee(o,e,t,n,s,i){o.load.image(t,n),o.load.once(`filecomplete-image-${t}`,()=>{i&&console.log(`ðŸŽ‘ Loaded image: ${t} from ${n}`),s()})}function Te(o,e,t,n,s,i,a,r){e.forEach(l=>{for(let c=0;c<l.columns;c++)for(let f=0;f<l.rows;f++){const d=`${l.name}_tile_${c}_${f}`,g=`${r}_${d}`;a.push(g);const P={tilesetName:l.name,col:c,row:f,filetype:l.filetype};Q(o,P,t,n,()=>{const k=a.indexOf(g);k>-1&&a.splice(k,1),s()},i,r)}})}function Q(o,e,t,n,s,i,a){const r=`${e.tilesetName}_tile_${e.col}_${e.row}`,l=`${a}_${r}`,c=`${t}/tiles/${e.tilesetName}/${n}/${r}.${e.filetype||"png"}`;o.textures.exists(l)?(s(),i&&console.log(`Tile already loaded: ${l}`)):(o.load.image(l,c),o.load.once(`filecomplete-image-${l}`,()=>{s(),i&&console.log(`ðŸ§© Loaded tile: ${l} from ${c}`)}))}function ee(o,e,t,n){o.forEach(s=>{let i=t||s.lazyLoad===!0;n!==void 0&&(n===!0||Array.isArray(n)&&n.includes(s.name))&&(i=!0);const a=i?e.lazyLoad:e.initialLoad;switch(s.category){case"tileset":a.tiles.push(s);break;case"sprite":a.sprites.push(s);break;case"zone":a.zones.push(s);break;case"point":a.points.push(s);break;case"group":a.groups.push(s),Array.isArray(s.children)&&ee(s.children,e,i,n);break}})}function Ne(o){return{load(e,t,n,s){const i=`${n}/data.json`;e.load.json(t,i),e.load.once(`filecomplete-json-${t}`,(a,r,l)=>{l?Le(e,t,l,n,o,s):console.error(`Loaded JSON is empty or invalid for key: ${t}`)}),e.load.once("loaderror",a=>{a.key===t&&console.error(`Failed to load JSON file: ${i}`)}),e.load.isLoading()||e.load.start()},loadMultiple:_e(o)}}function te(o,e,t){const n=o.getData(e);if(!n||!n.lazyLoad)return!1;const i={sprite:"sprites",tileset:"tiles",zone:"zones",point:"points",group:"groups"}[t.category];if(!i)return!1;const a=n.lazyLoad[i];return a?a.some(r=>r.name===t.name):!1}function Y(o,e,t){const n=o.add.container(e.x,e.y);if(t.isDebugEnabled("shape")){const s=o.add.graphics();s.lineStyle(2,16711935,1),s.strokeRect(0,0,e.width,e.height),n.add(s)}if(t.isDebugEnabled("label")){const s=o.add.text(0,-20,`${e.name} (Lazy)`,{fontSize:"16px",color:"#ff00ff",backgroundColor:"#ffffff"});n.add(s)}return n}function T(o,e){o.attributes&&(e.attributes=o.attributes)}function K(o,e,t){if(!z(e))return null;const n=`${e.name}_mask`;if(!o.textures.exists(n))return console.warn(`Mask texture not found: ${n}`),null;const s=o.add.image(e.x,e.y,n);s.setOrigin(0,0),s.setVisible(!1);const i=s.createBitmapMask();return t.setMask&&t.setMask(i),s}function Ie(o,e,t){if(!z(e))return null;const n=`${e.name}_mask`;if(!o.textures.exists(n))return console.warn(`Mask texture not found: ${n}`),null;const s=o.add.image(e.x,e.y,n);s.setOrigin(0,0),s.setVisible(!1);const i=s.createBitmapMask();return t.setMask(i),s}const Be={sprite:65280,tileset:16711680,zone:255,point:16711680,group:16776960},oe=1e3;function B(o,e,t,n){const s={shape:null,label:null},i=Be[n.type],a=`#${i.toString(16).padStart(6,"0")}`;return e.isDebugEnabled("shape")&&(s.shape=Oe(o,n,i),s.shape&&(s.shape.setDepth(oe),s.shape.isDebugObject=!0,t.add(s.shape))),e.isDebugEnabled("label")&&(s.label=Re(o,n,a),s.label&&(s.label.setDepth(oe),s.label.isDebugObject=!0,t.add(s.label))),s}function Oe(o,e,t){switch(e.type){case"point":const n=o.add.circle(e.x,e.y,5,t);return n.setStrokeStyle(2,t),n;case"zone":if(e.zoneShape){const s=o.add.graphics();return s.lineStyle(2,t,1),e.zoneShape instanceof Phaser.Geom.Polygon?s.strokePoints(e.zoneShape.points,!0):s.strokeRect(e.zoneShape.x,e.zoneShape.y,e.zoneShape.width,e.zoneShape.height),s}return null;default:if(e.width!==void 0&&e.height!==void 0){const s=o.add.graphics();return s.lineStyle(2,t,1),s.strokeRect(e.x,e.y,e.width,e.height),s}return null}}function Re(o,e,t){const n={fontSize:"16px",color:t,backgroundColor:"#ffffff"};let s=e.x,i=e.y-20,a=0,r=0;switch(e.type){case"point":a=.5,r=1;break;case"zone":if(e.zoneShape){if(e.zoneShape instanceof Phaser.Geom.Polygon){const c=Phaser.Geom.Polygon.GetAABB(e.zoneShape);s=c.centerX,i=c.centerY}else s=e.zoneShape.centerX,i=e.zoneShape.centerY;a=.5,r=.5}break}const l=o.add.text(s,i,e.name,n);return l.setOrigin(a,r),l}function Xe(o,e,t,n,s,i,a){const r=o.add.container(e.x,e.y);if(r.setName(e.name),r.setData("tileData",e),r.setData("tileSliceSize",n),r.setData("psdKey",a),r.setDepth(e.initialDepth??0),T(e,r),["setX","setY","setPosition","setBlendMode","setAlpha","setDepth","setMask"].forEach(d=>{Fe(r,d)}),te(t,a,e)){const d=Y(o,e,t);d&&r.add(d)}else{const g=t.getData(a)?.isMultiplePsd||!1;Ve(o,r,e,n,g,a)}Ie(o,e,r),s.add(r);const f=o.add.group();B(o,t,f,{type:"tileset",name:e.name,x:e.x,y:e.y,width:e.columns*n,height:e.rows*n}),s.debugGroup=f}function Ve(o,e,t,n,s=!1,i){for(let a=0;a<t.columns;a++)for(let r=0;r<t.rows;r++){const l=a*n,c=r*n,d=`${s&&i?`${i}_${t.name}`:t.name}_tile_${a}_${r}`,g=ne(o,{x:l,y:c,key:d,initialDepth:t.initialDepth},e);g&&e.add(g)}}function Fe(o,e){const t=Phaser.GameObjects.Container.prototype[e];o[e]=function(...n){const s=t.apply(this,n);if(["setX","setY","setPosition"].includes(e)){const a=e==="setX"||e==="setPosition"?n[0]-this.x:0,r=e==="setY"?n[0]-this.y:e==="setPosition"?n[1]-this.y:0;this.each(l=>{a!==0&&(l.x+=a),r!==0&&(l.y+=r)})}else this.each(a=>{typeof a[e]=="function"&&a[e](...n)});const i=this.getData("pendingMethodCalls")||[];return i.push({method:e,args:n}),this.setData("pendingMethodCalls",i),s}}function ne(o,e,t){if(o.textures.exists(e.key)){const n=o.add.image(e.x,e.y,e.key);return n.setOrigin(0,0),(t instanceof Phaser.GameObjects.Group||t instanceof Phaser.GameObjects.Container)&&t.add(n),n}else return console.warn(`Texture not found for tile: ${e.key}`),null}function se(o,e,t){t.setName(e.name),t.setOrigin(0,0),t.setDepth(e.initialDepth??0),T(e,t),K(o,e,t)}function ie(o,e){e.name=o.name,e.setDepth(o.initialDepth??0),T(o,e)}function ae(o,e,t){e.mask&&e.maskPath&&t.getChildren().forEach(n=>{K(o,e,n)})}function O(o,e){return e||o.name}function re(o,e,t){o.setName(e),o.setOrigin(0,0),o.setDepth(t)}function Ye(o,e,t,n,s){const i=O(e,s),a=o.add.sprite(e.x,e.y,i);return se(o,e,a),e.frame!==void 0&&a.setFrame(e.frame),a}function Ke(o,e,t,n,s){const i=o.add.group(),a=O(e,s);if(o.textures.exists(a)){const l=o.textures.get(a).getFrameNames(),c=Object.keys(e.frames).reduce((f,d,g)=>(f[d]=g,f),{});e.instances&&e.instances.forEach(f=>{const{name:d,x:g,y:P}=f,k=c[d];if(k!==void 0&&k<l.length){const v=l[k],b=o.add.sprite(g,P,a,v);re(b,d,e.initialDepth??0),i.add(b),t.isDebugEnabled("console")&&console.log(`Placed spritesheet instance: ${d}, at (${g}, ${P}), using frame: ${v}`)}else console.warn(`Frame for "${d}" not found in spritesheet "${a}"`)})}else console.error(`Texture "${a}" not found. Make sure the spritesheet is loaded correctly.`);return ie(e,i),ae(o,e,i),i}function Je(o,e,t,n,s){const i=o.add.group(),a=O(e,s);if(o.textures.exists(a)){const l=o.textures.get(a).getFrameNames();e.instances&&e.instances.forEach(c=>{const{name:f,x:d,y:g}=c;if(l.includes(f)){const P=o.add.sprite(d,g,a,f);re(P,f,e.initialDepth??0),i.add(P)}else console.warn(`Frame "${f}" not found in atlas "${a}"`)})}else console.error(`Texture "${a}" not found. Make sure the atlas is loaded correctly.`);return ie(e,i),ae(o,e,i),i}function We(o,e,t,n,s,i){const a=O(e,s),r=o.add.sprite(e.x,e.y,a,0);if(se(o,e,r),e.frame_width&&e.frame_height){const l={key:a,frames:o.anims.generateFrameNumbers(a,{start:0,end:e.frame_count?e.frame_count-1:-1}),frameRate:e.attributes?.frameRate||24,repeat:e.attributes?.repeat!==void 0?e.attributes.repeat:-1};e.attributes?.yoyo!==void 0&&(l.yoyo=e.attributes.yoyo),e.attributes?.delay!==void 0&&(l.delay=e.attributes.delay),e.attributes?.repeatDelay!==void 0&&(l.repeatDelay=e.attributes.repeatDelay),e.attributes?.duration!==void 0&&(l.duration=e.attributes.duration),e.attributes?.showOnStart!==void 0&&(l.showOnStart=e.attributes.showOnStart),e.attributes?.hideOnComplete!==void 0&&(l.hideOnComplete=e.attributes.hideOnComplete),i&&(Object.assign(l,i),l.key=a,i.frames||(l.frames=o.anims.generateFrameNumbers(a,{start:0,end:e.frame_count?e.frame_count-1:-1}))),o.anims.exists(a)||o.anims.create(l),r.play(a)}return r}function le(o,e,t,n,s,i,a){if(e.lazyLoad){const c=Y(o,e,t);c&&n.add(c),s();return}const l=t.getData(i)?.isMultiplePsd?`${i}_${e.name}`:e.name;if(o.textures.exists(l)){let c=null;switch(e.type){case"spritesheet":c=Ke(o,e,t,i,l);break;case"atlas":c=Je(o,e,t,i,l);break;case"animation":c=We(o,e,t,i,l,a);break;default:c=Ye(o,e,t,i,l);break}if(c){c instanceof Phaser.GameObjects.Group?c.getChildren().forEach(d=>{n.add(d)}):n.add(c),e.alpha!==void 0&&c.setAlpha(e.alpha),e.hidden!==void 0&&c.setVisible(!1),c.setDepth(e.initialDepth||0);const f=o.add.group();B(o,t,f,{type:"sprite",name:e.name,x:e.x,y:e.y,width:e.width,height:e.height}),n.debugGroup=f}else console.error(`Failed to place sprite: ${e.name}`)}else console.warn(`Texture not found for sprite: ${e.name} (looking for texture key: ${l})`);s()}function je(o,e,t,n,s,i){const a=Ze(o,e);if(a){n.add(a);const r=o.add.group(),l=ce(e);B(o,t,r,{type:"zone",name:e.name,x:e.x,y:e.y,zoneShape:l}),n.debugGroup=r}}function Ze(o,e){const t=ce(e);let n,s;if(t instanceof Phaser.Geom.Polygon){const i=Phaser.Geom.Polygon.GetAABB(t);n=o.add.zone(i.x,i.y,i.width,i.height),s=t.points}else n=o.add.zone(t.x,t.y,t.width,t.height),s=[new Phaser.Geom.Point(t.x,t.y),new Phaser.Geom.Point(t.x+t.width,t.y),new Phaser.Geom.Point(t.x+t.width,t.y+t.height),new Phaser.Geom.Point(t.x,t.y+t.height)];return n.setName(e.name||"unnamed_zone"),T(e,n),n.setData("points",s),n.setData("category",e.category),n.setData("x",e.x),n.setData("y",e.y),n.setData("width",e.width),n.setData("height",e.height),e.initialDepth!==void 0&&n.setData("initialDepth",e.initialDepth),e.attributes&&n.setData("attributes",e.attributes),n}function ce(o){if(o.subpaths&&Array.isArray(o.subpaths)&&o.subpaths.length>0&&Array.isArray(o.subpaths[0])){const e=o.subpaths[0].flatMap(t=>new Phaser.Geom.Point(t[0],t[1]));return new Phaser.Geom.Polygon(e)}else if(o.bbox&&typeof o.bbox=="object"){const{left:e,top:t,right:n,bottom:s}=o.bbox;if(typeof e=="number"&&typeof t=="number"&&typeof n=="number"&&typeof s=="number")return new Phaser.Geom.Rectangle(e,t,n-e,s-t)}return console.error("Unable to create zone shape. Invalid zone data:",o),new Phaser.Geom.Rectangle(0,0,1,1)}function He(o,e,t,n,s,i){const a=Ue(o,e);if(a){n.add(a);const r=o.add.group();B(o,t,r,{type:"point",name:e.name,x:e.x,y:e.y}),n.debugGroup=r}}function Ue(o,e){const t=o.add.container(e.x,e.y);return t.setData("pointData",e),t.setName(e.name),T(e,t),t}const fe=["setAlpha","setAngle","setActive","setAlpha","setBlendMode","setDepth","setDisplaySize","setFlip","setMask","setOrigin","setPipeline","setPosition","setRotation","setScale","setScrollFactor","setSize","setTint","setVisible","setX","setY","setZ"];function qe(o,e){e instanceof Phaser.GameObjects.Group?Qe(o,e):et(o,e)}function Qe(o,e){fe.forEach(t=>{e[t]=tt(o,t)})}function et(o,e){fe.forEach(t=>{t==="remove"&&(e[t]=(n={})=>{e.removedFromScene()})})}function tt(o,e){return function(...t){const n=typeof t[t.length-1]=="object"&&!Array.isArray(t[t.length-1])?t.pop():{},s=n.depth!==void 0?n.depth:1/0;ue(this,e,t,s,0)}}function ue(o,e,t,n,s){s>n||(o instanceof Phaser.GameObjects.Group?s<n&&o.getChildren().forEach(a=>{ue(a,e,t,n,s+1)}):typeof o[e]=="function"&&o[e](...t))}function ot(o){return function(t,n={}){let s,i=1/0;typeof t=="string"?(s=t,i=n.depth!==void 0?n.depth:1/0):typeof t=="object"&&(i=t.depth!==void 0?t.depth:1/0);let a=!1;const r=(c,f=0)=>{if(!(f>=i)){if(c instanceof Phaser.GameObjects.Group&&(c.getChildren().forEach(d=>r(d,f+1)),f===i)){c.clear(),a=!0;return}"parentContainer"in c&&c.parentContainer?c.parentContainer.remove(c):c.scene&&c.scene.children.remove(c),typeof c.destroy=="function"&&c.destroy(!0),a=!0}},l=(c,f)=>{if(f.length===0)return r(c),!0;if(c instanceof Phaser.GameObjects.Group){const d=f[0],g=c.getChildren().find(P=>P.name===d);if(g)return l(g,f.slice(1))}return!1};if(s){const c=s.split("/");a=l(this,c)}else r(this);return a||console.warn(`Object not found or already removed: ${s||"root"}`),a}}function nt(o,e){e.remove=ot()}function st(o,e){e instanceof Phaser.GameObjects.Group?at(o,e):e instanceof Phaser.GameObjects.Sprite&&it(o,e)}function it(o,e){e.updateAnimation=function(t){return de(e,t)}}function at(o,e){e.updateAnimation=function(t){function n(s){s instanceof Phaser.GameObjects.Sprite&&s.anims&&s.anims.currentAnim?de(s,t):s instanceof Phaser.GameObjects.Group&&s.getChildren().forEach(n)}return n(e),e}}function de(o,e){const t=o.anims.currentAnim?.key;if(!t)return console.warn("No animation currently playing on sprite"),o;const n=o.scene,s=n.anims.get(t);if(!s)return console.warn(`Animation ${t} not found`),o;const i={key:t,frames:s.frames.map(a=>({key:a.textureKey,frame:a.textureFrame})),frameRate:s.frameRate,duration:s.duration,repeat:s.repeat,repeatDelay:s.repeatDelay,yoyo:s.yoyo,showOnStart:s.showOnStart,hideOnComplete:s.hideOnComplete,...e};return i.key=t,n.anims.remove(t),n.anims.create(i),o.play(t),o}function rt(o){return function(t,n={}){if(!t)return this;const s=t.split("/"),i=n.depth!==void 0?n.depth:1/0;function a(l,c,f){if(f>i||c.length===0)return null;const[d,...g]=c;let P;if(l instanceof Phaser.GameObjects.Group)P=l.getChildren();else if(l instanceof Phaser.GameObjects.Container)P=l.list;else return null;const k=P.filter(v=>!v.isDebugObject);for(const v of k)if(v.name===d){if(g.length===0)return v;if(v instanceof Phaser.GameObjects.Group||v instanceof Phaser.GameObjects.Container)return a(v,g,f+1)}for(const v of k)if(v instanceof Phaser.GameObjects.Group||v instanceof Phaser.GameObjects.Container){const b=a(v,c,f+1);if(b)return b}return null}let r=null;return this instanceof Phaser.GameObjects.Group||this instanceof Phaser.GameObjects.Container?r=a(this,s,0):r=this.name===s[0]?this:null,r?he(o,r):console.warn(`Item not found at path: ${t}`),r}}function lt(o,e){e.target=rt(o)}function he(o,e){qe(o,e),nt(o,e),st(o,e),lt(o,e)}function R(o,e){if(e.length===0)return null;const[t,...n]=e,s=o.find(i=>i.name===t);return s?n.length===0?s:V(s)?R(s.children,n):null:null}function ct(o){return function(t,n,s,i={}){const a=o.getData(n);if(!a||!a.original)return console.error(`No data found for key: ${n}`),t.add.group();const r=a.original.tile_slice_size||150,l=t.add.group(),c=R(a.original.layers,s.split("/"));if(!c)return console.error(`No layer found with path: ${s}`),l;const f=ge(t,c,o,r,l,n,i);return he(o,f),t.events.emit("layerPlaced",s),f}}function ge(o,e,t,n,s,i,a){if(V(e)){if(a.depth===void 0||a.depth>0){const l=o.add.group();return l.name=e.name,e.children.forEach(c=>{const f=ge(o,c,t,n,l,i,{...a,depth:a.depth!==void 0?a.depth-1:void 0});f instanceof Phaser.GameObjects.GameObject&&l.add(f)}),z(e)&&l.getChildren().forEach(c=>{K(o,e,c)}),s.add(l),l}return s}if(te(t,i,e)){const l=Y(o,e,t);return l&&s.add(l),s}return W(e)?(Xe(o,e,t,n,s,()=>{},i),s):G(e)?(le(o,e,t,s,()=>{},i,a.animationOptions),s):j(e)?(je(o,e,t,s),s):Z(e)?(He(o,e,t,s),s):(console.error(`Unknown layer category: ${e.category}`),s)}function ft(o){return function(t,n,s){const i=o.getData(n);if(!i)return console.log(`No PSD data found for key: ${n}`),null;const a=s.split("/"),r=R(i.original.layers,a);if(!r)return console.log(`Sprite not found: ${s}`),console.log(`Available sprites: ${JSON.stringify(i.original.layers.map(d=>d.name))}`),null;if(!G(r))return console.log(`Layer "${s}" is not a sprite layer`),null;const c=i.isMultiplePsd||!1?`${n}_${r.name}`:r.name;if(t.textures.exists(c))return t.textures.get(c);const f=`${i.basePath}/${r.filePath}`;return t.load.image(c,f),t.load.once(`filecomplete-image-${c}`,()=>{console.log(`Texture loaded: ${c}`)}),t.load.start(),t.load.once("complete",()=>{console.log(`Load complete for: ${c}`)}),t.textures.exists(c)?t.textures.get(c):(console.log(`Failed to load texture: ${c}`),null)}}function ut(o){return function(t,n,s){const i=o.getData(n);if(!i)return console.log(`No PSD data found for key: ${n}`),null;const a=s.split("/"),r=R(i.original.layers,a);if(!r)return console.log(`Layer not found: ${s}`),null;if(!z(r))return console.log(`Layer "${s}" does not have a mask`),null;const l=`${r.name}_mask`;if(!t.textures.exists(l)){const d=`${i.basePath}/${r.maskPath}`;return t.load.image(l,d),t.load.once(`filecomplete-image-${l}`,()=>{o.isDebugEnabled("console")&&console.log(`ðŸŽ­ Loaded mask on-demand: ${l}`)}),t.load.start(),console.log(`Mask texture "${l}" is being loaded. Call getMask again after load completes.`),null}const c=t.add.image(r.x,r.y,l);c.setOrigin(0,0),c.setVisible(!1);const f=c.createBitmapMask();return{maskImage:c,bitmapMask:f}}}function dt(o,e,t={}){const n=e.scene;let s=!1,i=!1,a=new Phaser.Math.Vector2,r=new Phaser.Math.Vector2,l=new Phaser.Math.Vector2;const f={...{easeDragging:!1,friction:.95,minSpeed:.1,ignore:[]},...t};function d(){f.useBounds&&(typeof f.useBounds=="object"?(console.log("using custom size"),e.setBounds(f.useBounds.x,f.useBounds.y,f.useBounds.width,f.useBounds.height)):console.warn("useBounds object must have {x, y, width, height} format"))}function g(m){const x=[];let w=m;for(;w;)w.name&&x.unshift(w.name),w=w.parentContainer||null;return x.join("/")}function P(m){if(!f.ignore||f.ignore.length===0)return!1;const x=g(m),w=m.name||"";for(const A of f.ignore)if(w===A||x===A||x.endsWith("/"+A)||x.startsWith(A+"/")||x===A||x.includes("/"+A+"/"))return!0;return!1}function k(m){if(!f.ignore||f.ignore.length===0)return!1;const x=n.input.hitTestPointer(m);for(const w of x)if(P(w))return!0;return!1}function v(m){i||k(m)||(s=!0,l.copy(m),a.copy(m),r.reset(),n.events.emit("draggableStart",e))}function b(m){if(!s)return;const x=m.x-a.x,w=m.y-a.y;e.scrollX-=x/e.zoom,e.scrollY-=w/e.zoom,r.set(-x,-w),a.copy(m),n.events.emit("draggableActive",e)}function L(){s=!1,f.easeDragging||r.reset(),n.events.emit("draggableComplete",e)}function _(){!s&&f.easeDragging&&(r.length()>f.minSpeed?(e.scrollX+=r.x/e.zoom,e.scrollY+=r.y/e.zoom,r.scale(f.friction),n.events.emit("draggableActive",e)):r.reset())}function p(){n.input.on("pointerdown",v),n.input.on("pointermove",b),n.input.on("pointerup",L),n.events.on("update",_)}return p(),d(),{isDragging:()=>s,isPaused:()=>i,getVelocity:()=>r.clone(),setOptions:m=>{Object.assign(f,m),d(),f.easeDragging||r.reset()},pause:()=>{i=!0,s&&(s=!1,r.reset(),n.events.emit("draggableComplete",e))},resume:()=>{i=!1}}}function ht(o,e,t={}){const n=e.scene,s=t.targetKeys||gt(o);if(s.length===0)return console.warn("No PSDs found for lazy loading"),{};const i=[];if(s.forEach(u=>{const h=o.getData(u);if(h&&h.lazyLoad&&(h.lazyLoad.sprites&&h.lazyLoad.sprites.forEach($=>{i.push({...$,_psdKey:u})}),h.lazyLoad.tiles)){const $=h.original.tile_slice_size??150;h.lazyLoad.tiles.forEach(M=>{A(M,$).forEach(y=>{i.push({...y,_psdKey:u})})})}}),i.length===0)return t.debug?.console&&console.log("No lazy load items found in target PSDs:",s),{};let a,r=null,l=[],c=new Set,f=null,d=null;function g(){t.createBoundaryCamera&&P(),k(),v(),(t.debug?.shape||t.debug?.label)&&b(),_(),D()}function P(){d=n.cameras.add(),d.setVisible(!1),d.setZoom(1),d.setScroll(e.scrollX,e.scrollY),d.setSize(e.width,e.height)}function k(){const u=t.extendPreloadBounds||0;if(d){d.setScroll(e.scrollX,e.scrollY);const h=e.width/e.zoom,$=e.height/e.zoom,M=e.scrollX+e.width/2,y=e.scrollY+e.height/2;a=new Phaser.Geom.Rectangle(M-h/2-u,y-$/2-u,h+u*2,$+u*2)}else{const h=e.width/e.zoom,$=e.height/e.zoom;a=new Phaser.Geom.Rectangle(e.scrollX-u,e.scrollY-u,h+u*2,$+u*2)}}function v(){const u=h=>{const $=n.add.rectangle(h.x,h.y,h.width,h.height);return $.setOrigin(0,0),$.setStrokeStyle(1,65280),$.setDepth(1e3),{boundary:$,data:{...h,loaded:!1}}};l=i.map(u),t.debug?.shape?l.forEach(h=>h.boundary.setVisible(!0)):l.forEach(h=>h.boundary.setVisible(!1)),t.debug?.label&&l.forEach(h=>{const $=n.add.text(h.boundary.x,h.boundary.y-20,h.data.name,{fontSize:"12px",color:"#00ffff",backgroundColor:"#000000"});$.setOrigin(0,1),$.setDepth(1001)})}function b(){r=n.add.graphics(),r.setDepth(1e3),L()}function L(){r&&(r.clear(),r.lineStyle(2,16711935,1),r.strokeRect(a.x,a.y,a.width,a.height))}function _(){const u=l.filter(({boundary:h,data:$})=>!$.loaded&&!c.has(p($))&&Phaser.Geom.Intersects.RectangleToRectangle(h.getBounds(),a));u.length>0&&(t.debug?.console&&console.log(`LazyLoad: ${u.length} objects to load`),n.events.emit("lazyLoadStart",u.length),u.forEach(m))}function p(u){if(!u)return"unknown";const h=u.category||u.type;return h==="tile"||h==="tileset"?`tile_${u.tilesetName||u.name}_${u.col}_${u.row}`:`sprite_${u.name}_${Math.round(u.x)}_${Math.round(u.y)}`}function m({data:u}){const h=p(u);c.add(h);const $=u._psdKey;t.debug?.console&&console.log(`LazyLoad: Loading object ${h} from PSD ${$}`);const M={sprites:u.category==="sprite"?[u]:[],tiles:[],groups:[],singleTiles:u.category==="tile"||u.category==="tileset"?[u]:[]};U(n,$,M,o),n.load.once("complete",()=>{x(u)}),n.load.start()}function x(u){const h=p(u);if(c.delete(h),u.loaded=!0,t.debug?.console&&console.log(`LazyLoad: Object loaded ${h}`),u.category==="sprite"){const y=n.add.group();le(n,u,o,y,()=>{y.getChildren().forEach(S=>{S.setDepth&&u.initialDepth!==void 0&&S.setDepth(u.initialDepth)}),n.children.sort("depth")},u._psdKey)}else if(u.category==="tile"||u.category==="tileset"){const y=w(n,u);ne(n,{x:u.x-y.x,y:u.y-y.y,key:`${u.tilesetName}_tile_${u.col}_${u.row}`,initialDepth:u.initialDepth,tilesetName:u.tilesetName,col:u.col,row:u.row},y)}const $=l.filter(({data:y})=>y.loaded).length/l.length,M=Array.from(c);n.events.emit("lazyLoadProgress",$,M),t.debug?.console&&console.log(`LazyLoad: Progress ${$.toFixed(2)}, Remaining:`,M),l.every(({data:y})=>y.loaded)&&(n.events.emit("lazyLoadingComplete"),t.debug?.console&&console.log("LazyLoad: All objects loaded")),L()}function w(u,h){const $=u.children.list.find(C=>C instanceof Phaser.GameObjects.Container&&C.name===h.tilesetName);if($)return $;const M=h.x-h.col*h.tile_slice_size,y=h.y-h.row*h.tile_slice_size,S=u.add.container(M,y);return S.setName(h.tilesetName),S.setDepth(h.initialDepth),S}function A(u,h){const $=[];for(let M=0;M<u.columns;M++)for(let y=0;y<u.rows;y++)$.push({category:"tile",name:`${u.name}_tile_${M}_${y}`,x:u.x+M*h,y:u.y+y*h,width:h,height:h,tile_slice_size:h,filetype:u.filetype||"png",tilesetName:u.name,col:M,row:y,initialDepth:u.initialDepth});return $}function D(){const u=t.checkInterval||300;f=window.setInterval(()=>{X()},u)}function X(){k(),_(),(t.debug?.shape||t.debug?.label)&&L()}return g(),{update:X,destroy:()=>{f!==null&&(window.clearInterval(f),f=null),l.forEach(u=>u.boundary.destroy()),r&&r.destroy(),d&&(n.cameras.remove(d),d=null)}}}function gt(o){return o.getAllKeys()}function mt(o,e,t,n={}){const s=e;if(t.includes("draggable")&&Object.assign(s,dt(o,e,n.draggable)),t.includes("lazyLoad")){const i=typeof n.lazyLoad=="boolean"?{}:n.lazyLoad??{};Object.assign(s,ht(o,e,i))}return s}function pt(o){return function(e){let t,n;if(Array.isArray(e))if(e.length===2)typeof e[1]=="function"?(t={normal:e[0]},n={click:e[1]}):(t=e[0],n=e[1]);else if(e.length===3)t={normal:e[0],hover:e[1]},n={click:e[2]};else{console.error("Button: Invalid array format");return}else{console.error("Button: Invalid input format");return}if(!t.normal){console.error("Button requires at least a normal image");return}let s=t.normal,i=t.normal;if(i instanceof Phaser.GameObjects.Group){const b=i.getChildren();if(b.length===0){console.error("Button target group is empty");return}s=b[0]}else if(i instanceof Phaser.GameObjects.Container){if(i.list.length===0){console.error("Button target container is empty");return}s=i.list[0]}const a=s.scene;if(!a){console.error("Button target must have a valid scene");return}if(typeof s.setInteractive!="function"){console.error("Button target does not support interaction:",s.constructor.name);return}let r="normal";const l=s;let c,f,d,g;if(typeof l.getBounds=="function"){const b=l.getBounds();c=b.centerX||b.x+b.width/2,f=b.centerY||b.y+b.height/2,d=b.width,g=b.height}else c=l.x||0,f=l.y||0,d=l.width||l.displayWidth||100,g=l.height||l.displayHeight||100;const P=a.add.rectangle(c,f,d,g,0,0);P.setInteractive(),P.setDepth(Number.MAX_SAFE_INTEGER),P.setVisible(!0),t.normal&&t.normal.setVisible(!0),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);function k(b){t.normal&&t.normal.setVisible(!1),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);const L=t[b];L?L.setVisible(!0):t.normal&&t.normal.setVisible(!0),r=b}const v=a.sys.game.device.input.touch;return P.on("pointerdown",(b,L,_,p)=>{t.active&&k("active"),n.mousePress&&n.mousePress(i,{localX:L,localY:_,event:p},b)}),P.on("pointerup",(b,L,_,p)=>{t.active&&(!v&&t.hover&&P.input?.isOver?k("hover"):k("normal")),n.click&&n.click(i,{localX:L,localY:_,event:p},b)}),!v&&t.hover&&(P.on("pointerover",(b,L,_,p)=>{k("hover"),n.mouseOver&&n.mouseOver(i,{localX:L,localY:_,event:p},b)}),P.on("pointerout",(b,L)=>{r!=="active"&&(k("normal"),n.mouseOut&&n.mouseOut(i,{event:L},b))})),r="normal",{destroy:()=>{P.off("pointerover"),P.off("pointerout"),P.off("pointerdown"),P.off("pointerup"),P.destroy()},getCurrentState:()=>r,showState:b=>{k(b)}}}}function yt(o){return function(e,t,n={}){const s=e.scene;if(!s){console.error("Unable to determine scene for fillZone");return}const i=e.getData("points");if(!i||i.length===0){console.error("Zone does not have valid points data");return}const a=new Phaser.Geom.Polygon(i),r=Phaser.Geom.Polygon.GetAABB(a);let l,c;if(t instanceof Phaser.GameObjects.Group){const _=t.getChildren()[0];if(!_){console.error("Group is empty");return}l=_.texture.key,c=n.useFrames||[_.frame.name]}else l=t.texture.key,c=n.useFrames||[t.frame.name];const f=s.textures.get(l);if(!f){console.error(`Texture not found: ${l}`);return}if(!c||c.length===0){const _=f.getFrameNames();_.length>0?c=_:c=Array.from({length:f.frameTotal},(p,m)=>m)}const d=s.add.group(),g=n.minInstances!==void 0?n.minInstances:5,P=n.maxInstances!==void 0?n.maxInstances:10,k=Phaser.Math.Between(g,P);let v=0,b=k*10,L=0;for(;v<k&&L<b;){const _=Phaser.Math.Between(r.left,r.right),p=Phaser.Math.Between(r.top,r.bottom);if(Phaser.Geom.Polygon.Contains(a,_,p)){const m=Phaser.Math.RND.pick(c),x=s.add.sprite(_,p,l,m);if(n.scaleRange){const w=Phaser.Math.FloatBetween(n.scaleRange[0],n.scaleRange[1]);x.setScale(w)}if(n.tint&&n.tint.length>0){const w=Phaser.Math.RND.pick(n.tint);x.setTint(w)}d.add(x),v++}L++}return console.log(`fillZone completed. Sprites placed: ${v}, Target: ${k}, Attempts: ${L}`),d}}function bt(o){return function(e,t,n,s={}){const i=t.scene,a=s.bounceBack||!1,r=s.joystickRadius||50;e.setOrigin(.5,.5),e.setPosition(e.x+e.width/2,e.y+e.height/2);const l={x:e.x,y:e.y},c=t.getData("points"),f=c?new Phaser.Geom.Polygon(c):t.getBounds();let d=null;const g=(p,m)=>{const x=me(f),w=new Phaser.Math.Vector2(p-x.x,m-x.y);w.length()>r&&w.setLength(r);const D={x:x.x+w.x,y:x.y+w.y};return c?Phaser.Geom.Polygon.Contains(f,D.x,D.y)?D:xt(f,D.x,D.y):{x:Phaser.Math.Clamp(D.x,f.left,f.right),y:Phaser.Math.Clamp(D.y,f.top,f.bottom)}},P=(p,m)=>{const x=me(f);return{x:(p-x.x)/r,y:(m-x.y)/r}},k=(p,m)=>p.x>=m.left&&p.x<=m.right&&p.y>=m.top&&p.y<=m.bottom,v=p=>{d===null&&k(p,e.getBounds())&&(d=p,i.events.emit("joystickStart",{[n]:{isActive:!0,position:{x:e.x,y:e.y},change:{x:0,y:0},normalized:{x:0,y:0}}}))},b=p=>{if(p===d){const{x:m,y:x}=g(p.x,p.y);e.setPosition(m,x);const w={x:m-l.x,y:x-l.y},A=P(m,x);i.events.emit("joystickActive",{[n]:{isActive:!0,position:{x:m,y:x},change:w,normalized:A}})}},L=p=>{p===d&&(d=null,a?i.tweens.add({targets:e,x:l.x,y:l.y,duration:300,ease:"Bounce.out",onComplete:()=>{i.events.emit("joystickRelease",{[n]:{isActive:!1,position:l,change:{x:0,y:0},normalized:{x:0,y:0}}})}}):i.events.emit("joystickRelease",{[n]:{isActive:!1,position:{x:e.x,y:e.y},change:{x:e.x-l.x,y:e.y-l.y},normalized:P(e.x,e.y)}}))};i.input.on("pointerdown",v),i.input.on("pointermove",b),i.input.on("pointerup",L),i.input.on("pointerupoutside",L);function _(){i.input.off("pointerdown",v),i.input.off("pointermove",b),i.input.off("pointerup",L),i.input.off("pointerupoutside",L)}return{control:(p,m)=>{let x=new Phaser.Math.Vector2,w=0;const A=new Phaser.Math.Vector2(p.x,p.y),D=new Phaser.Math.Vector2(l.x,l.y),X=(y,S)=>{if(!m.directionLock)return[y,S];if(m.directionLock===4)return Math.abs(y)>Math.abs(S)?[y,0]:[0,S];if(m.directionLock===8){const C=Math.atan2(S,y),N=Math.round(8*C/(2*Math.PI)+8)%8*Math.PI/4;return[Math.cos(N),Math.sin(N)]}return[y,S]},u=(y,S,C)=>{switch([y,S]=X(y,S),m.type){case"speed":const J=m.maxSpeed||300;p.x+=y*J*C/1e3,p.y+=S*J*C/1e3;break;case"velocity":const N=p.body;if(N){const I=m.force||1;N.setVelocity(y*I*60,S*I*60)}break;case"unit":const pe=i.time.now,St=m.repeatRate||0,ye=m.pixels||100,be=.2;if((Math.abs(y)>be||Math.abs(S)>be)&&(w===0||pe-w>=St)){const I=Math.atan2(S,y);p.x+=Math.round(Math.cos(I)*ye),p.y+=Math.round(Math.sin(I)*ye),w=pe}break;case"tracked":const xe=m.multiplier||1,Lt=(y-D.x)*xe,_t=(S-D.y)*xe;p.setPosition(A.x+Lt,A.y+_t);break}},h=y=>{if(y[n])if(m.type==="tracked"){const S=y[n].position;u(S.x,S.y,0)}else x.set(y[n].normalized.x,y[n].normalized.y),w===0&&u(x.x,x.y,0)},$=y=>{if(y[n])if(x.reset(),w=0,m.type==="velocity"){const S=p.body;S&&S.setVelocity(0,0)}else m.type==="tracked"&&s.bounceBack&&p.setPosition(A.x,A.y)},M=(y,S)=>{m.type!=="tracked"&&(x.x!==0||x.y!==0)&&u(x.x,x.y,S)};return i.events.on("joystickActive",h),i.events.on("joystickRelease",$),i.events.on("update",M),{destroy:()=>{_(),i.events.off("joystickActive",h),i.events.off("joystickRelease",$),i.events.off("update",M)}}},destroy:_}}}function xt(o,e,t){let n=new Phaser.Geom.Point,s=Number.MAX_VALUE;for(let i=0;i<o.points.length;i++){const a=o.points[i],r=o.points[(i+1)%o.points.length],l=Pt(a,r,e,t),c=Phaser.Math.Distance.Between(e,t,l.x,l.y);c<s&&(s=c,n=l)}return n}function Pt(o,e,t,n){const s=e.x-o.x,i=e.y-o.y,a=((t-o.x)*s+(n-o.y)*i)/(s*s+i*i),r=Phaser.Math.Clamp(a,0,1);return new Phaser.Geom.Point(o.x+r*s,o.y+r*i)}function me(o){let e=0,t=0;for(const n of o.points)e+=n.x,t+=n.y;return new Phaser.Geom.Point(e/o.points.length,t/o.points.length)}function $t(o){return function(e,t,n={}){const s=e.scene,a={...{targetPositionY:"center",targetPositionX:"center",targetOffset:[0,0],speed:300,easing:!0},...n};let r,l,c=0,f=0;switch(Array.isArray(t)?[r,l]=t:(r=t.x,l=t.y,c=t.width||0,f=t.height||0),r+=c/2,l+=f/2,a.targetPositionX){case"left":r+=e.width/2;break;case"right":r-=e.width/2;break}switch(a.targetPositionY){case"top":l+=e.height/2;break;case"bottom":l-=e.height/2;break}r+=a.targetOffset[0],l+=a.targetOffset[1];const d=r-e.width/2,g=l-e.height/2,P=d-e.scrollX,k=a.speed;let v=Phaser.Math.Easing.Linear;a.easing===!0?v=Phaser.Math.Easing.Cubic.InOut:typeof a.easing=="function"&&(v=a.easing),s.events.emit("panToStart"),s.tweens.add({targets:e,scrollX:d,scrollY:g,duration:k,ease:v,onUpdate:()=>{const b=1-(e.scrollX-d)/P;s.events.emit("panToProgress",b)},onComplete:()=>{s.events.emit("panToComplete")}})}}function vt(o){return function(e){const{camera:t,target:n,scrollFactor:s=.25}=e;if(!n){console.warn('[P2P parallax] No valid "target" was provided.');return}let i,a;if(typeof t=="string"){if(a=n.scene,!a){console.warn(`[P2P parallax] Could not resolve scene from target for camera "${t}".`);return}i=a.cameras.getCamera(t),i||(i=a.cameras.main)}else if(t instanceof Phaser.Cameras.Scene2D.Camera)i=t,a=i.scene;else{if(a=n.scene,!a){console.warn("[P2P parallax] Could not find scene from target to use a default camera.");return}i=a.cameras.main}if(!i){console.warn("[P2P parallax] Could not resolve a valid camera.");return}if(!a){console.warn("[P2P parallax] Could not resolve a valid scene.");return}const r=a.sys;r._parallaxItems||(r._parallaxItems=[],a.events.on("update",()=>{const l=r._parallaxItems||[];for(const c of l)c.target.x=c.initX+c.camera.scrollX*c.factor,c.target.y=c.initY+c.camera.scrollY*c.factor})),r._parallaxItems.push({target:n,camera:i,factor:s,initX:n.x,initY:n.y})}}function wt(o){return{button:pt(),fillZone:yt(),joystick:bt(),panTo:$t(),parallax:vt()}}class kt extends E.Plugins.BasePlugin{psdData={};options;load;place;getTexture;getMask;use;createCamera;constructor(e){super(e),this.options={},console.log("%câœ¨ PSD-to-Phaser v0.0.6 âœ¨","background: black; color: white; padding: 1px 3px; border-radius: 2px;"),this.load=Ne(this),this.place=ct(this),this.getTexture=ft(this),this.getMask=ut(this),this.use=wt(),this.createCamera=(t,n,s)=>mt(this,t,n,s)}init(e={}){this.options={debug:!1,applyAlphaAll:!1,applyBlendModesAll:!1,...e},typeof this.options.debug=="boolean"&&(this.options.debug=this.options.debug?{shape:!0,label:!0,console:!0}:!1),this.options.debug&&console.log("PsdToPhaserPlugin initialized with options:",this.options)}setData(e,t){this.psdData[e]=t,this.isDebugEnabled("console")&&console.log(`Data set for key "${e}":`,t)}getData(e){return this.psdData[e]}getAllKeys(){return Object.keys(this.psdData)}isDebugEnabled(e){return typeof this.options.debug=="object"&&!!this.options.debug[e]}}return kt}));
