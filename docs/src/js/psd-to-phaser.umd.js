(function(G,S){typeof exports=="object"&&typeof module<"u"?module.exports=S(require("phaser")):typeof define=="function"&&define.amd?define(["phaser"],S):(G=typeof globalThis<"u"?globalThis:G||self,G.PsdToPhaserPlugin=S(G.Phaser))})(this,(function(G){"use strict";var wt=Object.defineProperty;var kt=(G,S,O)=>S in G?wt(G,S,{enumerable:!0,configurable:!0,writable:!0,value:O}):G[S]=O;var N=(G,S,O)=>kt(G,typeof S!="symbol"?S+"":S,O);function S(o){return o.category==="sprite"}function O(o){return o.category==="tileset"}function Z(o){return o.category==="zone"}function H(o){return o.category==="point"}function j(o){return o.category==="group"&&Array.isArray(o.children)}function z(o){return o.mask===!0&&typeof o.maskPath=="string"}function ge(o,e,t,s,i){return new Promise(n=>{let a=e.length;e.forEach(r=>{const l=r.name,c=`${t}/${r.filePath}`,f=()=>{a--,s(),a===0&&n()};z(r)&&J(o,r.name,t,r.maskPath,s,i),r.type==="atlas"?me(o,l,c,r,f,i):r.type==="spritesheet"||r.type==="animation"?pe(o,l,c,r,f,i):ye(o,l,c,f,i)}),a===0&&n()})}function J(o,e,t,s,i,n){const a=`${e}_mask`,r=`${t}/${s}`;o.textures.exists(a)?(i(),n&&console.log(`Mask already loaded: ${a}`)):(o.load.image(a,r),o.load.once(`filecomplete-image-${a}`,()=>{n&&console.log(`ðŸŽ­ Loaded mask: ${a} from ${r}`),i()}))}function me(o,e,t,s,i,n){console.log(`[${Date.now()}] Starting loadAtlas for key: ${e}`);const a={frames:{}};Object.entries(s.frames).forEach(([l,c])=>{a.frames[l]={frame:{x:c.x,y:c.y,w:c.width,h:c.height},rotated:!1,trimmed:!1,sourceSize:{w:c.width,h:c.height},spriteSourceSize:{x:0,y:0,w:c.width,h:c.height}}}),o.load.atlas(e,t,a);const r=()=>{o.textures.exists(e)?(n&&console.log(`ðŸ—ºï¸ Loaded atlas: ${e} from ${t}`),o.load.off("complete",r),i()):setTimeout(r,100)};o.load.on("complete",r),o.load.on("loaderror",l=>{console.error("Error loading file: ",l),o.load.off("complete",r)})}function pe(o,e,t,s,i,n){o.load.spritesheet(e,t,{frameWidth:s.frame_width,frameHeight:s.frame_height}),o.load.once(`filecomplete-spritesheet-${e}`,()=>{n&&console.log(`ðŸ’¥ Loaded spritesheet: ${e} from ${t}`);for(let a=0;a<(s.frame_count??1);a++)i()})}function ye(o,e,t,s,i){o.load.image(e,t),o.load.once(`filecomplete-image-${e}`,()=>{i&&console.log(`ðŸŽ‘ Loaded image: ${e} from ${t}`),s()})}function U(o,e,t,s,i,n){const a=`${e.tilesetName}_tile_${e.col}_${e.row}`,r=`${t}/tiles/${e.tilesetName}/${s}/${a}.${e.filetype??"png"}`;!o.textures.exists(a)&&!o.textures.getTextureKeys().includes(a)&&!o.load.textureManager.exists(a)?(o.load.image(a,r),o.load.once(`filecomplete-image-${a}`,()=>{i(),n&&console.log(`ðŸ§© Loaded tile: ${a} from ${r}`)}),o.load.start()):(i(),n&&console.log(`Tile already loaded or loading: ${a}`))}function be(o,e,t,s,i,n,a){e.forEach(r=>{for(let l=0;l<r.columns;l++)for(let c=0;c<r.rows;c++){const f={tilesetName:r.name,col:l,row:c,filetype:r.filetype},d=`${r.name}_tile_${l}_${c}`;a.push(d),U(o,f,t,s,()=>{const h=a.indexOf(d);h>-1&&a.splice(h,1),i()},n)}})}function q(o,e,t,s){const i=s.getData(e);if(!i||!i.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const n=i.basePath,a=i.original.tile_slice_size??150,r=xe(t),l=r.tiles+r.sprites+r.singleTiles+r.atlases+r.masks;let c=0;const f=[];s.isDebugEnabled("console")&&(console.log(`Total assets to load: ${l}`),console.log(`Tiles to load: ${r.tiles}`),console.log(`Sprites to load: ${r.sprites}`),console.log(`Single tiles to load: ${r.singleTiles}`),console.log(`Atlases to load: ${r.atlases}`),console.log(`Masks to load: ${r.masks}`),console.log(`Tile slice size: ${a}`));const d=()=>{c++;const h=c/l;o.events.emit("psdLoadProgress",h),s.isDebugEnabled("console")&&console.log(`â³ Progress: ${c} of ${l} ( ${(h*100).toFixed(2)}% )`),c===l&&(o.events.emit("psdLoadComplete"),s.isDebugEnabled("console")&&console.log("All PSD assets loaded"))};t.tiles&&t.tiles.length>0&&be(o,t.tiles,n,a,d,s.isDebugEnabled("console"),f),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(h=>{U(o,h,n,a,d,s.isDebugEnabled("console"))}),t.sprites&&t.sprites.length>0&&ge(o,t.sprites,n,d,s.isDebugEnabled("console")),t.tiles&&t.tiles.length>0&&t.tiles.forEach(h=>{!h.lazyLoad&&z(h)&&J(o,h.name,n,h.maskPath,d,s.isDebugEnabled("console"))}),t.groups&&t.groups.length>0&&t.groups.forEach(h=>{z(h)&&J(o,h.name,n,h.maskPath,d,s.isDebugEnabled("console"))}),o.load.isLoading()||o.load.start()}function xe(o){let e=0,t=0,s=0,i=0,n=0;o.tiles&&o.tiles.forEach(r=>{r.lazyLoad||(e+=r.columns*r.rows,z(r)&&n++)}),o.singleTiles&&(s=o.singleTiles.length);const a=r=>{r.forEach(l=>{l.lazyLoad||(l.type==="atlas"?i++:l.type==="spritesheet"?t+=l.frame_count??1:t++,z(l)&&n++)})};return o.sprites&&a(o.sprites),o.groups&&o.groups.forEach(r=>{z(r)&&n++}),{tiles:e,sprites:t,singleTiles:s,atlases:i,masks:n}}function Pe(o,e,t,s,i,n){if(!t||!Array.isArray(t.layers)){console.error(`Invalid or missing layers data for key: ${e}`);return}const a={original:JSON.parse(JSON.stringify(t)),basePath:s,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};Q(t.layers,a,!1,n==null?void 0:n.lazyLoad),i.setData(e,a),i.isDebugEnabled("console")&&console.log(`Processed JSON for key "${e}":`,a),q(o,e,a.initialLoad,i)}function Q(o,e,t,s){o.forEach(i=>{var r;let n=t||((r=i.attributes)==null?void 0:r.lazyLoad)===!0;s!==void 0&&(s===!0||Array.isArray(s)&&s.includes(i.name))&&(n=!0);const a=n?e.lazyLoad:e.initialLoad;O(i)?a.tiles.push(i):S(i)?a.sprites.push(i):Z(i)?a.zones.push(i):H(i)?a.points.push(i):j(i)&&(a.groups.push(i),Q(i.children,e,n,s))})}function $e(o){return function(e,t){if(!Array.isArray(t)||t.length===0){console.error("loadMultiple requires an array of PSD configurations");return}let s=0;const i=t.map(n=>new Promise((a,r)=>{const l=`${n.path}/data.json`,c=`${n.key}_temp_json`;e.load.json(c,l),e.load.once(`filecomplete-json-${c}`,(f,d,h)=>{if(h){const x=we(h,n.lazyLoad);s+=x,n._tempData=h,a()}else console.error(`Failed to load JSON for key: ${n.key}`),r(new Error(`Failed to load JSON for key: ${n.key}`))}),e.load.once("loaderror",f=>{f.key===c&&(console.error(`Failed to load JSON file: ${l}`),r(new Error(`Failed to load JSON file: ${l}`)))})}));e.load.isLoading()||e.load.start(),Promise.all(i).then(()=>{t.forEach(r=>{const l=r._tempData,c=ve(l,r.position),f={original:JSON.parse(JSON.stringify(c)),basePath:r.path,positionOffset:r.position,isMultiplePsd:!0,initialLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]},lazyLoad:{sprites:[],tiles:[],zones:[],points:[],groups:[]}};te(c.layers,f,!1,r.lazyLoad),o.setData(r.key,f),o.isDebugEnabled("console")&&console.log(`Processed multi-PSD data for key "${r.key}":`,f)});let n=0;const a=()=>{n++;const r=n/s;e.events.emit("psdLoadProgress",r),o.isDebugEnabled("console")&&console.log(`â³ Multi-PSD Progress: ${n} of ${s} (${(r*100).toFixed(2)}%)`),n===s&&(e.events.emit("psdLoadComplete"),o.isDebugEnabled("console")&&console.log("All multi-PSD assets loaded"))};t.forEach(r=>{const l=o.getData(r.key);l&&ke(e,r.key,l.initialLoad,o,a)}),e.load.isLoading()||e.load.start()}).catch(n=>{console.error("Failed to load multiple PSDs:",n)})}}function ve(o,e){const t=JSON.parse(JSON.stringify(o));function s(i){i.forEach(n=>{n.x+=e.x,n.y+=e.y,n.instances&&Array.isArray(n.instances)&&n.instances.forEach(a=>{a.x+=e.x,a.y+=e.y}),n.children&&Array.isArray(n.children)&&s(n.children)})}return t.layers&&Array.isArray(t.layers)&&s(t.layers),t}function we(o,e){let t=0;function s(i,n=!1){i.forEach(a=>{let r=n||a.lazyLoad===!0;if(e!==void 0&&(e===!0||Array.isArray(e)&&e.includes(a.name))&&(r=!0),!r)switch(a.category){case"tileset":t+=(a.columns||1)*(a.rows||1);break;case"sprite":a.type==="atlas"?t++:a.type==="spritesheet"?t+=a.frame_count||1:t++;break}a.children&&Array.isArray(a.children)&&s(a.children,r)})}return o.layers&&Array.isArray(o.layers)&&s(o.layers),t}function ke(o,e,t,s,i){const n=s.getData(e);if(!n||!n.basePath){console.error(`Invalid PSD data for key: ${e}`);return}const a=n.basePath,r=n.original.tile_slice_size||150;t.tiles&&t.tiles.length>0&&Ae(o,t.tiles,a,r,i,s.isDebugEnabled("console"),[],e),t.singleTiles&&t.singleTiles.length>0&&t.singleTiles.forEach(l=>{ee(o,l,a,r,i,s.isDebugEnabled("console"),e)}),t.sprites&&t.sprites.length>0&&De(o,t.sprites,a,i,s.isDebugEnabled("console"),e)}function De(o,e,t,s,i,n){e.forEach(a=>{const r=a.name,l=`${n}_${r}`,c=`${t}/${a.filePath}`,f=()=>{s()};a.type==="atlas"?Le(o,r,l,c,a,f,i):a.type==="spritesheet"||a.type==="animation"?Me(o,r,l,c,a,f,i):_e(o,r,l,c,f,i)})}function Le(o,e,t,s,i,n,a){const r={frames:{}};Object.entries(i.frames).forEach(([c,f])=>{r.frames[c]={frame:{x:f.x,y:f.y,w:f.width,h:f.height},rotated:!1,trimmed:!1,sourceSize:{w:f.width,h:f.height},spriteSourceSize:{x:0,y:0,w:f.width,h:f.height}}}),o.load.atlas(t,s,r);const l=()=>{o.textures.exists(t)?(a&&console.log(`ðŸ—ºï¸ Loaded atlas: ${t} from ${s}`),o.load.off("complete",l),n()):setTimeout(l,100)};o.load.on("complete",l)}function Me(o,e,t,s,i,n,a){o.load.spritesheet(t,s,{frameWidth:i.frame_width,frameHeight:i.frame_height}),o.load.once(`filecomplete-spritesheet-${t}`,()=>{a&&console.log(`ðŸ’¥ Loaded spritesheet: ${t} from ${s}`);for(let r=0;r<(i.frame_count||1);r++)n()})}function _e(o,e,t,s,i,n){o.load.image(t,s),o.load.once(`filecomplete-image-${t}`,()=>{n&&console.log(`ðŸŽ‘ Loaded image: ${t} from ${s}`),i()})}function Ae(o,e,t,s,i,n,a,r){e.forEach(l=>{for(let c=0;c<l.columns;c++)for(let f=0;f<l.rows;f++){const d=`${l.name}_tile_${c}_${f}`,h=`${r}_${d}`;a.push(h);const x={tilesetName:l.name,col:c,row:f,filetype:l.filetype};ee(o,x,t,s,()=>{const w=a.indexOf(h);w>-1&&a.splice(w,1),i()},n,r)}})}function ee(o,e,t,s,i,n,a){const r=`${e.tilesetName}_tile_${e.col}_${e.row}`,l=`${a}_${r}`,c=`${t}/tiles/${e.tilesetName}/${s}/${r}.${e.filetype||"png"}`;o.textures.exists(l)?(i(),n&&console.log(`Tile already loaded: ${l}`)):(o.load.image(l,c),o.load.once(`filecomplete-image-${l}`,()=>{i(),n&&console.log(`ðŸ§© Loaded tile: ${l} from ${c}`)}))}function te(o,e,t,s){o.forEach(i=>{let n=t||i.lazyLoad===!0;s!==void 0&&(s===!0||Array.isArray(s)&&s.includes(i.name))&&(n=!0);const a=n?e.lazyLoad:e.initialLoad;switch(i.category){case"tileset":a.tiles.push(i);break;case"sprite":a.sprites.push(i);break;case"zone":a.zones.push(i);break;case"point":a.points.push(i);break;case"group":a.groups.push(i),Array.isArray(i.children)&&te(i.children,e,n,s);break}})}function Se(o){return{load(e,t,s,i){const n=`${s}/data.json`;e.load.json(t,n),e.load.once(`filecomplete-json-${t}`,(a,r,l)=>{l?Pe(e,t,l,s,o,i):console.error(`Loaded JSON is empty or invalid for key: ${t}`)}),e.load.once("loaderror",a=>{a.key===t&&console.error(`Failed to load JSON file: ${n}`)}),e.load.isLoading()||e.load.start()},loadMultiple:$e(o)}}function oe(o,e,t){const s=o.getData(e);if(!s||!s.lazyLoad)return!1;const n={sprite:"sprites",tileset:"tiles",zone:"zones",point:"points",group:"groups"}[t.category];if(!n)return!1;const a=s.lazyLoad[n];return a?a.some(r=>r.name===t.name):!1}function K(o,e,t){const s=o.add.container(e.x,e.y);if(t.isDebugEnabled("shape")){const i=o.add.graphics();i.lineStyle(2,16711935,1),i.strokeRect(0,0,e.width,e.height),s.add(i)}if(t.isDebugEnabled("label")){const i=o.add.text(0,-20,`${e.name} (Lazy)`,{fontSize:"16px",color:"#ff00ff",backgroundColor:"#ffffff"});s.add(i)}return s}function I(o,e){o.attributes&&(e.attributes=o.attributes)}function R(o,e,t){if(!z(e))return null;const s=`${e.name}_mask`;if(!o.textures.exists(s))return console.warn(`Mask texture not found: ${s}`),null;const i=o.add.image(e.x,e.y,s);i.setOrigin(0,0),i.setVisible(!1);const n=i.createBitmapMask();return t.setMask&&t.setMask(n),i}function Ge(o,e,t){if(!z(e))return null;const s=`${e.name}_mask`;if(!o.textures.exists(s))return console.warn(`Mask texture not found: ${s}`),null;const i=o.add.image(e.x,e.y,s);i.setOrigin(0,0),i.setVisible(!1);const n=i.createBitmapMask();return t.setMask(n),i}function Ce(o,e,t,s,i,n,a){const r=o.add.container(e.x,e.y);if(r.setName(e.name),r.setData("tileData",e),r.setData("tileSliceSize",s),r.setData("psdKey",a),r.setDepth(e.initialDepth??0),I(e,r),["setX","setY","setPosition","setBlendMode","setAlpha","setDepth","setMask"].forEach(d=>{ze(r,d)}),oe(t,a,e)){const d=K(o,e,t);d&&r.add(d)}else{const d=t.getData(a),h=(d==null?void 0:d.isMultiplePsd)||!1;Ee(o,r,e,s,h,a)}Ge(o,e,r),i.add(r);const f=o.add.group();Te(o,e,s,f,t),i.debugGroup=f}function Ee(o,e,t,s,i=!1,n){for(let a=0;a<t.columns;a++)for(let r=0;r<t.rows;r++){const l=a*s,c=r*s,d=`${i&&n?`${n}_${t.name}`:t.name}_tile_${a}_${r}`,h=se(o,{x:l,y:c,key:d,initialDepth:t.initialDepth},e);h&&e.add(h)}}function ze(o,e){const t=Phaser.GameObjects.Container.prototype[e];o[e]=function(...s){const i=t.apply(this,s);if(["setX","setY","setPosition"].includes(e)){const a=e==="setX"||e==="setPosition"?s[0]-this.x:0,r=e==="setY"?s[0]-this.y:e==="setPosition"?s[1]-this.y:0;this.each(l=>{a!==0&&(l.x+=a),r!==0&&(l.y+=r)})}else this.each(a=>{typeof a[e]=="function"&&a[e](...s)});const n=this.getData("pendingMethodCalls")||[];return n.push({method:e,args:s}),this.setData("pendingMethodCalls",n),i}}function se(o,e,t){if(o.textures.exists(e.key)){const s=o.add.image(e.x,e.y,e.key);return s.setOrigin(0,0),(t instanceof Phaser.GameObjects.Group||t instanceof Phaser.GameObjects.Container)&&t.add(s),s}else return console.warn(`Texture not found for tile: ${e.key}`),null}function Te(o,e,t,s,i){if(i.isDebugEnabled("shape")){const a=o.add.graphics();a.setDepth(1e3),a.lineStyle(2,16711680,1),a.strokeRect(e.x,e.y,e.columns*t,e.rows*t),a.isDebugObject=!0,s.add(a)}if(i.isDebugEnabled("label")){const a=o.add.text(e.x,e.y-20,e.name,{fontSize:"16px",color:"#ff0000",backgroundColor:"#ffffff"});a.setDepth(1e3),a.isDebugObject=!0,s.add(a)}}function Ne(o,e,t,s,i){const n=o.add.sprite(e.x,e.y,i||e.name);return n.setName(e.name),n.setOrigin(0,0),n.setDepth(e.initialDepth??0),I(e,n),e.frame!==void 0&&n.setFrame(e.frame),R(o,e,n),n}function Oe(o,e,t,s,i){const n=o.add.group();n.name=e.name;const a=i||e.name;if(o.textures.exists(a)){const l=o.textures.get(a).getFrameNames(),c=Object.keys(e.frames).reduce((f,d,h)=>(f[d]=h,f),{});e.instances&&e.instances.forEach(f=>{const{name:d,x:h,y:x}=f,w=c[d];if(w!==void 0&&w<l.length){const v=l[w],m=o.add.sprite(h,x,a,v);m.setName(d),m.setOrigin(0,0),n.add(m),m.setDepth(e.initialDepth??0),t.isDebugEnabled("console")&&console.log(`Placed spritesheet instance: ${d}, at (${h}, ${x}), using frame: ${v}`)}else console.warn(`Frame for "${d}" not found in spritesheet "${a}"`)})}else console.error(`Texture "${a}" not found. Make sure the spritesheet is loaded correctly.`);return n.setDepth(e.initialDepth??0),I(e,n),e.mask&&e.maskPath&&n.getChildren().forEach(r=>{R(o,e,r)}),n}function Ie(o,e,t,s,i){const n=o.add.group();n.name=e.name;const a=i||e.name;if(o.textures.exists(a)){const l=o.textures.get(a).getFrameNames();e.instances&&e.instances.forEach(c=>{const{name:f,x:d,y:h}=c;if(l.includes(f)){const x=o.add.sprite(d,h,a,f);x.setName(f),x.setOrigin(0,0),n.add(x),x.setDepth(e.initialDepth??0)}else console.warn(`Frame "${f}" not found in atlas "${a}"`)})}else console.error(`Texture "${a}" not found. Make sure the atlas is loaded correctly.`);return n.setDepth(e.initialDepth??0),I(e,n),e.mask&&e.maskPath&&n.getChildren().forEach(r=>{R(o,e,r)}),n}function Be(o,e,t,s,i,n){var l,c,f,d,h,x,w,v;const a=i||e.name,r=o.add.sprite(e.x,e.y,a,0);if(r.setName(e.name),r.setOrigin(0,0),r.setDepth(e.initialDepth??0),I(e,r),R(o,e,r),e.frame_width&&e.frame_height){const m={key:a,frames:o.anims.generateFrameNumbers(a,{start:0,end:e.frame_count?e.frame_count-1:-1}),frameRate:((l=e.attributes)==null?void 0:l.frameRate)||24,repeat:((c=e.attributes)==null?void 0:c.repeat)!==void 0?e.attributes.repeat:-1};((f=e.attributes)==null?void 0:f.yoyo)!==void 0&&(m.yoyo=e.attributes.yoyo),((d=e.attributes)==null?void 0:d.delay)!==void 0&&(m.delay=e.attributes.delay),((h=e.attributes)==null?void 0:h.repeatDelay)!==void 0&&(m.repeatDelay=e.attributes.repeatDelay),((x=e.attributes)==null?void 0:x.duration)!==void 0&&(m.duration=e.attributes.duration),((w=e.attributes)==null?void 0:w.showOnStart)!==void 0&&(m.showOnStart=e.attributes.showOnStart),((v=e.attributes)==null?void 0:v.hideOnComplete)!==void 0&&(m.hideOnComplete=e.attributes.hideOnComplete),n&&(Object.assign(m,n),m.key=a,n.frames||(m.frames=o.anims.generateFrameNumbers(a,{start:0,end:e.frame_count?e.frame_count-1:-1}))),o.anims.exists(a)||o.anims.create(m),r.play(a)}return r}function ne(o,e,t,s,i,n,a){if(e.lazyLoad){const c=K(o,e,t);c&&s.add(c),i();return}const r=t.getData(n),l=r!=null&&r.isMultiplePsd?`${n}_${e.name}`:e.name;if(o.textures.exists(l)){let c=null;switch(e.type){case"spritesheet":c=Oe(o,e,t,n,l);break;case"atlas":c=Ie(o,e,t,n,l);break;case"animation":c=Be(o,e,t,n,l,a);break;default:c=Ne(o,e,t,n,l);break}if(c){c instanceof Phaser.GameObjects.Group?c.getChildren().forEach(d=>{s.add(d)}):s.add(c),e.alpha!==void 0&&c.setAlpha(e.alpha),e.hidden!==void 0&&c.setVisible(!1),c.setDepth(e.initialDepth||0);const f=o.add.group();Re(o,e,f,t),s.debugGroup=f}else console.error(`Failed to place sprite: ${e.name}`)}else console.warn(`Texture not found for sprite: ${e.name} (looking for texture key: ${l})`);i()}function Re(o,e,t,s){if(s.isDebugEnabled("shape")){const n=o.add.graphics();n.setDepth(1e3),n.lineStyle(2,65280,1),n.strokeRect(e.x,e.y,e.width,e.height),n.isDebugObject=!0,t.add(n)}if(s.isDebugEnabled("label")){const n=o.add.text(e.x,e.y-20,e.name,{fontSize:"16px",color:"#00ff00",backgroundColor:"#ffffff"});n.setDepth(1e3),n.isDebugObject=!0,t.add(n)}}function Ve(o,e,t,s,i,n){const a=Xe(o,e);if(a){s.add(a);const r=o.add.group();Fe(o,e,r,t),s.debugGroup=r}}function Xe(o,e){const t=W(e);let s,i;if(t instanceof Phaser.Geom.Polygon){const n=Phaser.Geom.Polygon.GetAABB(t);s=o.add.zone(n.x,n.y,n.width,n.height),i=t.points}else s=o.add.zone(t.x,t.y,t.width,t.height),i=[new Phaser.Geom.Point(t.x,t.y),new Phaser.Geom.Point(t.x+t.width,t.y),new Phaser.Geom.Point(t.x+t.width,t.y+t.height),new Phaser.Geom.Point(t.x,t.y+t.height)];return s.setName(e.name||"unnamed_zone"),I(e,s),s.setData("points",i),s.setData("category",e.category),s.setData("x",e.x),s.setData("y",e.y),s.setData("width",e.width),s.setData("height",e.height),e.initialDepth!==void 0&&s.setData("initialDepth",e.initialDepth),e.attributes&&s.setData("attributes",e.attributes),s}function W(o){if(o.subpaths&&Array.isArray(o.subpaths)&&o.subpaths.length>0&&Array.isArray(o.subpaths[0])){const e=o.subpaths[0].flatMap(t=>new Phaser.Geom.Point(t[0],t[1]));return new Phaser.Geom.Polygon(e)}else if(o.bbox&&typeof o.bbox=="object"){const{left:e,top:t,right:s,bottom:i}=o.bbox;if(typeof e=="number"&&typeof t=="number"&&typeof s=="number"&&typeof i=="number")return new Phaser.Geom.Rectangle(e,t,s-e,i-t)}return console.error("Unable to create zone shape. Invalid zone data:",o),new Phaser.Geom.Rectangle(0,0,1,1)}function Fe(o,e,t,s){if(s.isDebugEnabled("shape")){const n=W(e),a=o.add.graphics();a.lineStyle(2,255,1),n instanceof Phaser.Geom.Polygon?a.strokePoints(n.points,!0):a.strokeRect(n.x,n.y,n.width,n.height),a.setDepth(1e3),a.isDebugObject=!0,t.add(a)}if(s.isDebugEnabled("label")){const n=W(e);let a,r;if(n instanceof Phaser.Geom.Polygon){const c=Phaser.Geom.Polygon.GetAABB(n);a=c.centerX,r=c.centerY}else a=n.centerX,r=n.centerY;const l=o.add.text(a,r,e.name,{fontSize:"16px",color:"#0000ff",backgroundColor:"#ffffff"});l.setOrigin(.5),l.setDepth(1e3),l.isDebugObject=!0,t.add(l)}}function Ye(o,e,t,s,i,n){const a=je(o,e);if(a){s.add(a);const r=o.add.group();Je(o,e,r,t),s.debugGroup=r}}function je(o,e){const t=o.add.container(e.x,e.y);return t.setData("pointData",e),t.setName(e.name),I(e,t),t}function Je(o,e,t,s){if(s.isDebugEnabled("shape")){const n=o.add.circle(e.x,e.y,5,16711680);n.setStrokeStyle(2,16711680),n.setDepth(1e3),n.isDebugObject=!0,t.add(n)}if(s.isDebugEnabled("label")){const n=o.add.text(e.x,e.y-20,e.name,{fontSize:"16px",color:"#ff0000",backgroundColor:"#ffffff"});n.setOrigin(.5,1),n.setDepth(1e3),n.isDebugObject=!0,t.add(n)}}const ie=["setAlpha","setAngle","setActive","setAlpha","setBlendMode","setDepth","setDisplaySize","setFlip","setMask","setOrigin","setPipeline","setPosition","setRotation","setScale","setScrollFactor","setSize","setTint","setVisible","setX","setY","setZ"];function Ke(o,e){e instanceof Phaser.GameObjects.Group?We(o,e):Ze(o,e)}function We(o,e){ie.forEach(t=>{e[t]=He(o,t)})}function Ze(o,e){ie.forEach(t=>{t==="remove"&&(e[t]=(s={})=>{e.removedFromScene()})})}function He(o,e){return function(...t){const s=typeof t[t.length-1]=="object"&&!Array.isArray(t[t.length-1])?t.pop():{},i=s.depth!==void 0?s.depth:1/0;ae(this,e,t,i,0)}}function ae(o,e,t,s,i){i>s||(o instanceof Phaser.GameObjects.Group?i<s&&o.getChildren().forEach(a=>{ae(a,e,t,s,i+1)}):typeof o[e]=="function"&&o[e](...t))}function Ue(o){return function(t,s={}){let i,n=1/0;typeof t=="string"?(i=t,n=s.depth!==void 0?s.depth:1/0):typeof t=="object"&&(n=t.depth!==void 0?t.depth:1/0);let a=!1;const r=(c,f=0)=>{if(!(f>=n)){if(c instanceof Phaser.GameObjects.Group&&(c.getChildren().forEach(d=>r(d,f+1)),f===n)){c.clear(),a=!0;return}"parentContainer"in c&&c.parentContainer?c.parentContainer.remove(c):c.scene&&c.scene.children.remove(c),typeof c.destroy=="function"&&c.destroy(!0),a=!0}},l=(c,f)=>{if(f.length===0)return r(c),!0;if(c instanceof Phaser.GameObjects.Group){const d=f[0],h=c.getChildren().find(x=>x.name===d);if(h)return l(h,f.slice(1))}return!1};if(i){const c=i.split("/");a=l(this,c)}else r(this);return a||console.warn(`Object not found or already removed: ${i||"root"}`),a}}function qe(o,e){e.remove=Ue()}function Qe(o,e){e instanceof Phaser.GameObjects.Group?tt(o,e):e instanceof Phaser.GameObjects.Sprite&&et(o,e)}function et(o,e){e.updateAnimation=function(t){return re(e,t)}}function tt(o,e){e.updateAnimation=function(t){function s(i){i instanceof Phaser.GameObjects.Sprite&&i.anims&&i.anims.currentAnim?re(i,t):i instanceof Phaser.GameObjects.Group&&i.getChildren().forEach(s)}return s(e),e}}function re(o,e){var a;const t=(a=o.anims.currentAnim)==null?void 0:a.key;if(!t)return console.warn("No animation currently playing on sprite"),o;const s=o.scene,i=s.anims.get(t);if(!i)return console.warn(`Animation ${t} not found`),o;const n={key:t,frames:i.frames.map(r=>({key:r.textureKey,frame:r.textureFrame})),frameRate:i.frameRate,duration:i.duration,repeat:i.repeat,repeatDelay:i.repeatDelay,yoyo:i.yoyo,showOnStart:i.showOnStart,hideOnComplete:i.hideOnComplete,...e};return n.key=t,s.anims.remove(t),s.anims.create(n),o.play(t),o}function ot(o){return function(t,s={}){if(!t)return this;const i=t.split("/"),n=s.depth!==void 0?s.depth:1/0;function a(l,c,f){if(f>n||c.length===0)return null;const[d,...h]=c;let x;if(l instanceof Phaser.GameObjects.Group)x=l.getChildren();else if(l instanceof Phaser.GameObjects.Container)x=l.list;else return null;const w=x.filter(v=>!v.isDebugObject);for(const v of w)if(v.name===d){if(h.length===0)return v;if(v instanceof Phaser.GameObjects.Group||v instanceof Phaser.GameObjects.Container)return a(v,h,f+1)}for(const v of w)if(v instanceof Phaser.GameObjects.Group||v instanceof Phaser.GameObjects.Container){const m=a(v,c,f+1);if(m)return m}return null}let r=null;return this instanceof Phaser.GameObjects.Group||this instanceof Phaser.GameObjects.Container?r=a(this,i,0):r=this.name===i[0]?this:null,r?le(o,r):console.warn(`Item not found at path: ${t}`),r}}function st(o,e){e.target=ot(o)}function le(o,e){Ke(o,e),qe(o,e),Qe(o,e),st(o,e)}function F(o,e){if(e.length===0)return null;const[t,...s]=e,i=o.find(n=>n.name===t);return i?s.length===0?i:j(i)?F(i.children,s):null:null}function nt(o){return function(t,s,i,n={}){const a=o.getData(s);if(!a||!a.original)return console.error(`No data found for key: ${s}`),t.add.group();const r=a.original.tile_slice_size||150,l=t.add.group(),c=F(a.original.layers,i.split("/"));if(!c)return console.error(`No layer found with path: ${i}`),l;const f=ce(t,c,o,r,l,s,n);return le(o,f),t.events.emit("layerPlaced",i),f}}function ce(o,e,t,s,i,n,a){if(j(e)){if(a.depth===void 0||a.depth>0){const l=o.add.group();return l.name=e.name,e.children.forEach(c=>{const f=ce(o,c,t,s,l,n,{...a,depth:a.depth!==void 0?a.depth-1:void 0});f instanceof Phaser.GameObjects.GameObject&&l.add(f)}),z(e)&&l.getChildren().forEach(c=>{R(o,e,c)}),i.add(l),l}return i}if(oe(t,n,e)){const l=K(o,e,t);return l&&i.add(l),i}return O(e)?(Ce(o,e,t,s,i,()=>{},n),i):S(e)?(ne(o,e,t,i,()=>{},n,a.animationOptions),i):Z(e)?(Ve(o,e,t,i),i):H(e)?(Ye(o,e,t,i),i):(console.error(`Unknown layer category: ${e.category}`),i)}function it(o){return function(t,s,i){const n=o.getData(s);if(!n)return console.log(`No PSD data found for key: ${s}`),null;const a=i.split("/"),r=F(n.original.layers,a);if(!r)return console.log(`Sprite not found: ${i}`),console.log(`Available sprites: ${JSON.stringify(n.original.layers.map(d=>d.name))}`),null;if(!S(r))return console.log(`Layer "${i}" is not a sprite layer`),null;const c=n.isMultiplePsd||!1?`${s}_${r.name}`:r.name;if(t.textures.exists(c))return t.textures.get(c);const f=`${n.basePath}/${r.filePath}`;return t.load.image(c,f),t.load.once(`filecomplete-image-${c}`,()=>{console.log(`Texture loaded: ${c}`)}),t.load.start(),t.load.once("complete",()=>{console.log(`Load complete for: ${c}`)}),t.textures.exists(c)?t.textures.get(c):(console.log(`Failed to load texture: ${c}`),null)}}function at(o){return function(t,s,i){const n=o.getData(s);if(!n)return console.log(`No PSD data found for key: ${s}`),null;const a=i.split("/"),r=F(n.original.layers,a);if(!r)return console.log(`Layer not found: ${i}`),null;if(!z(r))return console.log(`Layer "${i}" does not have a mask`),null;const l=`${r.name}_mask`;if(!t.textures.exists(l)){const d=`${n.basePath}/${r.maskPath}`;return t.load.image(l,d),t.load.once(`filecomplete-image-${l}`,()=>{o.isDebugEnabled("console")&&console.log(`ðŸŽ­ Loaded mask on-demand: ${l}`)}),t.load.start(),console.log(`Mask texture "${l}" is being loaded. Call getMask again after load completes.`),null}const c=t.add.image(r.x,r.y,l);c.setOrigin(0,0),c.setVisible(!1);const f=c.createBitmapMask();return{maskImage:c,bitmapMask:f}}}function rt(o,e,t={}){const s=e.scene;let i=!1,n=!1,a=new Phaser.Math.Vector2,r=new Phaser.Math.Vector2,l=new Phaser.Math.Vector2;const f={...{easeDragging:!1,friction:.95,minSpeed:.1,ignore:[]},...t};function d(){f.useBounds&&(typeof f.useBounds=="object"?(console.log("using custom size"),e.setBounds(f.useBounds.x,f.useBounds.y,f.useBounds.width,f.useBounds.height)):console.warn("useBounds object must have {x, y, width, height} format"))}function h(p){const $=[];let k=p;for(;k;)k.name&&$.unshift(k.name),k=k.parentContainer||null;return $.join("/")}function x(p){if(!f.ignore||f.ignore.length===0)return!1;const $=h(p),k=p.name||"";for(const _ of f.ignore)if(k===_||$===_||$.endsWith("/"+_)||$.startsWith(_+"/")||$===_||$.includes("/"+_+"/"))return!0;return!1}function w(p){if(!f.ignore||f.ignore.length===0)return!1;const $=s.input.hitTestPointer(p);for(const k of $)if(x(k))return!0;return!1}function v(p){n||w(p)||(i=!0,l.copy(p),a.copy(p),r.reset(),s.events.emit("draggableStart",e))}function m(p){if(!i)return;const $=p.x-a.x,k=p.y-a.y;e.scrollX-=$/e.zoom,e.scrollY-=k/e.zoom,r.set(-$,-k),a.copy(p),s.events.emit("draggableActive",e)}function L(){i=!1,f.easeDragging||r.reset(),s.events.emit("draggableComplete",e)}function M(){!i&&f.easeDragging&&(r.length()>f.minSpeed?(e.scrollX+=r.x/e.zoom,e.scrollY+=r.y/e.zoom,r.scale(f.friction),s.events.emit("draggableActive",e)):r.reset())}function P(){s.input.on("pointerdown",v),s.input.on("pointermove",m),s.input.on("pointerup",L),s.events.on("update",M)}return P(),d(),{isDragging:()=>i,isPaused:()=>n,getVelocity:()=>r.clone(),setOptions:p=>{Object.assign(f,p),d(),f.easeDragging||r.reset()},pause:()=>{n=!0,i&&(i=!1,r.reset(),s.events.emit("draggableComplete",e))},resume:()=>{n=!1}}}function lt(o,e,t={}){var B;const s=e.scene,i=t.targetKeys||ct(o);if(i.length===0)return console.warn("No PSDs found for lazy loading"),{};const n=[];if(i.forEach(u=>{const y=o.getData(u);if(y&&y.lazyLoad&&(y.lazyLoad.sprites&&y.lazyLoad.sprites.forEach(D=>{n.push({...D,_psdKey:u})}),y.lazyLoad.tiles)){const D=y.original.tile_slice_size??150;y.lazyLoad.tiles.forEach(g=>{_(g,D).forEach(b=>{n.push({...b,_psdKey:u})})})}}),n.length===0)return(B=t.debug)!=null&&B.console&&console.log("No lazy load items found in target PSDs:",i),{};let a,r=null,l=[],c=new Set,f=null,d=null;function h(){var u,y;t.createBoundaryCamera&&x(),w(),v(),((u=t.debug)!=null&&u.shape||(y=t.debug)!=null&&y.label)&&m(),M(),C()}function x(){d=s.cameras.add(),d.setVisible(!1),d.setZoom(1),d.setScroll(e.scrollX,e.scrollY),d.setSize(e.width,e.height)}function w(){const u=t.extendPreloadBounds||0;if(d){d.setScroll(e.scrollX,e.scrollY);const y=e.width/e.zoom,D=e.height/e.zoom,g=e.scrollX+e.width/2,b=e.scrollY+e.height/2;a=new Phaser.Geom.Rectangle(g-y/2-u,b-D/2-u,y+u*2,D+u*2)}else{const y=e.width/e.zoom,D=e.height/e.zoom;a=new Phaser.Geom.Rectangle(e.scrollX-u,e.scrollY-u,y+u*2,D+u*2)}}function v(){var y,D;const u=g=>{const b=s.add.rectangle(g.x,g.y,g.width,g.height);return b.setOrigin(0,0),b.setStrokeStyle(1,65280),b.setDepth(1e3),{boundary:b,data:{...g,loaded:!1}}};l=n.map(u),(y=t.debug)!=null&&y.shape?l.forEach(g=>g.boundary.setVisible(!0)):l.forEach(g=>g.boundary.setVisible(!1)),(D=t.debug)!=null&&D.label&&l.forEach(g=>{const b=s.add.text(g.boundary.x,g.boundary.y-20,g.data.name,{fontSize:"12px",color:"#00ffff",backgroundColor:"#000000"});b.setOrigin(0,1),b.setDepth(1001)})}function m(){r=s.add.graphics(),r.setDepth(1e3),L()}function L(){r&&(r.clear(),r.lineStyle(2,16711935,1),r.strokeRect(a.x,a.y,a.width,a.height))}function M(){var y;const u=l.filter(({boundary:D,data:g})=>!g.loaded&&!c.has(P(g))&&Phaser.Geom.Intersects.RectangleToRectangle(D.getBounds(),a));u.length>0&&((y=t.debug)!=null&&y.console&&console.log(`LazyLoad: ${u.length} objects to load`),s.events.emit("lazyLoadStart",u.length),u.forEach(p))}function P(u){if(!u)return"unknown";const y=u.category||u.type;return y==="tile"||y==="tileset"?`tile_${u.tilesetName||u.name}_${u.col}_${u.row}`:`sprite_${u.name}_${Math.round(u.x)}_${Math.round(u.y)}`}function p({data:u}){var b;const y=P(u);c.add(y);const D=u._psdKey;(b=t.debug)!=null&&b.console&&console.log(`LazyLoad: Loading object ${y} from PSD ${D}`);const g={sprites:u.category==="sprite"?[u]:[],tiles:[],groups:[],singleTiles:u.category==="tile"||u.category==="tileset"?[u]:[]};q(s,D,g,o),s.load.once("complete",()=>{$(u)}),s.load.start()}function $(u){var b,E,T;const y=P(u);if(c.delete(y),u.loaded=!0,(b=t.debug)!=null&&b.console&&console.log(`LazyLoad: Object loaded ${y}`),u.category==="sprite"){const A=s.add.group();ne(s,u,o,A,()=>{A.getChildren().forEach(V=>{V.setDepth&&u.initialDepth!==void 0&&V.setDepth(u.initialDepth)}),s.children.sort("depth")},u._psdKey)}else if(u.category==="tile"||u.category==="tileset"){const A=k(s,u);se(s,{x:u.x-A.x,y:u.y-A.y,key:`${u.tilesetName}_tile_${u.col}_${u.row}`,initialDepth:u.initialDepth,tilesetName:u.tilesetName,col:u.col,row:u.row},A)}const D=l.filter(({data:A})=>A.loaded).length/l.length,g=Array.from(c);s.events.emit("lazyLoadProgress",D,g),(E=t.debug)!=null&&E.console&&console.log(`LazyLoad: Progress ${D.toFixed(2)}, Remaining:`,g),l.every(({data:A})=>A.loaded)&&(s.events.emit("lazyLoadingComplete"),(T=t.debug)!=null&&T.console&&console.log("LazyLoad: All objects loaded")),L()}function k(u,y){const D=u.children.list.find(T=>T instanceof Phaser.GameObjects.Container&&T.name===y.tilesetName);if(D)return D;const g=y.x-y.col*y.tile_slice_size,b=y.y-y.row*y.tile_slice_size,E=u.add.container(g,b);return E.setName(y.tilesetName),E.setDepth(y.initialDepth),E}function _(u,y){const D=[];for(let g=0;g<u.columns;g++)for(let b=0;b<u.rows;b++)D.push({category:"tile",name:`${u.name}_tile_${g}_${b}`,x:u.x+g*y,y:u.y+b*y,width:y,height:y,tile_slice_size:y,filetype:u.filetype||"png",tilesetName:u.name,col:g,row:b,initialDepth:u.initialDepth});return D}function C(){const u=t.checkInterval||300;f=window.setInterval(()=>{Y()},u)}function Y(){var u,y;w(),M(),((u=t.debug)!=null&&u.shape||(y=t.debug)!=null&&y.label)&&L()}return h(),{update:Y,destroy:()=>{f!==null&&(window.clearInterval(f),f=null),l.forEach(u=>u.boundary.destroy()),r&&r.destroy(),d&&(s.cameras.remove(d),d=null)}}}function ct(o){return o.getAllKeys()}function ft(o,e,t,s={}){const i=e;if(t.includes("draggable")&&Object.assign(i,rt(o,e,s.draggable)),t.includes("lazyLoad")){const n=typeof s.lazyLoad=="boolean"?{}:s.lazyLoad??{};Object.assign(i,lt(o,e,n))}return i}function ut(o){return function(e){let t,s;if(Array.isArray(e))if(e.length===2)typeof e[1]=="function"?(t={normal:e[0]},s={click:e[1]}):(t=e[0],s=e[1]);else if(e.length===3)t={normal:e[0],hover:e[1]},s={click:e[2]};else{console.error("Button: Invalid array format");return}else{console.error("Button: Invalid input format");return}if(!t.normal){console.error("Button requires at least a normal image");return}let i=t.normal,n=t.normal;if(n instanceof Phaser.GameObjects.Group){const m=n.getChildren();if(m.length===0){console.error("Button target group is empty");return}i=m[0]}else if(n instanceof Phaser.GameObjects.Container){if(n.list.length===0){console.error("Button target container is empty");return}i=n.list[0]}const a=i.scene;if(!a){console.error("Button target must have a valid scene");return}if(typeof i.setInteractive!="function"){console.error("Button target does not support interaction:",i.constructor.name);return}let r="normal";const l=i;let c,f,d,h;if(typeof l.getBounds=="function"){const m=l.getBounds();c=m.centerX||m.x+m.width/2,f=m.centerY||m.y+m.height/2,d=m.width,h=m.height}else c=l.x||0,f=l.y||0,d=l.width||l.displayWidth||100,h=l.height||l.displayHeight||100;const x=a.add.rectangle(c,f,d,h,0,0);x.setInteractive(),x.setDepth(Number.MAX_SAFE_INTEGER),x.setVisible(!0),t.normal&&t.normal.setVisible(!0),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);function w(m){t.normal&&t.normal.setVisible(!1),t.hover&&t.hover.setVisible(!1),t.active&&t.active.setVisible(!1);const L=t[m];L?L.setVisible(!0):t.normal&&t.normal.setVisible(!0),r=m}const v=a.sys.game.device.input.touch;return x.on("pointerdown",(m,L,M,P)=>{t.active&&w("active"),s.mousePress&&s.mousePress(n,{localX:L,localY:M,event:P},m)}),x.on("pointerup",(m,L,M,P)=>{var p;t.active&&(!v&&t.hover&&((p=x.input)!=null&&p.isOver)?w("hover"):w("normal")),s.click&&s.click(n,{localX:L,localY:M,event:P},m)}),!v&&t.hover&&(x.on("pointerover",(m,L,M,P)=>{w("hover"),s.mouseOver&&s.mouseOver(n,{localX:L,localY:M,event:P},m)}),x.on("pointerout",(m,L)=>{r!=="active"&&(w("normal"),s.mouseOut&&s.mouseOut(n,{event:L},m))})),r="normal",{destroy:()=>{x.off("pointerover"),x.off("pointerout"),x.off("pointerdown"),x.off("pointerup"),x.destroy()},getCurrentState:()=>r,showState:m=>{w(m)}}}}function dt(o){return function(e,t,s={}){const i=e.scene;if(!i){console.error("Unable to determine scene for fillZone");return}const n=e.getData("points");if(!n||n.length===0){console.error("Zone does not have valid points data");return}const a=new Phaser.Geom.Polygon(n),r=Phaser.Geom.Polygon.GetAABB(a);let l,c;if(t instanceof Phaser.GameObjects.Group){const M=t.getChildren()[0];if(!M){console.error("Group is empty");return}l=M.texture.key,c=s.useFrames||[M.frame.name]}else l=t.texture.key,c=s.useFrames||[t.frame.name];const f=i.textures.get(l);if(!f){console.error(`Texture not found: ${l}`);return}if(!c||c.length===0){const M=f.getFrameNames();M.length>0?c=M:c=Array.from({length:f.frameTotal},(P,p)=>p)}const d=i.add.group(),h=s.minInstances!==void 0?s.minInstances:5,x=s.maxInstances!==void 0?s.maxInstances:10,w=Phaser.Math.Between(h,x);let v=0,m=w*10,L=0;for(;v<w&&L<m;){const M=Phaser.Math.Between(r.left,r.right),P=Phaser.Math.Between(r.top,r.bottom);if(Phaser.Geom.Polygon.Contains(a,M,P)){const p=Phaser.Math.RND.pick(c),$=i.add.sprite(M,P,l,p);if(s.scaleRange){const k=Phaser.Math.FloatBetween(s.scaleRange[0],s.scaleRange[1]);$.setScale(k)}if(s.tint&&s.tint.length>0){const k=Phaser.Math.RND.pick(s.tint);$.setTint(k)}d.add($),v++}L++}return console.log(`fillZone completed. Sprites placed: ${v}, Target: ${w}, Attempts: ${L}`),d}}function ht(o){return function(e,t,s,i={}){const n=t.scene,a=i.bounceBack||!1,r=i.joystickRadius||50;e.setOrigin(.5,.5),e.setPosition(e.x+e.width/2,e.y+e.height/2);const l={x:e.x,y:e.y},c=t.getData("points"),f=c?new Phaser.Geom.Polygon(c):t.getBounds();let d=null;const h=(P,p)=>{const $=fe(f),k=new Phaser.Math.Vector2(P-$.x,p-$.y);k.length()>r&&k.setLength(r);const C={x:$.x+k.x,y:$.y+k.y};return c?Phaser.Geom.Polygon.Contains(f,C.x,C.y)?C:gt(f,C.x,C.y):{x:Phaser.Math.Clamp(C.x,f.left,f.right),y:Phaser.Math.Clamp(C.y,f.top,f.bottom)}},x=(P,p)=>{const $=fe(f);return{x:(P-$.x)/r,y:(p-$.y)/r}},w=(P,p)=>P.x>=p.left&&P.x<=p.right&&P.y>=p.top&&P.y<=p.bottom,v=P=>{d===null&&w(P,e.getBounds())&&(d=P,n.events.emit("joystickStart",{[s]:{isActive:!0,position:{x:e.x,y:e.y},change:{x:0,y:0},normalized:{x:0,y:0}}}))},m=P=>{if(P===d){const{x:p,y:$}=h(P.x,P.y);e.setPosition(p,$);const k={x:p-l.x,y:$-l.y},_=x(p,$);n.events.emit("joystickActive",{[s]:{isActive:!0,position:{x:p,y:$},change:k,normalized:_}})}},L=P=>{P===d&&(d=null,a?n.tweens.add({targets:e,x:l.x,y:l.y,duration:300,ease:"Bounce.out",onComplete:()=>{n.events.emit("joystickRelease",{[s]:{isActive:!1,position:l,change:{x:0,y:0},normalized:{x:0,y:0}}})}}):n.events.emit("joystickRelease",{[s]:{isActive:!1,position:{x:e.x,y:e.y},change:{x:e.x-l.x,y:e.y-l.y},normalized:x(e.x,e.y)}}))};n.input.on("pointerdown",v),n.input.on("pointermove",m),n.input.on("pointerup",L),n.input.on("pointerupoutside",L);function M(){n.input.off("pointerdown",v),n.input.off("pointermove",m),n.input.off("pointerup",L),n.input.off("pointerupoutside",L)}return{control:(P,p)=>{let $=new Phaser.Math.Vector2,k=0;const _=new Phaser.Math.Vector2(P.x,P.y),C=new Phaser.Math.Vector2(l.x,l.y),Y=(g,b)=>{if(!p.directionLock)return[g,b];if(p.directionLock===4)return Math.abs(g)>Math.abs(b)?[g,0]:[0,b];if(p.directionLock===8){const E=Math.atan2(b,g),A=Math.round(8*E/(2*Math.PI)+8)%8*Math.PI/4;return[Math.cos(A),Math.sin(A)]}return[g,b]},B=(g,b,E)=>{switch([g,b]=Y(g,b),p.type){case"speed":const T=p.maxSpeed||300;P.x+=g*T*E/1e3,P.y+=b*T*E/1e3;break;case"velocity":const A=P.body;if(A){const X=p.force||1;A.setVelocity(g*X*60,b*X*60)}break;case"unit":const V=n.time.now,Pt=p.repeatRate||0,ue=p.pixels||100,de=.2;if((Math.abs(g)>de||Math.abs(b)>de)&&(k===0||V-k>=Pt)){const X=Math.atan2(b,g);P.x+=Math.round(Math.cos(X)*ue),P.y+=Math.round(Math.sin(X)*ue),k=V}break;case"tracked":const he=p.multiplier||1,$t=(g-C.x)*he,vt=(b-C.y)*he;P.setPosition(_.x+$t,_.y+vt);break}},u=g=>{if(g[s])if(p.type==="tracked"){const b=g[s].position;B(b.x,b.y,0)}else $.set(g[s].normalized.x,g[s].normalized.y),k===0&&B($.x,$.y,0)},y=g=>{if(g[s])if($.reset(),k=0,p.type==="velocity"){const b=P.body;b&&b.setVelocity(0,0)}else p.type==="tracked"&&i.bounceBack&&P.setPosition(_.x,_.y)},D=(g,b)=>{p.type!=="tracked"&&($.x!==0||$.y!==0)&&B($.x,$.y,b)};return n.events.on("joystickActive",u),n.events.on("joystickRelease",y),n.events.on("update",D),{destroy:()=>{M(),n.events.off("joystickActive",u),n.events.off("joystickRelease",y),n.events.off("update",D)}}},destroy:M}}}function gt(o,e,t){let s=new Phaser.Geom.Point,i=Number.MAX_VALUE;for(let n=0;n<o.points.length;n++){const a=o.points[n],r=o.points[(n+1)%o.points.length],l=mt(a,r,e,t),c=Phaser.Math.Distance.Between(e,t,l.x,l.y);c<i&&(i=c,s=l)}return s}function mt(o,e,t,s){const i=e.x-o.x,n=e.y-o.y,a=((t-o.x)*i+(s-o.y)*n)/(i*i+n*n),r=Phaser.Math.Clamp(a,0,1);return new Phaser.Geom.Point(o.x+r*i,o.y+r*n)}function fe(o){let e=0,t=0;for(const s of o.points)e+=s.x,t+=s.y;return new Phaser.Geom.Point(e/o.points.length,t/o.points.length)}function pt(o){return function(e,t,s={}){const i=e.scene,a={...{targetPositionY:"center",targetPositionX:"center",targetOffset:[0,0],speed:300,easing:!0},...s};let r,l,c=0,f=0;switch(Array.isArray(t)?[r,l]=t:(r=t.x,l=t.y,c=t.width||0,f=t.height||0),r+=c/2,l+=f/2,a.targetPositionX){case"left":r+=e.width/2;break;case"right":r-=e.width/2;break}switch(a.targetPositionY){case"top":l+=e.height/2;break;case"bottom":l-=e.height/2;break}r+=a.targetOffset[0],l+=a.targetOffset[1];const d=r-e.width/2,h=l-e.height/2,x=d-e.scrollX,w=a.speed;let v=Phaser.Math.Easing.Linear;a.easing===!0?v=Phaser.Math.Easing.Cubic.InOut:typeof a.easing=="function"&&(v=a.easing),i.events.emit("panToStart"),i.tweens.add({targets:e,scrollX:d,scrollY:h,duration:w,ease:v,onUpdate:()=>{const m=1-(e.scrollX-d)/x;i.events.emit("panToProgress",m)},onComplete:()=>{i.events.emit("panToComplete")}})}}function yt(o){return function(e){const{camera:t,target:s,scrollFactor:i=.25}=e;if(!s){console.warn('[P2P parallax] No valid "target" was provided.');return}let n,a;if(typeof t=="string"){if(a=s.scene,!a){console.warn(`[P2P parallax] Could not resolve scene from target for camera "${t}".`);return}n=a.cameras.getCamera(t),n||(n=a.cameras.main)}else if(t instanceof Phaser.Cameras.Scene2D.Camera)n=t,a=n.scene;else{if(a=s.scene,!a){console.warn("[P2P parallax] Could not find scene from target to use a default camera.");return}n=a.cameras.main}if(!n){console.warn("[P2P parallax] Could not resolve a valid camera.");return}if(!a){console.warn("[P2P parallax] Could not resolve a valid scene.");return}const r=a.sys;r._parallaxItems||(r._parallaxItems=[],a.events.on("update",()=>{const l=r._parallaxItems||[];for(const c of l)c.target.x=c.initX+c.camera.scrollX*c.factor,c.target.y=c.initY+c.camera.scrollY*c.factor})),r._parallaxItems.push({target:s,camera:n,factor:i,initX:s.x,initY:s.y})}}function bt(o){return{button:ut(),fillZone:dt(),joystick:ht(),panTo:pt(),parallax:yt()}}class xt extends G.Plugins.BasePlugin{constructor(t){super(t);N(this,"psdData",{});N(this,"options");N(this,"load");N(this,"place");N(this,"getTexture");N(this,"getMask");N(this,"use");N(this,"createCamera");this.options={},console.log("%câœ¨ PSD-to-Phaser v0.0.5 âœ¨","background: black; color: white; padding: 1px 3px; border-radius: 2px;"),this.load=Se(this),this.place=nt(this),this.getTexture=it(this),this.getMask=at(this),this.use=bt(),this.createCamera=(s,i,n)=>ft(this,s,i,n)}init(t={}){this.options={debug:!1,applyAlphaAll:!1,applyBlendModesAll:!1,...t},typeof this.options.debug=="boolean"&&(this.options.debug=this.options.debug?{shape:!0,label:!0,console:!0}:!1),this.options.debug&&console.log("PsdToPhaserPlugin initialized with options:",this.options)}setData(t,s){this.psdData[t]=s,this.isDebugEnabled("console")&&console.log(`Data set for key "${t}":`,s)}getData(t){return this.psdData[t]}getAllKeys(){return Object.keys(this.psdData)}isDebugEnabled(t){return typeof this.options.debug=="object"&&!!this.options.debug[t]}}return xt}));
